<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Book a Session</title>

<link rel="stylesheet" href="styles.css">

</head>

<body>

<div class="container" id="bookingPage">
<img src="NewLogo.png" alt="Logo"
     style="display:block;margin:0 auto 2px;;width:70vw;max-width:600px;">



  <div class="month-nav">
    <span id="prevMonth">‚Üê</span>
    <span id="monthYear"></span>
    <span id="nextMonth">‚Üí</span>
  </div>

  <!-- Header actions (User Guide button) -->
  <div class="booking-header-actions" role="toolbar" aria-label="Booking actions">
    <button id="openUserGuideBtn" class="help-link" type="button">
      <span>Need help?</span>
    </button>
  </div>

  <!-- Calendar weekday header (Monday-first) -->
  <div class="calendar-head" aria-hidden="false">
    <div class="day-label">Mon</div>
    <div class="day-label">Tue</div>
    <div class="day-label">Wed</div>
    <div class="day-label">Thu</div>
    <div class="day-label">Fri</div>
    <div class="day-label">Sat</div>
    <div class="day-label">Sun</div>
  </div>

  <div class="calendar" id="calendar"></div>

  <!-- Color Legend -->
  <div class="calendar-color-legend" style="display:flex;flex-wrap:nowrap;gap:12px;align-items:center;white-space:nowrap;overflow-x:auto;">
    <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
      <div class="legend-dot" style="background:#10b981;width:14px;height:14px;min-width:14px;min-height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.2);"></div>
      <span>Session available</span>
    </div>
    <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
      <div class="legend-dot" style="background:#3b82f6;width:14px;height:14px;min-width:14px;min-height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.2);"></div>
      <span>Subsequent block sessions</span>
    </div>
    <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
      <div class="legend-dot" style="background:#ef4444;width:14px;height:14px;min-width:14px;min-height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.2);"></div>
      <span>Session full</span>
    </div>
  </div>
</div>

<!-- AVAILABLE SLOTS (Unified container for single + block slots) -->
<div class="available-slots container">
  <h2 class="available-title">SELECT A DATE</h2>
  <div class="slots" id="slots"></div>
  <div class="block-slots" id="blockSlots"></div>
</div>

<!-- NORMAL SLOTS (stays removed from here; booking form follows) -->
<div class="container">

  <!-- BLOCK SESSION CONFIRMATION (APPEARS WHEN BLOCK IS SELECTED) -->
  <h2 id="blockConfirmationTitle" class="available-title block-confirmation-title hidden">Block Session Details</h2>
  
  <!-- WAITLIST NOTICE (SHOWS WHEN SLOT IS FULLY BOOKED) -->
  <label id="waitlistNote" class="waitlist-note hidden">
    <div class="waitlist-note-text">
      <strong>This session is full ‚Äî add me to the waitlist</strong>
      <span id="waitlistCount" class="waitlist-count">0 people on the waitlist</span>
    </div>
    <input type="checkbox" id="waitlistConfirm" aria-label="Confirm waitlist">
  </label>
  
  <div id="blockConfirmation" class="block-confirmation hidden">
    <div class="confirmation-dates">
      <strong>Your booking includes these dates:</strong>
      <ul id="blockDatesList"></ul>
    </div>
    <div class="confirmation-details" id="blockDetails">
      <div><strong id="blockTitle">-</strong></div>
      <div class="slot-time" id="blockTime">-</div>
      <div class="slot-extra" id="blockExtra">-</div>
    </div>
    <label class="checkbox-label">
      <input type="checkbox" id="blockCheckbox">
      <span>I understand I am committing to multiple sessions</span>
    </label>
  </div>


  <!-- PAYMENT INSTRUCTIONS MODAL -->
  <div id="paymentModal" class="payment-modal hidden">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content">
      <button class="modal-close" id="closePaymentModal">&times;</button>
      
      <div class="payment-header">
        <h2>Booking Reserved</h2>
        <p>Complete your payment to confirm your spot</p>
      </div>

      <div class="payment-section">
        <h3>Session Details</h3>
        <div class="session-details">
          <div class="detail-row">
            <span class="label">Date:</span>
            <span class="value" id="paymentDate">-</span>
          </div>
          <div class="detail-row">
            <span class="label">Time:</span>
            <span class="value" id="paymentTime">-</span>
          </div>
          <div class="detail-row">
            <span class="label">Session:</span>
            <span class="value" id="paymentTitle">-</span>
          </div>
          <div class="detail-row highlight">
            <span class="label">Price:</span>
            <span class="value" id="paymentPrice">-</span>
          </div>
        </div>
      </div>

      <div class="payment-section">
        <h3>Bank Transfer Details</h3>
        <div class="bank-details">
          <div class="detail-row">
            <span class="label">Account Name:</span>
            <span class="value">Hoop Theory</span>
          </div>
          <div class="detail-row">
            <span class="label">Account Number:</span>
            <div class="copyable-value">
              <span id="accountNumber">12345678</span>
              <button class="copy-btn" id="copyAccountBtn" title="Copy account number">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                </svg>
              </button>
            </div>
          </div>
          <div class="detail-row">
            <span class="label">Sort Code:</span>
            <div class="copyable-value">
              <span id="sortCode">12-34-56</span>
              <button class="copy-btn" id="copySortBtn" title="Copy sort code">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                </svg>
              </button>
            </div>
          </div>
          <div class="detail-row">
            <span class="label">Reference:</span>
            <div class="copyable-value">
              <span id="paymentReference">-</span>
              <button class="copy-btn" id="copyRefBtn" title="Copy payment reference">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                </svg>
              </button>
            </div>
            <p style="font-size: 0.75rem; color: #999; margin: 4px 0 0; font-style: italic;">Format: FULLNAME-SESSIONNAME</p>
          </div>
        </div>
      </div>

      <div class="payment-section">
        <h3>Payment Deadline</h3>
        <div class="deadline-info">
          <p id="paymentDeadline">-</p>
          <p class="deadline-note">Please complete payment by this time to hold your reservation</p>
        </div>
      </div>

      <div class="payment-message">
        <p>You will also be sent an email with these payment details.</p>
        <p><strong>Once payment is received, you will receive a final confirmation email.</strong></p>
      </div>

      <div class="modal-actions">
        <button id="cancelBookingBtn" class="cancel-btn">Cancel Reservation</button>
        <button id="closePaymentBtn" class="close-modal-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- USER GUIDE MODAL (UI-only, editable) -->
  <div id="userGuideModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="userGuideTitle" tabindex="-1">
      <button class="modal-close" id="closeUserGuide" aria-label="Close user guide">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="userGuideTitle">How to use the booking system</h2>
        <p style="margin-top:6px;color:var(--muted);">Quick steps to get you booked in ‚Äî it only takes a minute.</p>
      </div>

      <div class="payment-section">
        <h3>Quick steps</h3>
        <ol style="margin:0 0 0 18px; color:var(--muted); line-height:1.6;">
          <li><strong>Select a date</strong> from the calendar.</li>
          <li><strong>Select a session</strong> from the available times shown below the calendar.</li>
          <li><strong>Fill in the registration form</strong> ‚Äî this is mandatory if it's your first time signing up.</li>
          <li><strong>Make your payment</strong> ‚Äî once received you will get a confirmation email.</li>
          <li>If the session is full, you can <strong>join the waiting list</strong> for that session.</li>
        </ol>
      </div>

      <div class="payment-section" style="padding-top:12px;">
        <h3>Cancelling a session</h3>
        <p style="color:var(--muted); margin:0 0 8px 0;">To cancel a booking:</p>
        <ol style="margin:0 0 0 18px; color:var(--muted); line-height:1.6;">
          <li>Check your <strong>reservation or confirmation email</strong> from Hoop Theory.</li>
          <li>Click the <strong>Cancel</strong> button in the email.</li>
          <li>If you no longer have access to the email, contact <strong>Bao via WhatsApp</strong> and he will cancel it for you.</li>
        </ol>
      </div>

      <div class="payment-section" style="padding-top:12px;">
        <h3>Need help?</h3>
        <p style="color:var(--muted); margin:0;">If you have any questions, please don‚Äôt hesitate to contact Bao via WhatsApp.</p>
      </div>

      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="closeUserGuideBtn" class="close-modal-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- WAITLIST CONFIRMATION MODAL -->
  <div id="waitlistConfirmationModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="waitlistConfirmationTitle" tabindex="-1">
      <button class="modal-close" id="closeWaitlistModal" aria-label="Close waitlist confirmation">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="waitlistConfirmationTitle">Waitlist Request Confirmed</h2>
      </div>

      <div class="payment-section">
        <p>Your waitlist request is confirmed.</p>
        <p>Details have been sent to your email.</p>
        <p>You are currently number <strong id="waitlistPositionValue">-</strong> on the waitlist.</p>
        <p>If a place becomes available, you will be notified and asked to complete payment within the stated time window. Unpaid offers may be released.</p>
        <p><strong>Please note this is NOT a booking reservation.</strong></p>
      </div>

      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="closeWaitlistBtn" class="close-modal-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- PLAYER REGISTRATION TITLE (OUTSIDE BOOKING FORM) -->
  <h2 id="playerRegistrationTitle" class="available-title player-registration-title hidden">Player Registration</h2>

  <!-- NORMAL BOOKING FORM (SHOWS WHEN SLOT IS AVAILABLE) -->
  <div id="bookingForm" class="booking-form hidden" style="display: none;">

    <label id="nameLabel">Player‚Äôs First and Last Name</label>
    <input type="text" id="name">


    <label id="emailLabel">Your Email</label>
    <input type="email" id="email">
    <div id="emailHelper" style="font-size:0.85em;color:#888;margin-top:2px;margin-bottom:10px;">(Please use the same email for every booking)</div>

    <div id="emailConflictBanner" class="email-conflict-banner hidden" style="background-color: #fee; border: 1px solid #f55; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #c00; font-weight: 600;">
      ‚ö†Ô∏è This email is already registered to a different name. Please use a different email or contact support.
    </div>

    <div id="nameConflictBanner" class="name-conflict-banner hidden" style="background-color: #fffbeb; border: 1px solid #f59e0b; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #92400e;">
      <div style="font-weight: 600; margin-bottom: 8px;">This player name is already registered using a different email.</div>
      <div style="margin-bottom: 12px; font-size: 0.9rem;">Are you sure you have entered your details correctly?</div>
      <button id="nameConflictYesBtn" style="background: #f59e0b; color: white; padding: 6px 16px; border: none; border-radius: 6px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">Yes, Continue</button>
    </div>

    <div id="duplicateBookingBanner" class="email-conflict-banner hidden" style="background-color: #f3f4f6; border: 1px solid #9ca3af; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #374151; font-weight: 600;">
      This user is already booked onto this session.
    </div>

    <!-- PLAYER REGISTRATION FORM (INLINE) -->
    <div id="playerRegistrationHostBooking">
      <div id="playerRegistrationForm" class="player-registration-form hidden">

      <h3 style="color: #1f2937; margin-bottom: 8px;">New Player Registration</h3>
      <p id="registrationWelcomeMessage" class="info" style="margin-bottom: 16px;">Welcome. Please complete this mandatory form to help us manage your booking and ensure your safety.</p>

      <label id="ageLabel">Age</label>
      <input type="number" id="player_age" min="0">

      <label id="experienceLabel">Playing Experience</label>
      <select id="player_experience">
        <option value="">-- Select --</option>
        <option>No experience</option>
        <option>Beginner</option>
        <option>Regular player but no team</option>
        <option>Local league</option>
        <option>National league</option>
      </select>


  <label id="medicalLabel">Medical information</label>
  <textarea id="player_medical" rows="3" required placeholder="Relevant conditions, allergies, learning needs..."></textarea>

  <fieldset class="emergency-contact">
    <legend style="font-weight:600; color:var(--muted);">Emergency contact</legend>
    <label id="emergencyNameLabel">Name</label>
    <input type="text" id="emergency_name" required>
    <label id="emergencyPhoneLabel">Phone</label>
    <input type="text" id="emergency_phone" required>
    <label id="emergencyRelationshipLabel">Relationship</label>
    <input type="text" id="emergency_relationship" required>
  </fieldset>

  <label class="checkbox consent"><input type="checkbox" id="media_consent"> <span id="media_consent_label">I, the parent/guardian of [Player Name], grant permission for Hoop Theory to use photos and videos taken during sessions for promotional purposes, including social media and marketing materials.</span></label>
  <label class="checkbox waiver"><input type="checkbox" id="waiver_ack"> <span id="waiver_label">I, the parent/guardian of [Player Name], agree to allow my child to participate in Hoop Theory sessions, understand the inherent risks of sports, and waive any claims against Hoop Theory for injuries incurred.</span></label>


      <!-- Checkbox removed as per requirements -->

      <!-- Error message removed: only visual indicators (asterisks, outline) will be shown -->
      </div>
    </div>

    <button id="bookBtn">Reserve Booking</button>
  </div>

  <!-- WAITLIST FORM (SHOWS WHEN SLOT IS FULLY BOOKED) -->
  <div id="waitlistForm" class="waitlist-form hidden">
    <label>Player's First and Last Name</label>
    <input type="text" id="waitlistName">

    <label>Your Email</label>
    <input type="email" id="waitlistEmail">
    <div id="emailHelper" style="font-size:0.85em;color:#888;margin-top:2px;margin-bottom:10px;">(Please use the same email for every booking)</div>

    <div id="waitlistEmailConflictBanner" class="email-conflict-banner hidden" style="background-color: #fee; border: 1px solid #f55; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #c00; font-weight: 600;">
      ‚ö†Ô∏è This email is already registered to a different name. Please use a different email or contact support.
    </div>

    <div id="waitlistNameConflictBanner" class="name-conflict-banner hidden" style="background-color: #fffbeb; border: 1px solid #f59e0b; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #92400e;">
      <div style="font-weight: 600; margin-bottom: 8px;">This player name is already registered using a different email.</div>
      <div style="margin-bottom: 12px; font-size: 0.9rem;">Are you sure you have entered your details correctly?</div>
      <button id="waitlistNameConflictYesBtn" style="background: #f59e0b; color: white; padding: 6px 16px; border: none; border-radius: 6px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">Yes, Continue</button>
    </div>

    <div id="waitlistDuplicateBookingBanner" class="email-conflict-banner hidden" style="background-color: #f3f4f6; border: 1px solid #9ca3af; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #374151; font-weight: 600;">
      This user is already booked onto this session.
    </div>

    <div id="waitlistDuplicateWaitlistBanner" class="email-conflict-banner hidden" style="background-color: #f3f4f6; border: 1px solid #9ca3af; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #374151; font-weight: 600;">
      This user is already on the waitlist for this session.
    </div>

    <div id="playerRegistrationHostWaitlist"></div>

    <button id="waitlistBtn">Join Waitlist</button>
  </div>
</div>

<script>
/* ================= STATE ================= */
let selectedDate = null;
let selectedSlot = null;
let calendarRenderVersion = 0;
let currentDisplayDate = new Date();
let autoRefreshInterval = null;
let currentBookingData = null; // Track pending booking for cancellation
let currentBookingId = null; // Track the bookingId for email sending
let pendingBooking = null; // Temporarily hold booking details while user completes registration
let _registrationCheckId = 0; // incrementing token to cancel outdated checks
let _nameConflictConfirmed = false; // track if user confirmed name conflict
let _lastCheckedName = '';
let _lastCheckedEmail = '';

const PHP_PATH = 'php/';
const REFRESH_INTERVAL = 5000;
const dateAvailabilityCache = {};

const BANK_DETAILS = {
  accountNumber: '12345678',
  sortCode: '12-34-56'
};

/* ================= DATE FORMATTING ================= */
function formatDateForDisplay(dateStr) {
  // Convert YYYY-MM-DD to "23 January 2026"
  const [year, month, day] = dateStr.split('-');
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                      'July', 'August', 'September', 'October', 'November', 'December'];
  
  const dayNum = parseInt(day);
  const monthName = monthNames[parseInt(month) - 1];
  
  return `${dayNum} ${monthName} ${year}`;
}

/* ================= API ================= */
async function getAvailableSlots(){
  return await (await fetch(PHP_PATH+'getSlots.php')).json();
}
async function getBookings(){
  return await (await fetch(PHP_PATH+'getBookings.php')).json();
}
async function getWaitlist(){
  return await (await fetch(PHP_PATH+'getWaitlist.php')).json();
}

// Check if player is already booked on the current session
async function isPlayerAlreadyBooked(email, date, slot) {
  if (!email || !date || !slot) return false;
  
  try {
    // First check: for block bookings, check the bookedUsers array in the slot itself
    if (slot.bookedUsers && Array.isArray(slot.bookedUsers)) {
      const userAlreadyInBlock = slot.bookedUsers.some(user => {
        return user && user.email && user.email.toLowerCase() === email.toLowerCase();
      });
      if (userAlreadyInBlock) {
        console.log('Found duplicate in block bookedUsers array');
        return true;
      }
    }
    
    // Second check: for regular bookings, query the bookings data
    const bookingsData = await getBookings();
    const bookingsOnDate = bookingsData[date] || [];
    
    // Check if email exists in any booking for this slot
    const alreadyBooked = bookingsOnDate.some(booking => {
      if (!booking) return false;
      
      // Match by time and title of the slot, and email
      const matchesSlot = booking.time === slot.time && booking.title === slot.title;
      const matchesEmail = booking.email && booking.email.toLowerCase() === email.toLowerCase();
      
      return matchesSlot && matchesEmail;
    });
    
    return alreadyBooked;
  } catch (err) {
    console.error('Error checking if player already booked:', err);
    return false;
  }
}

// Check if player is already on the waitlist for the current session
async function isPlayerAlreadyOnWaitlist(email, date, slot) {
  if (!email || !date || !slot) return false;

  try {
    const waitlistData = await getWaitlist();
    const entries = waitlistData[date] || [];

    const alreadyOnWaitlist = entries.some(entry => {
      if (!entry) return false;
      const matchesSlot = entry.time === slot.time && entry.title === slot.title;
      const matchesEmail = entry.email && entry.email.toLowerCase() === email.toLowerCase();
      
      // Also check blockId to distinguish between block and single sessions
      let matchesBlock = true;
      if (slot.blockId) {
        matchesBlock = entry.blockId === slot.blockId;
      } else {
        matchesBlock = !entry.blockId || entry.blockId === null;
      }
      
      return matchesSlot && matchesEmail && matchesBlock;
    });

    return alreadyOnWaitlist;
  } catch (err) {
    console.error('Error checking if player already on waitlist:', err);
    return false;
  }
}

async function updateWaitlistCount(){
  const countEl = document.getElementById('waitlistCount');
  if (!countEl) return;
  if (!selectedSlot || !selectedDate) {
    countEl.textContent = '0 people on the waitlist';
    return;
  }

  try {
    const waitlistData = await getWaitlist();
    const entries = waitlistData[selectedDate] || [];
    const count = entries.filter(e => e && e.time === selectedSlot.time && e.title === selectedSlot.title).length;
    countEl.textContent = `${count} ${count === 1 ? 'person' : 'people'} on the waitlist`;
  } catch (e) {
    console.error('Failed to load waitlist count', e);
    countEl.textContent = 'Waitlist count unavailable';
  }
}

/* ================= CALENDAR ================= */
function buildCalendarSkeleton(){
  calendarRenderVersion++;
  document.getElementById('calendar').innerHTML = '';
  document.getElementById('slots').innerHTML = '';
  document.getElementById('blockSlots').innerHTML = '';
  selectedDate = null;
  selectedSlot = null;

  // Reset the availability heading to default
  (document.querySelector('.available-title') || {textContent: null}).textContent = 'SELECT A DATE';
  
  // Hide all forms and payment modal
  hideBlockConfirmation();
  hidePaymentInstructions();
  showBookingForm(null);
  
  // Clear form inputs
  document.getElementById('name').value = '';
  document.getElementById('email').value = '';
  document.getElementById('waitlistName').value = '';
  document.getElementById('waitlistEmail').value = '';

  const year = currentDisplayDate.getFullYear();
  const month = currentDisplayDate.getMonth();
  // Build month grid with Monday as the first column
  const rawFirstDay = new Date(year, month, 1).getDay(); // 0=Sun,1=Mon...
  const firstDay = (rawFirstDay === 0) ? 6 : rawFirstDay - 1; // shift so 0=Mon..6=Sun
  const daysInMonth = new Date(year, month + 1, 0).getDate();

  const monthNames = [
    "January","February","March","April","May","June",
    "July","August","September","October","November","December"
  ];
  document.getElementById('monthYear').textContent =
    `${monthNames[month]} ${year}`;

  // Add leading empty cells for the first week
  for (let i = 0; i < firstDay; i++) {
    document.getElementById('calendar').appendChild(document.createElement('div'));
  }

  for (let d = 1; d <= daysInMonth; d++) {
    const dateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
    const div = document.createElement('div');
    div.className = 'day';
    div.dataset.date = dateStr;
    div.innerHTML = `<span>${d}</span>`;
    document.getElementById('calendar').appendChild(div);
  }

  refreshDateAvailability(true);
}

/* ================= AVAILABILITY ================= */
async function dateHasAvailableSlots(dateStr){
  const slotsData = await getAvailableSlots();
  const bookingsData = await getBookings();
  const slots = slotsData[dateStr] || [];
  return slots.some(s => {
    // Derive booked count from bookings.json
    let booked = 0;
    if (bookingsData && bookingsData[dateStr]) {
      booked = bookingsData[dateStr].filter(b => {
        const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
        const bTime = parts ? parts[1] : null;
        const titleMatch = b.match(/-\s*(.+?)\s*\(/);
        const bTitle = titleMatch ? titleMatch[1].trim() : null;
        return bTime === s.time && bTitle === s.title;
      }).length;
    } else {
      booked = (s.bookedUsers||[]).length;
    }
    return booked < (s.numberOfSpots||1);
  });
}

async function refreshDateAvailability(initial=false){
  const renderVersion = calendarRenderVersion;
  const days = document.querySelectorAll('.day[data-date]');
  const slotsData = await getAvailableSlots();
  const bookingsData = await getBookings();

  for (const div of days) {
    const dateStr = div.dataset.date;
    const date = new Date(dateStr);
    const today = new Date();
    today.setHours(0,0,0,0);

    if (date < today) {
      div.classList.add('disabled');
      continue;
    }

    const slots = slotsData[dateStr] || [];
    
    // Helper to get booked count for a slot
    const getBookedCount = (slot) => {
      let booked = 0;
      if (bookingsData && bookingsData[dateStr]) {
        booked = bookingsData[dateStr].filter(b => {
          const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
          const bTime = parts ? parts[1] : null;
          const titleMatch = b.match(/-\s*(.+?)\s*\(/);
          const bTitle = titleMatch ? titleMatch[1].trim() : null;
          return bTime === slot.time && bTitle === slot.title;
        }).length;
      } else {
        booked = (slot.bookedUsers||[]).length;
      }
      return booked;
    };

    // Determine color based on slot availability/booking status
    let hasAvailableSlots = false;
    let hasBlockSlots = false;
    let allFullyBooked = true;

    for (const slot of slots) {
      const booked = getBookedCount(slot);
      const spots = slot.numberOfSpots || 1;
      const full = booked >= spots;
      const isBlock = slot.blockId && slot.blockDates;
      const isFirstDate = isBlock && slot.blockDates[0] === dateStr;

      if (!full) {
        allFullyBooked = false;
        if (isFirstDate || !isBlock) {
          hasAvailableSlots = true; // GREEN: available on first date or single session
        } else if (isBlock) {
          hasBlockSlots = true; // BLUE: block session on non-first date
        }
      }
    }
    
    if (renderVersion !== calendarRenderVersion) return;

    // Remove any previous color classes
    div.classList.remove('available', 'block', 'full');

    let colorStatus = 'none';

    if (slots.length === 0) {
      // No slots at all
      div.classList.add('disabled');
      colorStatus = 'disabled';
    } else {
      div.classList.remove('disabled');
      
      if (allFullyBooked) {
        // RED: All sessions fully booked
        div.classList.add('full');
        colorStatus = 'red';
      } else if (hasAvailableSlots) {
        // GREEN: At least one available slot on first date or single
        div.classList.add('available');
        colorStatus = 'green';
      } else if (hasBlockSlots) {
        // BLUE: Block sessions available on non-first dates
        div.classList.add('block');
        colorStatus = 'blue';
      }
      
      div.onclick = () => handleDateClick(div, dateStr);
    }
    
    // DEBUG LOGGING
    if (slots.length > 0) {
      console.log(`üìÖ Date: ${dateStr} | Status: ${colorStatus} | Classes: ${div.className} | Slots: ${slots.length}`);
    }
  }
}

/* ================= DATE CLICK ================= */
async function handleDateClick(div, dateStr){
  selectedDate = dateStr;
  // Update availability header to show the selected date
  try {
    const hdr = document.querySelector('.available-title');
    if (hdr) hdr.textContent = 'Availability: ' + formatDateForDisplay(dateStr);
  } catch (err) { /* ignore */ }
  document.querySelectorAll('.day').forEach(d => d.classList.remove('selected'));
  div.classList.add('selected');

  document.getElementById('slots').innerHTML = '';
  document.getElementById('blockSlots').innerHTML = '';
  selectedSlot = null;
  
  // Reset forms when changing date
  hideBlockConfirmation();
  hidePaymentInstructions();
  showBookingForm(null);
  
  // Clear form inputs
  document.getElementById('name').value = '';
  document.getElementById('email').value = '';
  document.getElementById('waitlistName').value = '';
  document.getElementById('waitlistEmail').value = '';

  const slotsData = await getAvailableSlots();
  const bookingsData = await getBookings();
  const slots = slotsData[dateStr] || [];
  const processedBlockIds = new Set();

  slots.forEach(slot => {
    // Derive booked count from bookings.json
    let booked = 0;
    if (bookingsData && bookingsData[dateStr]) {
      booked = bookingsData[dateStr].filter(b => {
        const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
        const bTime = parts ? parts[1] : null;
        const titleMatch = b.match(/-\s*(.+?)\s*\(/);
        const bTitle = titleMatch ? titleMatch[1].trim() : null;
        return bTime === slot.time && bTitle === slot.title;
      }).length;
    } else {
      booked = (slot.bookedUsers || []).length;
    }
    const spots = slot.numberOfSpots || 1;
    const full = booked >= spots;
    const isBlock = slot.blockId && slot.blockDates;

    if (isBlock && processedBlockIds.has(slot.blockId)) return;
    if (isBlock) processedBlockIds.add(slot.blockId);

    /* ===== BLOCK SESSION ===== */
    if (isBlock) {
      const el = document.createElement('div');
      el.className = 'slot-card block-card';

      // Determine if this is first date in block for color coding
      const isFirstDate = slot.blockDates[0] === dateStr;
      let colorClass = isFirstDate ? 'block-color-green' : 'block-color-blue';
      
      // Override with red if fully booked
      if (full) {
        colorClass = 'block-color-red';
      }

      const priceDisplay = slot.price ? `¬£${slot.price.toFixed(2)}` : '';
      const locationDisplay = slot.location ? slot.location : '';

      el.innerHTML = `
        <div class="block-inner">
          <div class="block-info">
            <div class="slot-header">
              <strong class="slot-title">${slot.title}<!-- spots pill inserted next to title -->${!full ? ` <span class="pill spots-pill ${isFirstDate ? 'block-first' : 'block-subsequent'}">${Math.max(0, (spots - booked))} / ${spots} spots left</span>` : ''}</strong>
              <div class="slot-actions">
                ${full ? '<span class="pill fully-booked-pill">Fully Booked</span>' : ''}
              </div>
            </div>
            <div class="slot-meta">
              <div class="slot-time">${slot.time} - 4-Week Block</div>
            </div>
            ${priceDisplay || locationDisplay ? `<div class="slot-extra">${priceDisplay ? `<span class="meta-icon"><svg class="icon icon--price" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20.59 13.41L13.41 20.59a2 2 0 0 1-2.83 0L2 12l7.17-7.17a2 2 0 0 1 2.83 0L20.59 13.41z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/><circle cx="7.5" cy="7.5" r="1.5" fill="currentColor"/></svg></span><span class="price-text">${priceDisplay}</span>` : ''}${priceDisplay && locationDisplay ? '<span class="sep">‚Ä¢</span>' : ''}${locationDisplay ? `<span class="meta-icon"><svg class="icon icon--location" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 21s7-4.5 7-10a7 7 0 1 0-14 0c0 5.5 7 10 7 10zM12 11a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg></span><span class="location-text">${locationDisplay}</span>` : ''}</div>` : ''}
          </div>
          <!-- selectable indicator (bottom-right) -->
          <div class="select-indicator" role="button" aria-pressed="false" tabindex="0" title="Select session"></div>
        </div>
      `;

      el.classList.add(colorClass);

// Toggle selection when clicking a block card; indicator reflects selected state
    el.onclick = () => {
      const wasSelected = el.classList.contains('selected');
      document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
      if (!wasSelected) {
        el.classList.add('selected');
        selectedSlot = slot;
        
        // Only show block confirmation if NOT fully booked, otherwise wait for waitlist checkbox
        if (!full) {
          showBlockConfirmation(slot, false);
        }
        
        showBookingForm(full ? true : false);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','true');

        // Auto-scroll to show selected session and next step
        const blockDetails = document.getElementById('blockConfirmation');
        const formTarget = full ? document.getElementById('waitlistNote') : (blockDetails || document.getElementById('bookingForm'));
        formTarget?.scrollIntoView({ behavior: 'smooth', block: 'end' });
      } else {
        // deselect
        selectedSlot = null;
        hideBlockConfirmation();
        showBookingForm(null);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','false');
      }
    };

    // Make the indicator itself keyboard + pointer interactive and mirror card click
    setTimeout(()=>{
      const ind = el.querySelector('.select-indicator');
      if (!ind) return;
      ind.addEventListener('click', (ev)=>{ ev.stopPropagation(); el.click(); });
      ind.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); el.click(); } });
    }, 0);

      // Append to blockSlots container (layout unified via CSS)
      document.getElementById('blockSlots').appendChild(el);
      return;
    }

    // SINGLE SLOT CARD ‚Äî render solo sessions (details panel removed; booking opens directly)
    const el = document.createElement('div');
    el.className = 'slot-card';
    let colorClass = 'slot-color-green';
    if (full) colorClass = 'slot-color-red';

    const priceDisplay = slot.price ? `¬£${slot.price.toFixed(2)}` : '';
    const locationDisplay = slot.location ? slot.location : '';

    el.innerHTML = `
      <div class="single-slot-content">
        <div class="slot-header">
          <div class="slot-title"><span class="title-text">${slot.title}</span>${spots === 1 ? ' <span class="pill session-type">Solo Session</span>' : ''}${spots > 1 && !full ? ` <span class="pill spots-pill">${Math.max(0, (spots - booked))} / ${spots} spots left</span>` : ''}</div>
          <div class="slot-actions">
            ${full ? '<span class="pill fully-booked-pill">Fully Booked</span>' : ''}
          </div>
        </div>
        <div class="slot-meta">
          <div class="slot-time">${slot.time}</div>
          ${priceDisplay || locationDisplay ? `<div class="slot-extra">${priceDisplay ? `<span class="meta-icon"><svg class="icon icon--price" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20.59 13.41L13.41 20.59a2 2 0 0 1-2.83 0L2 12l7.17-7.17a2 2 0 0 1 2.83 0L20.59 13.41z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/><circle cx="7.5" cy="7.5" r="1.5" fill="currentColor"/></svg></span><span class="price-text">${priceDisplay}</span>` : ''}${priceDisplay && locationDisplay ? '<span class="sep">‚Ä¢</span>' : ''}${locationDisplay ? `<span class="meta-icon"><svg class="icon icon--location" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 21s7-4.5 7-10a7 7 0 1 0-14 0c0 5.5 7 10 7 10zM12 11a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg></span><span class="location-text">${locationDisplay}</span>` : ''}</div>` : ''}
        </div>
          <!-- selectable indicator for single session -->
          <div class="select-indicator" role="button" aria-pressed="false" tabindex="0" title="Select session"></div>
      </div>
    `;

    el.classList.add(colorClass);

    // Toggle selection for single session cards (click card or indicator)
    el.onclick = () => {
      const wasSelected = el.classList.contains('selected');
      document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
      if (!wasSelected) {
        el.classList.add('selected');
        selectedSlot = slot;
        hideBlockConfirmation();
        showBookingForm(full ? true : false);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','true');

        // Auto-scroll to show selected session and next step
        const formTarget = full ? document.getElementById('waitlistForm') : document.getElementById('bookingForm');
        formTarget?.scrollIntoView({ behavior: 'smooth', block: 'end' });
      } else {
        selectedSlot = null;
        hideBlockConfirmation();
        showBookingForm(null);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','false');
      }
    };

    // Make the small indicator interactive and keyboard accessible
    setTimeout(()=>{
      const ind = el.querySelector('.select-indicator');
      if (!ind) return;
      ind.addEventListener('click', (ev)=>{ ev.stopPropagation(); el.click(); });
      ind.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); el.click(); } });
    }, 0);

    document.getElementById('slots').appendChild(el);
  });
  
  // Auto-scroll to show calendar and availability section after slots render
  const slotsSection = document.querySelector('.available-slots');
  if (slotsSection) {
    slotsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
}

/* ================= NAV ================= */
// Safely advance the calendar by `delta` months without day-overflow bugs
// (e.g. Jan 31 + 1 month -> Mar 3). We normalise to the first of the target
// month which prevents accidental month-skips caused by Date overflow.
function advanceCalendarMonth(delta) {
  const y = currentDisplayDate.getFullYear();
  const m = currentDisplayDate.getMonth() + delta;
  // Set to first day of the target month to avoid overflow rolling into the following month
  currentDisplayDate = new Date(y, m, 1);
}

prevMonth.onclick = () => {
  advanceCalendarMonth(-1);
  buildCalendarSkeleton();
};
nextMonth.onclick = () => {
  advanceCalendarMonth(1);
  buildCalendarSkeleton();
};

/* ================= BLOCK CONFIRMATION ================= */
function showBlockConfirmation(slot, isWaitlist = false) {
  const confirmEl = document.getElementById('blockConfirmation');
  const titleEl = document.getElementById('blockConfirmationTitle');
  const datesList = document.getElementById('blockDatesList');
  const checkbox = document.getElementById('blockCheckbox');
  
  const blockDates = slot.blockDates || [];
  datesList.innerHTML = blockDates.map(d => `<li>${formatDateForDisplay(d)}</li>`).join('');
  checkbox.checked = false;

  // Populate extra details into the confirmation panel
  document.getElementById('blockTitle').textContent = slot.title || '-';
  document.getElementById('blockTime').textContent = slot.time || '-';
  const priceText = slot.price ? `¬£${slot.price.toFixed(2)}` : '';
  const locationText = slot.location || '';
  const extra = [];
  if (priceText) extra.push(`<span class="meta-icon"><svg class="icon icon--price" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20.59 13.41L13.41 20.59a2 2 0 0 1-2.83 0L2 12l7.17-7.17a2 2 0 0 1 2.83 0L20.59 13.41z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/><circle cx="7.5" cy="7.5" r="1.5" fill="currentColor"/></svg></span><span class="price-text">${priceText}</span>`);
  if (locationText) extra.push(`<span class="meta-icon"><svg class="icon icon--location" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 21s7-4.5 7-10a7 7 0 1 0-14 0c0 5.5 7 10 7 10zM12 11a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg></span><span class="location-text">${locationText}</span>`);
  document.getElementById('blockExtra').innerHTML = extra.join('<span class="sep">‚Ä¢</span>');

  // Add red color scheme if waitlist mode
  if (isWaitlist) {
    confirmEl.classList.add('waitlist-mode');
  } else {
    confirmEl.classList.remove('waitlist-mode');
  }

  confirmEl.classList.remove('hidden');
  titleEl?.classList.remove('hidden');
} 
function hideBlockConfirmation() {
  const confirmEl = document.getElementById('blockConfirmation');
  const titleEl = document.getElementById('blockConfirmationTitle');
  confirmEl.classList.add('hidden');
  titleEl?.classList.add('hidden');
}


/* ================= FORM TOGGLE ================= */
function showBookingForm(isFullyBooked) {
  const bookingForm = document.getElementById('bookingForm');
  const waitlistForm = document.getElementById('waitlistForm');
  const waitlistNote = document.getElementById('waitlistNote');
  const waitlistConfirm = document.getElementById('waitlistConfirm');
  const regForm = document.getElementById('playerRegistrationForm');
  const regHostBooking = document.getElementById('playerRegistrationHostBooking');
  const regHostWaitlist = document.getElementById('playerRegistrationHostWaitlist');
  const blockCheckbox = document.getElementById('blockCheckbox');
  const titleEl = document.getElementById('playerRegistrationTitle');
  
  // If no session selected (both false/undefined), hide both forms
  if (isFullyBooked === null || isFullyBooked === undefined) {
    bookingForm.classList.add('hidden');
    bookingForm.style.display = 'none';
    waitlistForm.classList.add('hidden');
    waitlistForm.style.display = 'none';
    waitlistNote.classList.add('hidden');
    waitlistNote.style.display = 'none';
    if (waitlistConfirm) waitlistConfirm.checked = false;
    return;
  }
  
  if (isFullyBooked) {
    // Ensure the normal booking form is hidden (both class and inline styles)
    bookingForm.classList.add('hidden');
    bookingForm.style.display = 'none';
    titleEl?.classList.add('hidden');
    regForm?.classList.add('hidden');

    // Show waitlist note, but keep waitlist form hidden until checkbox is checked
    waitlistForm.classList.add('hidden');
    waitlistForm.style.display = 'none';
    waitlistNote.classList.remove('hidden');
    waitlistNote.style.display = '';
    if (waitlistConfirm) waitlistConfirm.checked = false;
    updateWaitlistCount();

    // Move registration form into waitlist form container
    if (regForm && regHostWaitlist && regForm.parentElement !== regHostWaitlist) {
      regHostWaitlist.appendChild(regForm);
    }
  } else {
    // Check if this is a block session
    if (selectedSlot && selectedSlot.blockId) {
      // For block sessions: hide booking form until checkbox is checked
      bookingForm.classList.add('hidden');
      bookingForm.style.display = 'none';
      titleEl?.classList.add('hidden');
      regForm?.classList.add('hidden');
      blockCheckbox.checked = false;
    } else {
      // For regular single sessions: show booking form immediately
      bookingForm.classList.remove('hidden');
      bookingForm.style.display = '';
      // Move registration form back into booking form container
      if (regForm && regHostBooking && regForm.parentElement !== regHostBooking) {
        regHostBooking.appendChild(regForm);
      }
    }

    // Hide waitlist form (both class and inline)
    waitlistForm.classList.add('hidden');
    waitlistForm.style.display = 'none';
    waitlistNote.classList.add('hidden');
    waitlistNote.style.display = 'none';
    if (waitlistConfirm) waitlistConfirm.checked = false;
  }
}

/* ================= PAYMENT INSTRUCTIONS ================= */
function generatePaymentReference() {
  // Generate reference: FULLNAME-SESSIONNAME
  // This will be set when showPaymentInstructions is called with actual data
  return null; // Will be set dynamically
}

function showPaymentInstructions(slot, name, email, date, bookingId) {
  console.log('üü† showPaymentInstructions called with:', { slot, name, email, date, bookingId });
  console.log('üîµ BookingId received:', bookingId);
  const modal = document.getElementById('paymentModal');
  console.log('üü† Modal element:', modal, 'Has hidden class:', modal.classList.contains('hidden'));
  
  // Store bookingId globally for email sending
  currentBookingId = bookingId;
  console.log('üîµ currentBookingId set to:', currentBookingId);
  
  // Generate payment reference in format: FULLNAME-SESSIONNAME
  const fullName = name.toUpperCase().replace(/\s+/g, '');
  const sessionName = slot.title.toUpperCase().replace(/\s+/g, '');
  const paymentRef = `${fullName}-${sessionName}`;
  
  // Calculate deadline (24 hours from now)
  const deadline = new Date();
  deadline.setHours(deadline.getHours() + 24);
  const deadlineStr = deadline.toLocaleString('en-GB', { 
    weekday: 'short',
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
  
  // Format date for display
  const dateDisplay = formatDateForDisplay(date);
  
  // Get price (default to ¬£25 if not specified)
  const price = slot.price ? `¬£${slot.price.toFixed(2)}` : '¬£25.00';
  
  // Populate payment details
  document.getElementById('paymentDate').textContent = dateDisplay;
  document.getElementById('paymentTime').textContent = slot.time;
  document.getElementById('paymentTitle').textContent = slot.title;
  document.getElementById('paymentPrice').textContent = price;
  document.getElementById('paymentReference').textContent = paymentRef;
  document.getElementById('paymentDeadline').textContent = deadlineStr;
  document.getElementById('accountNumber').textContent = BANK_DETAILS.accountNumber;
  document.getElementById('sortCode').textContent = BANK_DETAILS.sortCode;
  
  // Store booking data for cancellation
  currentBookingData = {
    slot: slot,
    name: name,
    email: email,
    date: date,
    paymentRef: paymentRef,
    deadline: deadline,
    isBlock: !!slot.blockId,
    blockDates: slot.blockDates
  };
  
  // Show modal (using same approach as user guide modal)
  console.log('üü† About to show modal - before removal. Classes:', modal.className);
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  console.log('üü† After removing hidden class:', modal.className);
  
  // Add body class to prevent iOS zoom
  document.body.classList.add('modal-open-payment');
  
  // Ensure the modal content is scrolled to top
  const modalContent = modal.querySelector('.payment-modal-content');
  if (modalContent) {
    modalContent.scrollTop = 0;
  }

  // Hide the booking form
  const bookingForm = document.getElementById('bookingForm');
  if (bookingForm) bookingForm.style.display = 'none';
}

function hidePaymentInstructions() {
  const modal = document.getElementById('paymentModal');
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  
  // Remove body class
  document.body.classList.remove('modal-open-payment');
  
  // Show the booking form
  const bookingForm = document.getElementById('bookingForm');
  if (bookingForm) bookingForm.style.display = 'block';

  // Remove any dynamic viewport listeners
  const modalContent = modal.querySelector('.payment-modal-content');
  if (modalContent && modalContent._vcResizeHandler) {
    if (window.visualViewport) window.visualViewport.removeEventListener('resize', modalContent._vcResizeHandler);
    window.removeEventListener('orientationchange', modalContent._vcResizeHandler);
    delete modalContent._vcResizeHandler;
  }
  
  currentBookingData = null;
}

function showWaitlistConfirmationModal(position) {
  const modal = document.getElementById('waitlistConfirmationModal');
  const positionEl = document.getElementById('waitlistPositionValue');
  if (!modal || !positionEl) return;

  positionEl.textContent = position || '-';
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  document.body.classList.add('modal-open-payment');

  const content = modal.querySelector('.payment-modal-content');
  if (content) content.scrollTop = 0;
}

function hideWaitlistConfirmationModal() {
  const modal = document.getElementById('waitlistConfirmationModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('modal-open-payment');
}

function copyToClipboard(element, btnElement) {
  const text = element.textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = btnElement;
    const originalHTML = btn.innerHTML;
    
    // Show success state
    btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>';
    btn.style.background = '#10b981';
    
    // Revert after 2 seconds
    setTimeout(() => {
      btn.innerHTML = originalHTML;
      btn.style.background = '';
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
  });
}

/* ================= PAYMENT EMAIL ================= */
async function sendReservationEmail() {
  if (!currentBookingData) {
    console.error('sendReservationEmail: No currentBookingData');
    alert('Error: Could not send email. Please try again.');
    return false;
  }
  
  // Calculate deadline (24 hours from now)
  const deadline = new Date();
  deadline.setHours(deadline.getHours() + 24);
  const deadlineStr = deadline.toLocaleString('en-GB', { 
    weekday: 'short',
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
  
  const emailPayload = {
    type: 'temporary_reservation',
    email: currentBookingData.email,
    name: currentBookingData.name,
    slot: currentBookingData.slot.time,
    title: currentBookingData.slot.title,
    date: currentBookingData.date,
    blockDates: currentBookingData.blockDates || [],
    paymentRef: currentBookingData.paymentRef,
    deadline: deadlineStr,
    price: currentBookingData.slot.price || '25.00',
    location: currentBookingData.slot.location || 'Hoop Theory',
    bookingId: currentBookingId || ''
  };
  
  console.log('Sending reservation email with payload:', emailPayload);
  console.log('üîµ Current Booking ID:', currentBookingId);
  console.log('üîµ Price:', currentBookingData.slot.price);
  console.log('üîµ Location:', currentBookingData.slot.location);
  
  try {
    const response = await fetch(PHP_PATH + 'sendEmail.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(emailPayload)
    });
    
    const responseText = await response.text();
    console.log('Email API response status:', response.status);
    console.log('Email API response text:', responseText);
    
    if (response.ok) {
      console.log('‚úì Reservation email sent successfully');
      return true;
    } else {
      console.error('‚úó Email send failed - HTTP ' + response.status);
      alert('Email could not be sent. Please contact support.');
      return false;
    }
  } catch (error) {
    console.error('‚úó Email send error:', error);
    alert('Error sending email. Please try again.');
    return false;
  }
}

async function sendWaitlistConfirmationEmail(payload) {
  if (!payload) return false;
  const emailPayload = {
    type: 'waitlist_confirmation',
    email: payload.email,
    name: payload.name,
    slot: payload.slot?.time || '',
    title: payload.slot?.title || '',
    date: payload.date || '',
    blockDates: payload.slot?.blockDates || [],
    waitlistPosition: payload.waitlistPosition || '',
    price: payload.slot?.price || '25.00',
    location: payload.slot?.location || 'Hoop Theory'
  };

  try {
    const response = await fetch(PHP_PATH + 'sendEmail.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(emailPayload)
    });

    const responseText = await response.text();
    console.log('Waitlist email response status:', response.status);
    console.log('Waitlist email response text:', responseText);
    return response.ok;
  } catch (error) {
    console.error('Waitlist email send error:', error);
    return false;
  }
}

/* ================= BOOKING ================= */
async function saveBooking(slot, name, email) {
  const payload = {
    name: name,
    email: email,
    date: selectedDate,
    slot: {
      title: slot.title,
      time: slot.time,
      price: slot.price,
      location: slot.location
    }
  };
  console.log('saveBooking payload:', payload);
  const response = await fetch(PHP_PATH + 'saveBookings.php', {
    method: 'POST',
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    console.error('saveBooking HTTP error:', response.status);
    throw new Error('HTTP ' + response.status);
  }
  const result = await response.json();
  console.log('saveBooking response:', result);
  console.log('üî¥ saveBooking returned bookingId:', result.bookingId);
  return result;
}

async function saveBlockBooking(slot, name, email) {
  const payload = {
    name: name,
    email: email,
    blockId: slot.blockId,
    blockDates: slot.blockDates,
    slot: {
      title: slot.title,
      time: slot.time,
      price: slot.price,
      location: slot.location
    }
  };
  console.log('saveBlockBooking payload:', payload);
  const response = await fetch(PHP_PATH + 'saveBookings.php', {
    method: 'POST',
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    console.error('saveBlockBooking HTTP error:', response.status);
    throw new Error('HTTP ' + response.status);
  }
  const result = await response.json();
  console.log('saveBlockBooking response:', result);
  return result;
}

// Helper: check if player is registered (calls backend)
async function checkPlayerRegistered(name, email) {
  try {
    console.log('Calling backend isPlayerRegistered for:', name, email);
    const res = await fetch(PHP_PATH + 'isPlayerRegistered.php', {
      method: 'POST',
      body: JSON.stringify({ name, email })
    });
    if (!res.ok) {
      console.log('isPlayerRegistered: non-OK response');
      return false;
    }
    const j = await res.json();
    console.log('Backend isPlayerRegistered result:', j);
    return j;
  } catch (e) {
    console.error('Player registration check failed', e);
    return { registered: false };
  }
}

function showPlayerRegistration(prefill={}, isWaitlistOnly=false){
  // Cancel other checks so they won't accidentally hide the form while we show it
  _registrationCheckId++;

  // Only show booking form if not in waitlist-only mode
  if (!isWaitlistOnly) {
    // Ensure booking form container is visible so registration form can be seen
    const bookingForm = document.getElementById('bookingForm');
    if (bookingForm) {
      bookingForm.classList.remove('hidden');
      bookingForm.style.display = '';
    }
  }

  const form = document.getElementById('playerRegistrationForm');
  const titleEl = document.getElementById('playerRegistrationTitle');
  form.classList.remove('hidden');
  titleEl?.classList.remove('hidden');
  // ensure animated class toggle for smooth transition - don't scroll or force focus
  requestAnimationFrame(() => {
    form.classList.add('visible');
  });

  document.getElementById('bookBtn').disabled = false;
  console.log('Player registration form shown for', prefill.name || '', prefill.email || '');
  // store a snapshot of the booking so we can continue reliably even if selectedSlot changes
  pendingBooking = { slot: selectedSlot, date: selectedDate, name: prefill.name || '', email: prefill.email || '' };
  console.log('Pending booking saved:', pendingBooking);
  // populate name/email from booking form
  if (prefill.name) document.getElementById('name').value = prefill.name;
  if (prefill.email) document.getElementById('email').value = prefill.email;
  
  // Update welcome message with player name
  const welcomeMsg = document.getElementById('registrationWelcomeMessage');
  if (welcomeMsg && prefill.name) {
    welcomeMsg.textContent = `Welcome ${prefill.name}. Please complete this mandatory form to help us manage your booking and ensure your safety.`;
  }
  
  // copy booking inputs into form where relevant
  document.getElementById('player_age').value = prefill.age || '';
  document.getElementById('player_experience').value = prefill.experience || '';
  document.getElementById('player_medical').value = prefill.medical || '';
  document.getElementById('emergency_name').value = prefill.emergency?.name || '';
  document.getElementById('emergency_phone').value = prefill.emergency?.phone || '';
  document.getElementById('emergency_relationship').value = prefill.emergency?.relationship || '';

  // Update consent/waiver text with player name if available
  const playerName = prefill.name || document.getElementById('name').value.trim() || '[Player Name]';
  const consentLabel = document.getElementById('media_consent_label');
  const waiverLabel = document.getElementById('waiver_label');
  if (consentLabel) consentLabel.textContent = `I, the parent/guardian of ${playerName}, grant permission for Hoop Theory to use photos and videos taken during sessions for promotional purposes, including social media and marketing materials.`;
  if (waiverLabel) waiverLabel.textContent = `I, the parent/guardian of ${playerName}, agree to allow my child to participate in Hoop Theory sessions, understand the inherent risks of sports, and waive any claims against Hoop Theory for injuries incurred.`;
}
function hidePlayerRegistration(immediate = false){
  const form = document.getElementById('playerRegistrationForm');
  const titleEl = document.getElementById('playerRegistrationTitle');
  if (!form) {
    console.warn('‚ö†Ô∏è playerRegistrationForm element not found');
    return;
  }
  // Cancel in-flight checks
  _registrationCheckId++;
  // remove visible class to trigger animation
  form.classList.remove('visible');
  // if immediate is requested, hide instantly
  if (immediate) {
    form.classList.add('hidden');
    titleEl?.classList.add('hidden');
  } else {
    // after transition completes, add hidden to remove from flow
    setTimeout(() => {
      form.classList.add('hidden');
      titleEl?.classList.add('hidden');
    }, 220);
  }
  const playerFormError = document.getElementById('playerFormError');
  if (playerFormError) playerFormError.classList.add('hidden');
  document.getElementById('bookBtn').disabled = false;
  console.log('Player registration form hidden');
  // clear pending booking snapshot if the user cancelled
  pendingBooking = null;
}

function showPlayerFormError(msg){
  const el = document.getElementById('playerFormError');
  el.textContent = msg;
  el.classList.remove('hidden');
}

function collectRegistrationData(){
  const email = document.getElementById('email').value.trim();
  const name = document.getElementById('name').value.trim();
  const age = document.getElementById('player_age').value;
  const experience = document.getElementById('player_experience').value;
  const medical = document.getElementById('player_medical').value.trim();
  const emergency = {
    name: document.getElementById('emergency_name').value.trim(),
    phone: document.getElementById('emergency_phone').value.trim(),
    relationship: document.getElementById('emergency_relationship').value.trim()
  };
  const mediaConsent = !!document.getElementById('media_consent').checked;
  const waiverAck = !!document.getElementById('waiver_ack').checked;
  const mediaText = document.getElementById('media_consent_label')?.textContent || '';
  const waiverText = document.getElementById('waiver_label')?.textContent || '';

  return {
    name, email, age, experience, medical, emergency,
    media_consent: mediaConsent, media_consent_text: mediaText,
    waiver_acknowledged: waiverAck, waiver_text: waiverText,
    registration_complete: true
  };
}

function validateRegistration(profile){
  const errors = [];
  if (!profile.name) errors.push('Name is required');
  if (!profile.email || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(profile.email)) errors.push('Valid email is required');
  if (profile.age === '' || profile.age === null || profile.age === undefined) errors.push('Age is required');
  else if (isNaN(parseInt(profile.age)) || parseInt(profile.age) < 0) errors.push('Age must be a non-negative number');
  const allowed = ['No experience','Beginner','Regular player but no team','Local league','National league'];
  if (!allowed.includes(profile.experience)) errors.push('Playing experience is required');
  if (!profile.medical) errors.push('Medical information is required');
  if (!profile.emergency || !profile.emergency.name) errors.push('Emergency contact name is required');
  if (!profile.emergency || !profile.emergency.phone) errors.push('Emergency contact phone is required');
  if (!profile.emergency || !profile.emergency.relationship) errors.push('Emergency contact relationship is required');
  if (!profile.media_consent) errors.push('Media consent must be accepted');
  if (!profile.waiver_acknowledged) errors.push('Waiver must be acknowledged');
  return errors;
}

async function submitRegistrationAndContinue(){
  const profile = collectRegistrationData();
  const alreadyFilled = document.getElementById('already_filled_registration')?.checked;
  if (alreadyFilled) {
    console.log('Already filled registration checkbox is checked ‚Äî proceeding without saving');
    if (!confirm('You indicated you have already filled out registration elsewhere. Proceed without saving?')) return false;
    hidePlayerRegistration();
    return true; // caller should continue booking
  }

  const errs = validateRegistration(profile);
  if (errs.length > 0) {
    showPlayerFormError(errs.join('; '));
    return false;
  }

  try {
    console.log('Saving profile to backend:', profile);
    const res = await fetch(PHP_PATH + 'savePlayerProfile.php', {
      method: 'POST',
      body: JSON.stringify(profile)
    });
    const j = await res.json();
    console.log('savePlayerProfile response:', j);
    if (!j.success) {
      showPlayerFormError((j.errors || ['Failed to save profile']).join('; '));
      return false;
    }
    // success - hide form and continue
    console.log('Profile saved successfully for', profile.name, profile.email);
    hidePlayerRegistration();
    return true;
  } catch (e) {
    console.error('Save player profile failed', e);
    showPlayerFormError('Failed to save profile');
    return false;
  }
}


// Save Player Registration button handler removed - logic integrated into Reserve Booking button
/*
document.getElementById('savePlayerRegistrationBtn').onclick = async (e) => {
  e.preventDefault();
  const profile = collectRegistrationData();
  // Remove previous error highlights and asterisks
  clearRegistrationFieldErrors();
  const errs = validateRegistration(profile);
  if (errs.length > 0) {
    showRegistrationFieldErrors(profile);
    // No error message: only visual indicators
    return;
  }
  // Print profile JSON to console as required
  try {
    console.log('Profile JSON to save:', JSON.stringify(profile, null, 2));
  } catch (e) {
    console.log('Profile object:', profile);
  }

  const ok = await submitRegistrationAndContinue();
  if (ok) {
    // proceed with pending booking
    proceedWithBookingAfterProfile();
  }
};
*/

// Helper: clear previous error highlights and asterisks
function clearRegistrationFieldErrors() {
  const labelIds = [
    'nameLabel', 'emailLabel', 'ageLabel', 'experienceLabel', 'medicalLabel',
    'emergencyNameLabel', 'emergencyPhoneLabel', 'emergencyRelationshipLabel'
  ];
  labelIds.forEach(id => {
    const label = document.getElementById(id);
    if (label) {
      // Remove only .asterisk spans, do not touch other HTML
      label.querySelectorAll('.asterisk').forEach(el => el.remove());
      label.classList.remove('field-error');
    }
  });
  const fieldIds = [
    'name', 'email', 'player_age', 'player_experience', 'player_medical',
    'emergency_name', 'emergency_phone', 'emergency_relationship'
  ];
  fieldIds.forEach(id => {
    const field = document.getElementById(id);
    if (field) field.classList.remove('field-error');
  });
}

// Helper: show asterisks and highlight missing required fields
function showRegistrationFieldErrors(profile) {
  // Name
  if (!profile.name) markFieldError('nameLabel', 'name');
  // Email
  if (!profile.email || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(profile.email)) markFieldError('emailLabel', 'email');
  // Age
  if (profile.age === '' || profile.age === null || profile.age === undefined || isNaN(parseInt(profile.age)) || parseInt(profile.age) < 0) markFieldError('ageLabel', 'player_age');
  // Experience
  const allowed = ['No experience','Beginner','Regular player but no team','Local league','National league'];
  if (!allowed.includes(profile.experience)) markFieldError('experienceLabel', 'player_experience');
  // Medical
  if (!profile.medical) markFieldError('medicalLabel', 'player_medical');
  // Emergency contact
  if (!profile.emergency || !profile.emergency.name) markFieldError('emergencyNameLabel', 'emergency_name');
  if (!profile.emergency || !profile.emergency.phone) markFieldError('emergencyPhoneLabel', 'emergency_phone');
  if (!profile.emergency || !profile.emergency.relationship) markFieldError('emergencyRelationshipLabel', 'emergency_relationship');
}

function markFieldError(labelId, fieldId) {
  const label = document.getElementById(labelId);
  if (label) {
    let asterisk = label.querySelector('.asterisk');
    if (!asterisk) {
      asterisk = document.createElement('span');
      asterisk.className = 'asterisk';
      asterisk.textContent = ' *';
      label.appendChild(asterisk);
    }
    // Always re-trigger the animation
    asterisk.classList.remove('asterisk-pop');
    void asterisk.offsetWidth;
    asterisk.classList.add('asterisk-pop');
    label.classList.add('field-error');
  }
  const field = document.getElementById(fieldId);
  if (field) field.classList.add('field-error');
}

// Field-change logging and booking-area checkbox handling
const fieldIds = ['player_age','player_experience','player_medical','emergency_name','emergency_phone','emergency_relationship','media_consent','waiver_ack','already_filled_registration'];
fieldIds.forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  const ev = (el.tagName === 'INPUT' && el.type === 'checkbox') || el.tagName === 'SELECT' ? 'change' : 'input';
  el.addEventListener(ev, (e) => {
    const val = (el.type === 'checkbox') ? el.checked : el.value;
    console.log('Field changed:', id, val);
    // special handling for the booking-area already-filled checkbox
    if (id === 'already_filled_registration') {
      console.log('Already filled checkbox checked/unchecked');
      if (val) {
        console.log('Already filled registration checkbox checked - hiding registration form');
        hidePlayerRegistration(true);
      } else {
        console.log('Already filled registration checkbox unchecked - no-op');
      }
    }
  });
});

// cancel handler (if user opened the form and changed their mind)
const cancelBtn = document.getElementById('cancelPlayerBtn');
if (cancelBtn) cancelBtn.onclick = (e) => { e.preventDefault(); console.log('Cancel Player Registration clicked'); hidePlayerRegistration(); };


// Centralized continuation after profile saved or skip
async function proceedWithBookingAfterProfile(){
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();

  // prefer the live selectedSlot but fall back to the snapshot saved when the form was shown
  const slotToUse = selectedSlot || (pendingBooking && pendingBooking.slot) || null;
  const dateToUse = selectedDate || (pendingBooking && pendingBooking.date) || null;

  if (!slotToUse) {
    console.warn('No session selected while trying to continue booking after registration');
    alert('No session selected. Please re-select a session to continue booking.');
    return;
  }

  try {
    console.log('Proceeding with booking after profile. slot:', slotToUse, 'date:', dateToUse, 'name:', name, 'email:', email);

    let bookingResult;
    if (slotToUse.blockId) {
      bookingResult = await saveBlockBooking(slotToUse, name, email);
    } else {
      bookingResult = await saveBooking(slotToUse, name, email);
    }

    // Capture bookingId from response
    const bookingId = bookingResult && bookingResult.bookingId ? bookingResult.bookingId : null;

    showPaymentInstructions(slotToUse, name, email, dateToUse, bookingId);

    // Clear pending booking now that booking is created
    pendingBooking = null;
  } catch (err) {
    console.error('Booking after profile failed', err);
    alert('Error confirming booking. Please try again.');
  }
}

// Debounce helper and live registration checking
const debounce = (fn, wait = 600) => {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
};

const handleNameEmailChange = debounce(async () => {
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();
  const note = document.getElementById('playerCheckNote');
  const emailConflictBanner = document.getElementById('emailConflictBanner');
  const nameConflictBanner = document.getElementById('nameConflictBanner');
  const duplicateBookingBanner = document.getElementById('duplicateBookingBanner');
  const bookBtn = document.getElementById('bookBtn');

  // Hide form if inputs incomplete or invalid
  const emailValid = /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email);
  if (!name || !email || !emailValid) {
    // Cancel any in-flight checks
    _registrationCheckId++;
    hidePlayerRegistration(true);
    emailConflictBanner?.classList.add('hidden');
    nameConflictBanner?.classList.add('hidden');
    duplicateBookingBanner?.classList.add('hidden');
    if (bookBtn) bookBtn.disabled = false;
    _nameConflictConfirmed = false;
    _lastCheckedName = '';
    _lastCheckedEmail = '';
    return;
  }

  // Reset confirmation flag if name or email changed
  if (name !== _lastCheckedName || email !== _lastCheckedEmail) {
    _nameConflictConfirmed = false;
    _lastCheckedName = name;
    _lastCheckedEmail = email;
  }

  // Start a new check token
  const checkId = ++_registrationCheckId;

  // Show checking note (no-op if note element missing)
  note?.classList.remove('hidden');
  console.log('Checking profile for:', name, email, ' (checkId=', checkId, ')');

  try {
    const checkResult = await checkPlayerRegistered(name, email);
    // If another check started since we began, ignore this result
    if (checkId !== _registrationCheckId) {
      console.log('Stale registration check result ignored (checkId', checkId, 'current', _registrationCheckId, ')');
      return;
    }

    console.log('Checking profile for:', name, email, 'found:', !!checkResult.registered);

    // Log if name exists with different email
    if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      console.warn('‚ö†Ô∏è Name "' + name + '" already exists with a different email:', checkResult.existingEmail);
    }

    // Check if player is already booked on this session
    console.log('Checking for duplicate booking - email:', email, 'date:', selectedDate, 'slot:', selectedSlot);
    if (checkResult.registered && selectedSlot && selectedDate) {
      const alreadyBooked = await isPlayerAlreadyBooked(email, selectedDate, selectedSlot);
      console.log('Duplicate booking check result:', alreadyBooked);
      if (alreadyBooked) {
        console.warn('Player profile already booked onto session');
        note?.classList.add('hidden');
        duplicateBookingBanner?.classList.remove('hidden');
        emailConflictBanner?.classList.add('hidden');
        nameConflictBanner?.classList.add('hidden');
        hidePlayerRegistration(true);
        if (bookBtn) bookBtn.disabled = true;
        return;
      }
    }
    duplicateBookingBanner?.classList.add('hidden');

    note?.classList.add('hidden');

    const existingName = (checkResult.existingName || '').trim().toLowerCase();
    const inputName = name.trim().toLowerCase();

    if (checkResult.registered) {
      // Email + name match - hide registration form
      hidePlayerRegistration(true);
      emailConflictBanner?.classList.add('hidden');
      nameConflictBanner?.classList.add('hidden');
      if (bookBtn) bookBtn.disabled = false;
    } else if (checkResult.emailExists && existingName && existingName !== inputName) {
      // Email exists but with different name - show error banner, hide form, and disable submit
      emailConflictBanner?.classList.remove('hidden');
      nameConflictBanner?.classList.add('hidden');
      hidePlayerRegistration(true);
      if (bookBtn) bookBtn.disabled = true;
    } else if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      // Name exists with different email - show warning banner only if not already confirmed
      if (!_nameConflictConfirmed) {
        nameConflictBanner?.classList.remove('hidden');
        emailConflictBanner?.classList.add('hidden');
        hidePlayerRegistration(true);
        if (bookBtn) bookBtn.disabled = false;
      } else {
        // Already confirmed, show form
        showPlayerRegistration({ name, email });
        emailConflictBanner?.classList.add('hidden');
        nameConflictBanner?.classList.add('hidden');
        if (bookBtn) bookBtn.disabled = false;
      }
    } else {
      // Email not found - show form normally
      showPlayerRegistration({ name, email });
      emailConflictBanner?.classList.add('hidden');
      nameConflictBanner?.classList.add('hidden');
      if (bookBtn) bookBtn.disabled = false;
    }
  } catch (err) {
    console.error('Registration check failed', err);
    note?.classList.add('hidden');
  }
}, 600);

// Waitlist: live registration checking (same logic as booking form)
const handleWaitlistNameEmailChange = debounce(async () => {
  const name = document.getElementById('waitlistName').value.trim();
  const email = document.getElementById('waitlistEmail').value.trim();
  const waitlistBanner = document.getElementById('waitlistEmailConflictBanner');
  const waitlistNameBanner = document.getElementById('waitlistNameConflictBanner');
  const waitlistDuplicateBanner = document.getElementById('waitlistDuplicateBookingBanner');
  const waitlistDuplicateWaitlistBanner = document.getElementById('waitlistDuplicateWaitlistBanner');
  const waitlistBtn = document.getElementById('waitlistBtn');

  // Hide form if inputs incomplete or invalid
  const emailValid = /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email);
  if (!name || !email || !emailValid) {
    _registrationCheckId++;
    hidePlayerRegistration(true);
    waitlistBanner?.classList.add('hidden');
    waitlistNameBanner?.classList.add('hidden');
    waitlistDuplicateBanner?.classList.add('hidden');
    waitlistDuplicateWaitlistBanner?.classList.add('hidden');
    if (waitlistBtn) waitlistBtn.disabled = false;
    return;
  }

  const checkId = ++_registrationCheckId;
  console.log('Waitlist: checking profile for:', name, email, '(checkId=', checkId, ')');

  try {
    const checkResult = await checkPlayerRegistered(name, email);
    if (checkId !== _registrationCheckId) {
      console.log('Waitlist: stale registration check ignored (checkId', checkId, 'current', _registrationCheckId, ')');
      return;
    }

    console.log('Waitlist: profile found:', !!checkResult.registered);

    // Log if name exists with different email
    if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      console.warn('‚ö†Ô∏è Waitlist: Name "' + name + '" already exists with a different email:', checkResult.existingEmail);
    }

    // Check if player is already booked on this session (even when joining waitlist)
    console.log('Waitlist: checking for duplicate booking - email:', email, 'date:', selectedDate, 'slot:', selectedSlot);
    if (checkResult.registered && selectedSlot && selectedDate) {
      const alreadyBooked = await isPlayerAlreadyBooked(email, selectedDate, selectedSlot);
      console.log('Waitlist: duplicate booking check result:', alreadyBooked);
      if (alreadyBooked) {
        console.warn('Player profile already booked onto session');
        waitlistDuplicateBanner?.classList.remove('hidden');
        waitlistBanner?.classList.add('hidden');
        waitlistNameBanner?.classList.add('hidden');
        hidePlayerRegistration(true);
        if (waitlistBtn) waitlistBtn.disabled = true;
        return;
      }
    }
    if (selectedSlot && selectedDate) {
      const alreadyOnWaitlist = await isPlayerAlreadyOnWaitlist(email, selectedDate, selectedSlot);
      console.log('Waitlist: already on waitlist check result:', alreadyOnWaitlist);
      if (alreadyOnWaitlist) {
        console.warn('Player is already on the waitlist for this session');
        waitlistDuplicateWaitlistBanner?.classList.remove('hidden');
        waitlistBanner?.classList.add('hidden');
        waitlistNameBanner?.classList.add('hidden');
        waitlistDuplicateBanner?.classList.add('hidden');
        hidePlayerRegistration(true);
        if (waitlistBtn) waitlistBtn.disabled = true;
        return;
      }
    }
    waitlistDuplicateBanner?.classList.add('hidden');
    waitlistDuplicateWaitlistBanner?.classList.add('hidden');

    const existingName = (checkResult.existingName || '').trim().toLowerCase();
    const inputName = name.trim().toLowerCase();

    if (checkResult.registered) {
      hidePlayerRegistration(true);
      waitlistBanner?.classList.add('hidden');
      waitlistNameBanner?.classList.add('hidden');
      if (waitlistBtn) waitlistBtn.disabled = false;
    } else if (checkResult.emailExists && existingName && existingName !== inputName) {
      // Email exists with different name
      waitlistBanner?.classList.remove('hidden');
      waitlistNameBanner?.classList.add('hidden');
      hidePlayerRegistration(true);
      if (waitlistBtn) waitlistBtn.disabled = true;
    } else if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      // Name exists with different email - show warning banner only if not already confirmed
      if (!_nameConflictConfirmed) {
        waitlistNameBanner?.classList.remove('hidden');
        waitlistBanner?.classList.add('hidden');
        hidePlayerRegistration(true);
        if (waitlistBtn) waitlistBtn.disabled = false;
      } else {
        // Already confirmed, show form
        document.getElementById('waitlistName').value = name;
        document.getElementById('waitlistEmail').value = email;
        showPlayerRegistration({ name, email }, true);
        waitlistBanner?.classList.add('hidden');
        waitlistNameBanner?.classList.add('hidden');
        if (waitlistBtn) waitlistBtn.disabled = false;
      }
    } else {
      // Pre-fill waitlist form and show registration form (waitlist only, don't show booking form)
      document.getElementById('waitlistName').value = name;
      document.getElementById('waitlistEmail').value = email;
      showPlayerRegistration({ name, email }, true);
      waitlistBanner?.classList.add('hidden');
      waitlistNameBanner?.classList.add('hidden');
      if (waitlistBtn) waitlistBtn.disabled = false;
    }
  } catch (err) {
    console.error('Waitlist: registration check failed', err);
  }
}, 600);

['input','change'].forEach(ev => {
  document.getElementById('name').addEventListener(ev, handleNameEmailChange);
  document.getElementById('email').addEventListener(ev, handleNameEmailChange);
});

['input','change'].forEach(ev => {
  document.getElementById('waitlistName').addEventListener(ev, handleWaitlistNameEmailChange);
  document.getElementById('waitlistEmail').addEventListener(ev, handleWaitlistNameEmailChange);
});

// Handle "Yes, Continue" button for name conflict in booking form
document.getElementById('nameConflictYesBtn')?.addEventListener('click', () => {
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();
  const nameConflictBanner = document.getElementById('nameConflictBanner');
  nameConflictBanner?.classList.add('hidden');
  _nameConflictConfirmed = true;
  showPlayerRegistration({ name, email });
});

// Handle "Yes, Continue" button for name conflict in waitlist form
document.getElementById('waitlistNameConflictYesBtn')?.addEventListener('click', () => {
  const name = document.getElementById('waitlistName').value.trim();
  const email = document.getElementById('waitlistEmail').value.trim();
  const waitlistNameBanner = document.getElementById('waitlistNameConflictBanner');
  waitlistNameBanner?.classList.add('hidden');
  _nameConflictConfirmed = true;
  document.getElementById('waitlistName').value = name;
  document.getElementById('waitlistEmail').value = email;
  showPlayerRegistration({ name, email }, true);
});

// New book button flow which checks registration first
document.getElementById('bookBtn').onclick = async () => {
  console.log('üî¥ RESERVE BUTTON CLICKED');
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();
  console.log('üìù Name:', name, 'Email:', email, 'SelectedSlot:', selectedSlot);
  const confirmEl = document.getElementById('blockConfirmation');

  // Validate inputs
  if (!selectedSlot) {
    console.warn('‚ùå No slot selected');
    alert('Please select a session');
    return;
  }
  if (!name) {
    alert('Please enter your name');
    return;
  }
  if (!email) {
    alert('Please enter your email');
    return;
  }

  // If block session, validate checkbox
  if (selectedSlot.blockId) {
    const checkbox = document.getElementById('blockCheckbox');
    if (!checkbox.checked) {
      alert('Please confirm you understand this is a 4-date block session');
      return;
    }
  }

  try {
    // Check registration first
    const registered = await checkPlayerRegistered(name, email);
    
    if (registered) {
      console.log('Player is registered, continuing to book');
      // proceed with normal booking flow
      let bookingResult;
      try {
        if (selectedSlot.blockId) {
          bookingResult = await saveBlockBooking(selectedSlot, name, email);
        } else {
          bookingResult = await saveBooking(selectedSlot, name, email);
        }
        console.log('Booking saved, result:', bookingResult);
      } catch (err) {
        console.error('Error saving booking:', err);
        alert('Error saving booking. Please try again.');
        return;
      }
      const bookingId = bookingResult && bookingResult.bookingId ? bookingResult.bookingId : null;
      console.log('Calling showPaymentInstructions with bookingId:', bookingId);
      console.log('üü¢ Full bookingResult:', JSON.stringify(bookingResult));
      console.log('üü¢ Extracted bookingId:', bookingId);
      if (!bookingId) {
        console.error('‚ùå WARNING: bookingId is null/undefined! Email cancellation link will not work!');
      }
      console.log('üü¢ showPaymentInstructions about to be called with:', { selectedSlot, name, email, selectedDate, bookingId });
      showPaymentInstructions(selectedSlot, name, email, selectedDate, bookingId);
      console.log('üü¢ showPaymentInstructions returned');
    } else {
      // Player not registered - check if registration form is visible and filled
      const regForm = document.getElementById('playerRegistrationForm');
      const isRegVisible = regForm && regForm.classList.contains('visible');
      
      if (isRegVisible) {
        // Registration form is showing - validate and save it
        const profile = collectRegistrationData();
        clearRegistrationFieldErrors();
        const errs = validateRegistration(profile);
        
        if (errs.length > 0) {
          showRegistrationFieldErrors(profile);
          alert('Please complete all required registration fields');
          return;
        }
        
        // Save registration and proceed with booking
        console.log('Profile JSON to save:', JSON.stringify(profile, null, 2));
        const ok = await submitRegistrationAndContinue();
        
        if (ok) {
          // Registration saved, now proceed with booking
          let bookingResult;
          try {
            if (selectedSlot.blockId) {
              bookingResult = await saveBlockBooking(selectedSlot, name, email);
            } else {
              bookingResult = await saveBooking(selectedSlot, name, email);
            }
            console.log('Booking saved after registration, result:', bookingResult);
          } catch (err) {
            console.error('Error saving booking:', err);
            alert('Error saving booking. Please try again.');
            return;
          }
          const bookingId = bookingResult && bookingResult.bookingId ? bookingResult.bookingId : null;
          console.log('Calling showPaymentInstructions with bookingId:', bookingId);
          showPaymentInstructions(selectedSlot, name, email, selectedDate, bookingId);
        }
      } else {
        // Show registration form for first time
        showPlayerRegistration({ name, email });
      }
    }
  } catch (error) {
    console.error('Booking error:', error);
    alert('Error confirming booking. Please try again.');
  }
};

/* ================= PAYMENT COPY BUTTONS ================= */
document.getElementById('copyAccountBtn').onclick = (e) => {
  e.preventDefault();
  copyToClipboard(document.getElementById('accountNumber'), document.getElementById('copyAccountBtn'));
};

document.getElementById('copySortBtn').onclick = (e) => {
  e.preventDefault();
  copyToClipboard(document.getElementById('sortCode'), document.getElementById('copySortBtn'));
};

document.getElementById('copyRefBtn').onclick = (e) => {
  e.preventDefault();
  copyToClipboard(document.getElementById('paymentReference'), document.getElementById('copyRefBtn'));
};

/* ================= MODAL CONTROLS ================= */
document.getElementById('closePaymentModal').onclick = async () => {
  console.log('X button clicked - sending reservation email and closing');
  const emailSent = await sendReservationEmail();
  if (emailSent) {
    currentBookingData = null;
    currentBookingId = null;
    hidePaymentInstructions();
    setTimeout(() => {
      console.log('Auto-refreshing page to show pending reservation state');
      location.reload();
    }, 1000);
  }
};

document.getElementById('closePaymentBtn').onclick = async () => {
  console.log('Close button clicked - sending reservation email and closing');
  const emailSent = await sendReservationEmail();
  if (emailSent) {
    currentBookingData = null;
    currentBookingId = null;
    hidePaymentInstructions();
    setTimeout(() => {
      console.log('Auto-refreshing page to show pending reservation state');
      location.reload();
    }, 1000);
  }
};

// Disable overlay click to close (only allow explicit close via button)
document.getElementById('paymentModal').addEventListener('click', (e) => {
  if (e.target.id === 'paymentModal') {
    console.log('Overlay click ignored - must use Close button or Cancel');
  }
});

// ------------------- WAITLIST CONFIRMATION MODAL -------------------
const closeWaitlistModal = document.getElementById('closeWaitlistModal');
const closeWaitlistBtn = document.getElementById('closeWaitlistBtn');
const waitlistConfirmationModal = document.getElementById('waitlistConfirmationModal');

if (closeWaitlistModal) {
  closeWaitlistModal.onclick = () => {
    hideWaitlistConfirmationModal();
  };
}

if (closeWaitlistBtn) {
  closeWaitlistBtn.onclick = () => {
    hideWaitlistConfirmationModal();
  };
}

if (waitlistConfirmationModal) {
  waitlistConfirmationModal.addEventListener('click', (e) => {
    if (e.target.id === 'waitlistConfirmationModal' || e.target.classList.contains('payment-modal-overlay')) {
      hideWaitlistConfirmationModal();
    }
  });
}

// ------------------- USER GUIDE MODAL (UI-only) -------------------
const userGuideModal = document.getElementById('userGuideModal');
const openUserGuideBtn = document.getElementById('openUserGuideBtn');
const closeUserGuideBtn = document.getElementById('closeUserGuideBtn');
const closeUserGuideX = document.getElementById('closeUserGuide');
let _lastFocusedBeforeGuide = null;

function openUserGuide(){
  if (!userGuideModal) return;
  _lastFocusedBeforeGuide = document.activeElement;
  userGuideModal.classList.remove('hidden');
  userGuideModal.setAttribute('aria-hidden','false');
  document.body.classList.add('modal-open-payment');
  const content = userGuideModal.querySelector('.payment-modal-content');
  content.focus();
  document.addEventListener('keydown', _userGuideKeyHandler);
}

function closeUserGuide(){
  if (!userGuideModal) return;
  userGuideModal.classList.add('hidden');
  userGuideModal.setAttribute('aria-hidden','true');
  document.body.classList.remove('modal-open-payment');
  document.removeEventListener('keydown', _userGuideKeyHandler);
  try { _lastFocusedBeforeGuide?.focus(); } catch (err) {}
}

function _userGuideKeyHandler(e){
  if (e.key === 'Escape') closeUserGuide();
}

openUserGuideBtn?.addEventListener('click', (e)=>{ e.preventDefault(); openUserGuide(); });
closeUserGuideBtn?.addEventListener('click', (e)=>{ e.preventDefault(); closeUserGuide(); });
closeUserGuideX?.addEventListener('click', (e)=>{ e.preventDefault(); closeUserGuide(); });

// Close when clicking overlay area (user expects this for help dialogs)
userGuideModal?.addEventListener('click', (e)=>{ if (e.target.id === 'userGuideModal') closeUserGuide(); });

// Accessibility: allow focus to land inside the dialog
userGuideModal?.querySelector('.payment-modal-content')?.setAttribute('tabindex','-1');
// -----------------------------------------------------------------

/* ================= CANCEL BOOKING ================= */
document.getElementById('cancelBookingBtn').onclick = async () => {
  if (!currentBookingData) {
    alert('Error: No booking data found');
    return;
  }
  
  console.log('Cancel button clicked - user does NOT want to reserve');
  console.log('Booking Reference (NOT sending email):', currentBookingData.paymentRef);
  
  if (!confirm('Are you sure? This will remove your booking and you can re-book if the slot is available.')) {
    return;
  }
  
  try {
    console.log('Calling cancelBooking.php to delete reservation');
    const response = await fetch(PHP_PATH + 'cancelBooking.php', {
      method: 'POST',
      body: JSON.stringify({
        name: currentBookingData.name,
        email: currentBookingData.email,
        date: currentBookingData.date,
        time: currentBookingData.slot.time,
        title: currentBookingData.slot.title,
        isBlock: currentBookingData.isBlock,
        blockDates: currentBookingData.blockDates,
        bookingId: currentBookingId || ''
      })
    });
    
    if (!response.ok) {
      throw new Error('Failed to cancel booking');
    }
    
    const result = await response.json();
    
    if (result.status === 'ok') {
      console.log('‚úì Booking cancelled successfully - NO email sent (as intended)');
      alert('Booking cancelled. Your slot has been released.');
      
      // Reset UI
      hidePaymentInstructions();
      document.getElementById('name').value = '';
      document.getElementById('email').value = '';
      selectedSlot = null;
      hideBlockConfirmation();
      document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
      
      // Refresh calendar and slots
      buildCalendarSkeleton();
    } else {
      alert('Error: ' + (result.message || 'Failed to cancel booking'));
    }
  } catch (error) {
    console.error('Cancellation error:', error);
    alert('Error cancelling booking. Please try again.');
  }
};
document.getElementById('waitlistBtn').onclick = async () => {
  const name = document.getElementById('waitlistName').value.trim();
  const email = document.getElementById('waitlistEmail').value.trim();
  const isConfirmed = document.getElementById('waitlistConfirm').checked;
  console.log('üü† WAITLIST BUTTON CLICKED', { name, email, selectedSlot, selectedDate, isConfirmed });
  
  // Validate inputs
  if (!selectedSlot) {
    alert('Please select a session');
    return;
  }
  if (!name) {
    alert('Please enter your name');
    return;
  }
  if (!email) {
    alert('Please enter your email');
    return;
  }
  if (!isConfirmed) {
    alert('Please check the confirmation box before joining the waitlist');
    return;
  }
  
  try {
    console.log('üü† Waitlist: starting registration check');
    const saveWaitlistEntry = async (finalName, finalEmail) => {
      console.log('üü† Waitlist: saving entry for', finalName, finalEmail);
      const response = await fetch(PHP_PATH + 'saveWaitlist.php', {
        method: 'POST',
        body: JSON.stringify({
          slot: selectedSlot,
          name: finalName,
          email: finalEmail,
          date: selectedDate,
          blockId: selectedSlot.blockId,
          blockDates: selectedSlot.blockDates
        })
      });
      const result = await response.json().catch(() => ({}));
      console.log('üü† Waitlist: saveWaitlist response:', result);
      if (!response.ok) throw new Error(result.message || 'Failed to add to waitlist');
      return result;
    };

    // Check registration first (same logic as booking)
    const registeredResult = await checkPlayerRegistered(name, email);
    const registered = !!registeredResult.registered;
    
    console.log('üü† Waitlist: registered?', registered, registeredResult);

    let finalName = name;
    let finalEmail = email;
    let waitlistResult = null;

    if (registered) {
      waitlistResult = await saveWaitlistEntry(name, email);
    } else {
      const regForm = document.getElementById('playerRegistrationForm');
      const isRegVisible = regForm && !regForm.classList.contains('hidden');

      // Ensure profile save uses the waitlist name/email
      document.getElementById('name').value = name;
      document.getElementById('email').value = email;

      if (!isRegVisible) {
        // Pre-fill registration form fields for new player, then show registration form (waitlist only)
        document.getElementById('waitlistName').value = name;
        document.getElementById('waitlistEmail').value = email;
        showPlayerRegistration({ name, email }, true);
        return;
      }

      const profile = collectRegistrationData();
      clearRegistrationFieldErrors();
      const errs = validateRegistration(profile);

      if (errs.length > 0) {
        showRegistrationFieldErrors(profile);
        alert('Please complete all required registration fields');
        return;
      }

      const ok = await submitRegistrationAndContinue();
      if (!ok) return;

      finalName = document.getElementById('name').value.trim();
      finalEmail = document.getElementById('email').value.trim();
      waitlistResult = await saveWaitlistEntry(finalName, finalEmail);
    }

    const waitlistSlot = selectedSlot;
    const waitlistDate = selectedDate;
    console.log('üü† Waitlist result object:', waitlistResult);
    const waitlistPosition = waitlistResult?.waitlistPosition || '-';
    console.log('üü† Extracted waitlist position:', waitlistPosition);
    showWaitlistConfirmationModal(waitlistPosition);
    sendWaitlistConfirmationEmail({
      name: finalName,
      email: finalEmail,
      slot: waitlistSlot,
      date: waitlistDate,
      waitlistPosition: waitlistPosition
    });

    // Reset form
    document.getElementById('waitlistName').value = '';
    document.getElementById('waitlistEmail').value = '';
    const waitlistConfirm = document.getElementById('waitlistConfirm');
    if (waitlistConfirm) waitlistConfirm.checked = false;
    const waitlistForm = document.getElementById('waitlistForm');
    if (waitlistForm) {
      waitlistForm.classList.add('hidden');
      waitlistForm.style.display = 'none';
    }
    selectedSlot = null;
    hideBlockConfirmation();
    document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
    
    // Refresh calendar and slots
    buildCalendarSkeleton();
  } catch (error) {

    console.error('Waitlist error:', error);
    alert('Error adding to waitlist. Please try again.');
  }
};

// Show waitlist form only after checkbox is checked
document.getElementById('waitlistConfirm').onchange = (e) => {
  const waitlistForm = document.getElementById('waitlistForm');
  if (e.target.checked) {
    waitlistForm.classList.remove('hidden');
    waitlistForm.style.display = '';
    
    // Show block confirmation in waitlist mode if a block session is selected
    if (selectedSlot && selectedSlot.blockId) {
      showBlockConfirmation(selectedSlot, true);
      // Auto-scroll to show confirmation and next step
      const blockDetails = document.getElementById('blockConfirmation');
      blockDetails?.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }
  } else {
    waitlistForm.classList.add('hidden');
    waitlistForm.style.display = 'none';
    
    // Hide block confirmation when unchecked
    hideBlockConfirmation();
  }
};

// Show booking form only after block checkbox is checked
document.getElementById('blockCheckbox').onchange = (e) => {
  const bookingForm = document.getElementById('bookingForm');
  const titleEl = document.getElementById('playerRegistrationTitle');
  const regForm = document.getElementById('playerRegistrationForm');
  const blockConfirmation = document.getElementById('blockConfirmation');
  const isWaitlistMode = blockConfirmation?.classList.contains('waitlist-mode');
  
  if (e.target.checked) {
    // Only show booking form if NOT in waitlist mode (i.e., session is not fully booked)
    if (!isWaitlistMode) {
      // Show booking form (with name/email fields)
      bookingForm.classList.remove('hidden');
      bookingForm.style.display = '';
      // Show player registration title and form
      titleEl?.classList.remove('hidden');
      regForm?.classList.remove('hidden');
      // Auto-scroll to show confirmation and next step
      bookingForm?.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }
  } else {
    // Hide all forms when unchecked
    bookingForm.classList.add('hidden');
    bookingForm.style.display = 'none';
    titleEl?.classList.add('hidden');
    regForm?.classList.add('hidden');
  }
};



/* ================= INIT ================= */
buildCalendarSkeleton();
</script>

<!-- Help link at bottom of page -->
<div style="text-align:center; padding:24px 12px; color:var(--muted);">
  <button id="bottomHelpLink" class="help-link" type="button">
    <span>Need help cancelling a session?</span>
  </button>
</div>

<script>
document.getElementById('bottomHelpLink')?.addEventListener('click', (e)=>{ e.preventDefault(); openUserGuide(); });
</script>

</body>
</html>
