<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Book a Session</title>

<link rel="stylesheet" href="styles.css">

</head>

<body>

<div class="container" id="bookingPage">
<img src="NewLogo.png" alt="Logo"
     style="display:block;margin:0 auto 2px;;width:70vw;max-width:600px;">




  <div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
    <div class="month-nav">
      <span id="prevMonth" class="month-arrow">
        <svg width="44" height="44" viewBox="0 0 44 44" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="22" cy="22" r="22" fill="#111"/>
          <polyline points="27,13 15,22 27,31" fill="none" stroke="#fff" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </span>
      <span id="monthYear"></span>
      <span id="nextMonth" class="month-arrow">
        <svg width="44" height="44" viewBox="0 0 44 44" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="22" cy="22" r="22" fill="#111"/>
          <polyline points="17,13 29,22 17,31" fill="none" stroke="#fff" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </span>
    </div>
    <div class="booking-header-actions" role="toolbar" aria-label="Booking actions" style="margin-top: 0.5em; align-items: center; justify-content: center; display: flex; width: 100%;">
      <button id="openUserGuideBtn" class="help-link" type="button">
        <span>Need help?</span>
      </button>
    </div>
  </div>

  <!-- Calendar weekday header (Monday-first) -->
  <div class="calendar-head" aria-hidden="false">
    <div class="day-label">Mon</div>
    <div class="day-label">Tue</div>
    <div class="day-label">Wed</div>
    <div class="day-label">Thu</div>
    <div class="day-label">Fri</div>
    <div class="day-label">Sat</div>
    <div class="day-label">Sun</div>
  </div>

  <div class="calendar" id="calendar"></div>

  <!-- Color Legend -->
  <div class="calendar-color-legend" style="display:flex;flex-direction:column;gap:8px;overflow-x:visible;align-items:flex-start;">
    <div class="legend-row" style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;width:100%;justify-content:flex-start;">
      <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
        <div class="legend-dot" style="background:#10b981;width:14px;height:14px;min-width:14px;min-height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.2);"></div>
        <span>Session available</span>
      </div>
      <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
        <div class="legend-dot" style="background:#3b82f6;width:14px;height:14px;min-width:14px;min-height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.2);"></div>
        <span>Subsequent block sessions</span>
      </div>
    </div>
    <div class="legend-row" style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;width:100%;justify-content:flex-start;">
      <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
        <div class="legend-dot" style="background:#ef4444;width:14px;height:14px;min-width:14px;min-height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.2);"></div>
        <span>Session full</span>
      </div>
      <div class="legend-item" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
        <div class="legend-dot" style="background:#9ca3af;width:14px;height:14px;min-width:14px;min-height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,0.2);"></div>
        <span>Session unavailable</span>
      </div>
    </div>
  </div>
</div>

<!-- AVAILABLE SLOTS (Unified container for single + block slots) -->
<div class="available-slots container">
  <h2 class="available-title">SELECT A DATE</h2>
  <div class="slots" id="slots"></div>
  <div class="block-slots" id="blockSlots"></div>
</div>

<!-- NORMAL SLOTS (stays removed from here; booking form follows) -->
<div class="container">

  <!-- BLOCK SESSION CONFIRMATION (APPEARS WHEN BLOCK IS SELECTED) -->
  <h2 id="blockConfirmationTitle" class="available-title block-confirmation-title hidden">Block Session Details</h2>
  
  <!-- WAITLIST NOTICE (SHOWS WHEN SLOT IS FULLY BOOKED) -->
  
  <div id="blockConfirmation" class="block-confirmation hidden">
    <div class="confirmation-dates">
      <strong>Your booking includes these dates:</strong>
      <ul id="blockDatesList"></ul>
    </div>
    <div class="confirmation-details" id="blockDetails">
      <!-- Full session card markup for block session details -->
      <div class="slot-card-inner">
        <div class="block-info">
          <div class="slot-header">
            <div class="slot-title-row">
              <span class="slot-title" id="blockTitle">-</span>
            </div>
            <div class="slot-actions">
              <span class="pill fully-booked-pill" id="blockFullPill" style="display:none">Fully Booked</span>
            </div>
          </div>
          <div class="slot-meta">
            <div class="slot-time" id="blockTime">-</div>
          </div>
          <div class="slot-extra" id="blockExtra"></div>
        </div>
      </div>
    </div>
    <label class="checkbox-label">
      <input type="checkbox" id="blockCheckbox">
      <span>I understand I am committing to multiple sessions</span>
    </label>
  </div>


  <!-- PAYMENT INSTRUCTIONS MODAL -->
  <div id="paymentModal" class="payment-modal hidden">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content">
      <button class="modal-close" id="closePaymentModal">&times;</button>
      
      <div class="payment-header">
        <h2>Booking Reserved</h2>
        <p>Complete your payment to confirm your spot</p>
      </div>

      <div class="payment-section">
        <h3>Session Details</h3>
        <div class="session-details">
          <div class="detail-row">
            <span class="label">Date:</span>
            <span class="value" id="paymentDate">-</span>
          </div>
          <div class="detail-row">
            <span class="label">Time:</span>
            <span class="value" id="paymentTime">-</span>
          </div>
          <div class="detail-row">
            <span class="label">Session:</span>
            <span class="value" id="paymentTitle">-</span>
          </div>
          <div class="detail-row highlight">
            <span class="label">Price:</span>
            <span class="value" id="paymentPrice">-</span>
          </div>
        </div>
      </div>

      <div class="payment-section">
        <h3>Bank Transfer Details</h3>
        <div class="bank-details">
          <div class="detail-row">
            <span class="label">Account Name:</span>
            <span class="value">Hoop Theory</span>
          </div>
          <div class="detail-row">
            <span class="label">Account Number:</span>
            <div class="copyable-value">
              <span id="accountNumber">12345678</span>
              <button class="copy-btn" id="copyAccountBtn" title="Copy account number">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                </svg>
              </button>
            </div>
          </div>
          <div class="detail-row">
            <span class="label">Sort Code:</span>
            <div class="copyable-value">
              <span id="sortCode">12-34-56</span>
              <button class="copy-btn" id="copySortBtn" title="Copy sort code">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                </svg>
              </button>
            </div>
          </div>
          <div class="detail-row">
            <span class="label">Reference:</span>
            <div class="copyable-value">
              <span id="paymentReference">-</span>
              <button class="copy-btn" id="copyRefBtn" title="Copy payment reference">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                </svg>
              </button>
            </div>
            <p style="font-size: 0.75rem; color: #999; margin: 4px 0 0; font-style: italic;">Format: FULLNAME-SESSIONNAME</p>
          </div>
        </div>
      </div>

      <div class="payment-section">
        <h3>Payment Deadline</h3>
        <div class="deadline-info">
          <p id="paymentDeadline">-</p>
          <p class="deadline-note">Please complete payment by this time to hold your reservation</p>
        </div>
      </div>

      <div class="payment-message">
        <p>You will also be sent an email with these payment details.</p>
        <p><strong>Once payment is received, you will receive a final confirmation email.</strong></p>
        <p class="deadline-note" style="margin-top:8px;color:#b91c1c;font-weight:600;">Important: please note that refunds will not be issued after your spot has been confirmed.</p>
      </div>

      <div class="modal-actions">
        <button id="cancelBookingBtn" class="cancel-btn">Cancel Reservation</button>
        <button id="closePaymentBtn" class="close-modal-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- USER GUIDE MODAL (UI-only, editable) -->
  <div id="userGuideModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="userGuideTitle" tabindex="-1">
      <button class="modal-close" id="closeUserGuide" aria-label="Close user guide">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="userGuideTitle">How to use the booking system</h2>
        <p style="margin-top:6px;color:var(--muted);">Quick steps to get you booked in ‚Äî it only takes a minute.</p>
      </div>

      <div class="payment-section">
        <h3>Quick steps</h3>
        <ol style="margin:0 0 0 18px; color:var(--muted); line-height:1.6;">
          <li><strong>Select a date</strong> from the calendar.</li>
          <li><strong>Select a session</strong> from the available times shown below the calendar.</li>
          <li><strong>Fill in the registration form</strong> ‚Äî this is mandatory if it's your first time signing up.</li>
          <li><strong>Make your payment</strong> ‚Äî once received you will get a confirmation email.</li>
          <li>If the session is full, you can <strong>join the waiting list</strong> for that session.</li>
        </ol>
      </div>

      <div class="payment-section" style="padding-top:12px;">
        <h3>Cancelling a session</h3>
        <p style="color:var(--muted); margin:0 0 8px 0;">To cancel a booking:</p>
        <ol style="margin:0 0 0 18px; color:var(--muted); line-height:1.6;">
          <li>Check your <strong>reservation or confirmation email</strong> from Hoop Theory.</li>
          <li>Click the <strong>Cancel</strong> button in the email.</li>
          <li>If you no longer have access to the email, contact <strong>Bao via WhatsApp</strong> and he will cancel it for you.</li>
        </ol>
        <p style="margin-top:10px;color:#b91c1c;font-weight:600;">Important: please note that refunds will not be issued after your spot has been confirmed.</p>
      </div>

      <div class="payment-section" style="padding-top:12px;">
        <h3>Need help?</h3>
        <p style="color:var(--muted); margin:0;">If you have any questions, please don‚Äôt hesitate to contact Bao via WhatsApp.</p>
      </div>

      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="closeUserGuideBtn" class="close-modal-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- WAITLIST CONFIRMATION MODAL -->
  <div id="waitlistConfirmationModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="waitlistConfirmationTitle" tabindex="-1">
      <button class="modal-close" id="closeWaitlistModal" aria-label="Close waitlist confirmation">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="waitlistConfirmationTitle">Waitlist Request Confirmed</h2>
      </div>

      <div class="payment-section">
        <p>Your waitlist request is confirmed.</p>
        <p>Details have been sent to your email.</p>
        <p>You are currently number <strong id="waitlistPositionValue">-</strong> on the waitlist.</p>
        <p>If a place becomes available, you will be notified and asked to complete payment within the stated time window. Unpaid offers may be released.</p>
        <p><strong>Please note this is NOT a booking reservation.</strong></p>
      </div>

      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="closeWaitlistBtn" class="modal-btn">Close</button>
      </div>
    </div>
  </div>

  <!-- WAITLIST EMAIL CONFLICT MODAL -->
  <div id="waitlistEmailConflictModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="waitlistEmailConflictTitle" tabindex="-1">
      <button class="modal-close" id="closeWaitlistEmailConflictModal" aria-label="Close email conflict">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="waitlistEmailConflictTitle" style="color:#222;">Email Conflict</h2>
      </div>
      <div class="payment-section">
        <p><strong>‚ö†Ô∏è This email is already registered to a different player.</strong></p>
        <p style="margin-bottom:8px;">If you are a parent registering multiple players, please continue. Otherwise, please use a different email.</p>
      </div>
      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="waitlistEmailConflictCancelBtn" class="modal-btn modal-btn--secondary">Change Email</button>
        <button id="waitlistEmailConflictYesBtn" class="modal-btn">Yes, Continue</button>
      </div>
    </div>
  </div>

  <!-- WAITLIST NAME CONFLICT MODAL -->
  <div id="waitlistNameConflictModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="waitlistNameConflictTitle" tabindex="-1">
      <button class="modal-close" id="closeWaitlistNameConflictModal" aria-label="Close name conflict">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="waitlistNameConflictTitle" style="color:#222;">Name Conflict</h2>
      </div>
      <div class="payment-section">
        <p><strong>This player name is already registered using a different email.</strong></p>
        <p>Are you sure you have entered your details correctly?</p>
      </div>
      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="waitlistNameConflictCancelBtn" class="modal-btn modal-btn--secondary">Cancel</button>
        <button id="waitlistNameConflictYesBtn" class="modal-btn">Yes, Continue</button>
      </div>
    </div>
  </div>

  <!-- BOOKING EMAIL CONFLICT MODAL -->
  <div id="bookingEmailConflictModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="bookingEmailConflictTitle" tabindex="-1">
      <button class="modal-close" id="closeBookingEmailConflictModal" aria-label="Close email conflict">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="bookingEmailConflictTitle" style="color:#222;">Email Conflict</h2>
      </div>
      <div class="payment-section">
        <p><strong>‚ö†Ô∏è This email is already registered to a different player.</strong></p>
        <p style="margin-bottom:8px;">If you are a parent registering multiple players, please continue. Otherwise, please use a different email.</p>
      </div>
      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="bookingEmailConflictCancelBtn" class="modal-btn modal-btn--secondary">Change Email</button>
        <button id="bookingEmailConflictYesBtn" class="modal-btn">Yes, Continue</button>
      </div>
    </div>
  </div>

  <!-- BOOKING NAME CONFLICT MODAL -->
  <div id="bookingNameConflictModal" class="payment-modal hidden" aria-hidden="true">
    <div class="payment-modal-overlay"></div>
    <div class="payment-modal-content" role="dialog" aria-modal="true" aria-labelledby="bookingNameConflictTitle" tabindex="-1">
      <button class="modal-close" id="closeBookingNameConflictModal" aria-label="Close name conflict">&times;</button>
      <div class="payment-header" style="padding-bottom:6px;">
        <h2 id="bookingNameConflictTitle" style="color:#222;">Name Conflict</h2>
      </div>
      <div class="payment-section">
        <p><strong>This player name is already registered using a different email.</strong></p>
        <p>Are you sure you have entered your details correctly?</p>
      </div>
      <div class="modal-actions" style="display:flex;justify-content:flex-end;gap:12px;padding-top:12px;">
        <button id="bookingNameConflictCancelBtn" class="modal-btn modal-btn--secondary">Cancel</button>
        <button id="bookingNameConflictYesBtn" class="modal-btn">Yes, Continue</button>
      </div>
    </div>
  </div>

  <!-- PLAYER REGISTRATION TITLE (OUTSIDE BOOKING FORM) -->
  <h2 id="playerRegistrationTitle" class="available-title player-registration-title hidden">Player Registration</h2>

  <!-- NORMAL BOOKING FORM (SHOWS WHEN SLOT IS AVAILABLE) -->
  <div id="bookingForm" class="booking-form hidden" style="display: none;">

    <div id="bookingMessageBanner" class="email-conflict-banner hidden" style="background-color: #fee; border: 1px solid #f55; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #c00; font-weight: 600;"></div>

    <label id="nameLabel">Player‚Äôs First and Last Name</label>
    <input type="text" id="name" placeholder="Hoop Theorist" style="color:#888;">


    <label id="emailLabel">Your Email</label>
    <input type="email" id="email" placeholder="SameEmailEveryBooking@gmail.com" style="color:#888;">
    <div id="emailHelper" style="font-size:0.85em;color:#888;margin-top:2px;margin-bottom:10px;">(Please use the same email for every booking)</div>

    <div id="emailConflictBanner" class="email-conflict-banner hidden" style="background-color: #fee; border: 1px solid #f55; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #c00; font-weight: 600;">
      <div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è This email is already registered to a different name.</div>
      <div style="margin-bottom: 12px; font-size: 0.9rem;">If this is correct, you can continue and complete a new registration.</div>
      <button id="emailConflictYesBtn" style="background: #ef4444; color: white; padding: 6px 16px; border: none; border-radius: 6px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">Yes, Continue</button>
    </div>

    <div id="nameConflictBanner" class="name-conflict-banner hidden" style="background-color: #fffbeb; border: 1px solid #f59e0b; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #92400e;">
      <div style="font-weight: 600; margin-bottom: 8px;">This player name is already registered using a different email.</div>
      <div style="margin-bottom: 12px; font-size: 0.9rem;">Are you sure you have entered your details correctly?</div>
      <button id="nameConflictYesBtn" style="background: #f59e0b; color: white; padding: 6px 16px; border: none; border-radius: 6px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">Yes, Continue</button>
    </div>

    <div id="duplicateBookingBanner" class="email-conflict-banner hidden" style="background-color: #f3f4f6; border: 1px solid #9ca3af; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #374151; font-weight: 600;">
      This user is already booked onto this session.
    </div>

    <!-- PLAYER REGISTRATION FORM (INLINE) -->
    <div id="playerRegistrationHostBooking">
      <div id="playerRegistrationForm" class="player-registration-form hidden">
      <h3 style="color: #1f2937; margin-bottom: 8px;">New Player Registration</h3>
      <p id="registrationWelcomeMessage" class="info" style="margin-bottom: 16px;">Welcome. Please complete this mandatory form to help us manage your booking and ensure your safety.</p>

      <label id="ageLabel">Age</label>
      <input type="number" id="player_age" min="0">

      <label id="experienceLabel">Playing Experience</label>
      <select id="player_experience">
        <option value="">-- Select --</option>
        <option>No experience</option>
        <option>Beginner</option>
        <option>Regular player but no team</option>
        <option>Local league</option>
        <option>National league</option>
      </select>

      <label id="medicalLabel">Medical information</label>
      <textarea id="player_medical" rows="3" required placeholder="Relevant conditions, allergies, learning needs..."></textarea>

      <fieldset class="emergency-contact">
        <legend style="font-weight:600; color:var(--muted);">Emergency contact</legend>
        <label id="emergencyNameLabel">Name</label>
        <input type="text" id="emergency_name" required>
        <label id="emergencyPhoneLabel">Phone</label>
        <input type="text" id="emergency_phone" required>
        <!-- Waitlist checkbox handler is now set dynamically after slot selection -->
        <label id="emergencyRelationshipLabel">Relationship</label>
        <input type="text" id="emergency_relationship" required>
      </fieldset>
      <!-- Error/validation banner moved above consent checkboxes for visibility -->
      <div id="playerRegistrationErrorBanner" class="email-conflict-banner hidden" style="background-color: #fee; border: 1px solid #f55; border-radius: 6px; padding: 12px; margin-top: 18px; color: #c00; font-weight: 600;"></div>

      <label class="checkbox consent"><input type="checkbox" id="media_consent"> <span id="media_consent_label">I, the parent/guardian of [Player Name], grant permission for Hoop Theory to use photos and videos taken during sessions for promotional purposes, including social media and marketing materials.</span></label>
      <label class="checkbox waiver"><input type="checkbox" id="waiver_ack"> <span id="waiver_label">I, the parent/guardian of [Player Name], agree to allow my child to participate in Hoop Theory sessions, understand the inherent risks of sports, and waive any claims against Hoop Theory for injuries incurred.</span></label>
      </div>
    </div>

    <button id="bookBtn">Reserve Booking</button>
  </div>

  <!-- WAITLIST FORM (SHOWS WHEN SLOT IS FULLY BOOKED) -->
  <div id="waitlistForm" class="waitlist-form hidden">
    <div id="waitlistMessageBanner" class="email-conflict-banner hidden" style="background-color: #fee; border: 1px solid #f55; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #c00; font-weight: 600;"></div>
    <label>Player's First and Last Name</label>
    <input type="text" id="waitlistName" placeholder="Hoop Theorist" style="color:#888;" autocomplete="off">
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('waitlistName').onblur = handleWaitlistNameEmailChange;
        document.getElementById('waitlistEmail').onblur = handleWaitlistNameEmailChange;
      });
    </script>

    <label>Your Email</label>
    <input type="email" id="waitlistEmail" placeholder="SameEmailEveryBooking@gmail.com" style="color:#888;" autocomplete="off">
    <div id="emailHelper" style="font-size:0.85em;color:#888;margin-top:2px;margin-bottom:10px;">(Please use the same email for every booking)</div>

    <div id="waitlistEmailConflictBanner" class="email-conflict-banner hidden" style="background-color: #fee; border: 1px solid #f55; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #c00; font-weight: 600;">
      <div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è This email is already registered to a different name.</div>
      <div style="margin-bottom: 12px; font-size: 0.9rem;">If this is correct, you can continue and complete a new registration.</div>
      <button id="waitlistEmailConflictYesBtn" style="background: #ef4444; color: white; padding: 6px 16px; border: none; border-radius: 6px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">Yes, Continue</button>
    </div>

    <div id="waitlistNameConflictBanner" class="name-conflict-banner hidden" style="background-color: #fffbeb; border: 1px solid #f59e0b; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #92400e;">
      <div style="font-weight: 600; margin-bottom: 8px;">This player name is already registered using a different email.</div>
      <div style="margin-bottom: 12px; font-size: 0.9rem;">Are you sure you have entered your details correctly?</div>
      <button id="waitlistNameConflictYesBtn" style="background: #f59e0b; color: white; padding: 6px 16px; border: none; border-radius: 6px; font-size: 0.9rem; font-weight: 600; cursor: pointer;">Yes, Continue</button>
    </div>

    <!-- Only use the red waitlistMessageBanner for duplicate booking errors -->

    <div id="waitlistDuplicateWaitlistBanner" class="email-conflict-banner hidden" style="background-color: #f3f4f6; border: 1px solid #9ca3af; border-radius: 6px; padding: 12px; margin-bottom: 16px; color: #374151; font-weight: 600;">
      This user is already on the waitlist for this session.
    </div>

    <div id="playerRegistrationHostWaitlist"></div>

    <button id="waitlistBtn">Join Waitlist</button>
  </div>
</div>

<script>
/* ================= STATE ================= */
let selectedDate = null;
let selectedSlot = null;
let calendarRenderVersion = 0;
let slotRenderVersion = 0;
let currentDisplayDate = new Date();
let autoRefreshInterval = null;
let currentBookingData = null; // Track pending booking for cancellation
let currentBookingId = null; // Track the bookingId for email sending
let pendingBooking = null; // Temporarily hold booking details while user completes registration
let _registrationCheckId = 0; // incrementing token to cancel outdated checks
let _bookingNameConflictConfirmed = false; // booking: track if user confirmed name conflict
let _bookingEmailConflictConfirmed = false; // booking: track if user confirmed email conflict
let _waitlistNameConflictConfirmed = false; // waitlist: track if user confirmed name conflict
let _waitlistEmailConflictConfirmed = false; // waitlist: track if user confirmed email conflict
let _bookingConflictModalActive = false;
let _waitlistConflictModalActive = false;
let _lastCheckedName = '';
let _lastCheckedEmail = '';

const PHP_PATH = 'php/';
const REFRESH_INTERVAL = 5000;
const dateAvailabilityCache = {};

const BANK_DETAILS = {
  accountNumber: '12345678',
  sortCode: '12-34-56'
};

/* ================= INLINE MESSAGES ================= */
function setInlineMessage(el, message, type = 'error') {
  if (!el) return;
  el.textContent = message;
  el.classList.remove('hidden');
  if (type === 'success') {
    el.style.backgroundColor = '#ecfdf5';
    el.style.borderColor = '#10b981';
    el.style.color = '#065f46';
  } else if (type === 'info') {
    el.style.backgroundColor = '#eff6ff';
    el.style.borderColor = '#60a5fa';
    el.style.color = '#1e3a8a';
  } else {
    el.style.backgroundColor = '#fee';
    el.style.borderColor = '#f55';
    el.style.color = '#c00';
  }
}

function clearInlineMessage(el) {
  if (!el) return;
  el.textContent = '';
  el.classList.add('hidden');
}

function showBookingMessage(message, type = 'error') {
  setInlineMessage(document.getElementById('bookingMessageBanner'), message, type);
}

function showWaitlistMessage(message, type = 'error') {
  const banner = document.getElementById('waitlistMessageBanner');
  setInlineMessage(banner, message, type);
  if (banner) {
    banner.classList.remove('hidden'); // Ensure visible before scroll
    setTimeout(() => {
      // Try scrollIntoView first
      banner.scrollIntoView({behavior: 'smooth', block: 'center', inline: 'nearest'});
      // Fallback: force scroll window if not visible
      const rect = banner.getBoundingClientRect();
      const isVisible = rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);
      if (!isVisible) {
        window.scrollTo({top: window.scrollY + rect.top - 40, behavior: 'smooth'});
      }
      // Extra: scroll nearest scrollable parent if any
      let parent = banner.parentElement;
      while (parent && parent !== document.body) {
        const style = window.getComputedStyle(parent);
        const overflowY = style.overflowY;
        if ((overflowY === 'auto' || overflowY === 'scroll') && parent.scrollHeight > parent.clientHeight) {
          parent.scrollTo({top: banner.offsetTop - 40, behavior: 'smooth'});
          break;
        }
        parent = parent.parentElement;
      }
    }, 120);
  }
}

/* ================= DATE FORMATTING ================= */
function formatDateForDisplay(dateStr) {
  // Convert YYYY-MM-DD to "5 February 2026"
  const [year, month, day] = dateStr.split('-');
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                      'July', 'August', 'September', 'October', 'November', 'December'];
  const dayNum = parseInt(day);
  const monthName = monthNames[parseInt(month) - 1];
  return `${dayNum} ${monthName} ${year}`;
}

function formatSelectedDateHeader(dateStr) {
  // Convert YYYY-MM-DD to "THU 5th FEB 2026" (with ordinal and superscript)
  const [year, month, day] = dateStr.split('-');
  const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
  const dayNames = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
  const d = new Date(dateStr);
  const dayNum = parseInt(day);
  const dayName = dayNames[d.getDay()];
  const monthName = monthNames[parseInt(month) - 1];
  // Ordinal logic
  let ord = 'th';
  if (dayNum % 10 === 1 && dayNum !== 11) ord = 'st';
  else if (dayNum % 10 === 2 && dayNum !== 12) ord = 'nd';
  else if (dayNum % 10 === 3 && dayNum !== 13) ord = 'rd';
  return `${dayName} ${dayNum}<sup>${ord}</sup> ${monthName} ${year}`;
}

/* ================= API ================= */
async function getAvailableSlots(){
  return await (await fetch(PHP_PATH+'getSlots.php')).json();
}
async function getBookings(){
  return await (await fetch(PHP_PATH+'getBookings.php')).json();
}
async function getWaitlist(){
  return await (await fetch(PHP_PATH+'getWaitlist.php?t=' + Date.now(), { cache: 'no-store' })).json();
}

// Check if player is already booked on the current session
async function isPlayerAlreadyBooked(email, date, slot) {
  if (!email || !date || !slot) return false;

  const norm = (val) => (val ?? '').toString().trim().toLowerCase();
  
  try {
    // First check: for block bookings, check the bookedUsers array in the slot itself
    if (slot.bookedUsers && Array.isArray(slot.bookedUsers)) {
      const userAlreadyInBlock = slot.bookedUsers.some(user => {
        return user && user.email && norm(user.email) === norm(email);
      });
      if (userAlreadyInBlock) {
        console.log('Found duplicate in block bookedUsers array');
        return true;
      }
    }
    
    // Second check: for regular bookings, query the bookings data
    const bookingsData = await getBookings();
    
    // For block sessions, check ALL dates in the block
    let datesToCheck = [date];
    if (slot.blockId && slot.blockDates && Array.isArray(slot.blockDates)) {
      datesToCheck = slot.blockDates;
      console.log('Block session detected - checking all dates:', datesToCheck);
    }
    
    // Check if email exists in any booking for this slot on any of the dates
    for (const checkDate of datesToCheck) {
      const bookingsOnDate = bookingsData[checkDate] || [];
      
      const alreadyBooked = bookingsOnDate.some(booking => {
        if (!booking || typeof booking !== 'string') return false;
        const match = booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+@[^)]+)\)$/);
        if (!match) return false;
        const bookingTime = norm(match[1]);
        const bookingTitle = norm(match[2]);
        const bookingEmail = norm(match[4]);
        const matchesSlot = bookingTime === norm(slot.time) && bookingTitle === norm(slot.title);
        const matchesEmail = bookingEmail === norm(email);
        return matchesSlot && matchesEmail;
      });
      
      if (alreadyBooked) {
        console.log('User already booked on date:', checkDate);
        return true;
      }
    }
    
    return false;
  } catch (err) {
    console.error('Error checking if player already booked:', err);
    return false;
  }
}

// Check if player is already on the waitlist for the current session
async function isPlayerAlreadyOnWaitlist(email, date, slot) {
  if (!email || !date || !slot || !slot.time || !slot.title) return false;

  const norm = (val) => (val ?? '').toString().trim().toLowerCase();

  try {
    const waitlistData = await getWaitlist();
    
    // For block sessions, check the first date (where all block waitlist entries are stored)
    let lookupDate = date;
    if (slot.blockId && slot.blockDates && slot.blockDates.length > 0) {
      lookupDate = slot.blockDates[0];
    }
    
    const entries = waitlistData[lookupDate] || [];

    const slotTime = norm(slot.time);
    const slotTitle = norm(slot.title);
    const slotEmail = norm(email);

    const alreadyOnWaitlist = entries.some(entry => {
      if (!entry) return false;
      const entryTime = norm(entry.time);
      const entryTitle = norm(entry.title);
      const entryEmail = norm(entry.email);
      if (!entryTime || !entryTitle || !entryEmail) return false;

      const matchesSlot = entryTime === slotTime && entryTitle === slotTitle;
      const matchesEmail = entryEmail === slotEmail;
      
      // Also check blockId to distinguish between block and single sessions
      let matchesBlock = true;
      if (slot.blockId) {
        matchesBlock = entry.blockId === slot.blockId;
      } else {
        matchesBlock = !entry.blockId || entry.blockId === null;
      }
      
      const matches = matchesSlot && matchesEmail && matchesBlock;
      if (matches) {
        console.log('Waitlist match found:', { lookupDate, entry, slot });
      }
      return matches;
    });

    if (!alreadyOnWaitlist) return false;

    // Confirm with a second fresh fetch to avoid stale data
    const freshWaitlist = await (await fetch(PHP_PATH + 'getWaitlist.php?t=' + Date.now(), { cache: 'no-store' })).json();
    const freshEntries = freshWaitlist[lookupDate] || [];
    const confirmed = freshEntries.some(entry => {
      if (!entry) return false;
      const entryTime = norm(entry.time);
      const entryTitle = norm(entry.title);
      const entryEmail = norm(entry.email);
      if (!entryTime || !entryTitle || !entryEmail) return false;
      const matchesSlot = entryTime === slotTime && entryTitle === slotTitle;
      const matchesEmail = entryEmail === slotEmail;
      let matchesBlock = true;
      if (slot.blockId) {
        matchesBlock = entry.blockId === slot.blockId;
      } else {
        matchesBlock = !entry.blockId || entry.blockId === null;
      }
      return matchesSlot && matchesEmail && matchesBlock;
    });

    return confirmed;
  } catch (err) {
    console.error('Error checking if player already on waitlist:', err);
    return false;
  }
}

async function updateWaitlistCount(){
  const countEl = document.getElementById('waitlistCount');
  if (!countEl) return;
  if (!selectedSlot || !selectedDate) {
    countEl.textContent = '0 people on the waitlist';
    return;
  }

  try {
    const waitlistData = await getWaitlist();
    
    // For block sessions, check the first date (where all block waitlist entries are stored)
    let lookupDate = selectedDate;
    if (selectedSlot.blockId && selectedSlot.blockDates && selectedSlot.blockDates.length > 0) {
      lookupDate = selectedSlot.blockDates[0];
    }
    
    const entries = waitlistData[lookupDate] || [];
    
    // Filter by time, title, and blockId (if applicable)
    const count = entries.filter(e => {
      if (!e) return false;
      const timeMatch = e.time === selectedSlot.time;
      const titleMatch = e.title === selectedSlot.title;
      
      // For block sessions, match by blockId
      if (selectedSlot.blockId) {
        return timeMatch && titleMatch && e.blockId === selectedSlot.blockId;
      } else {
        // For single sessions, ensure it's not a block entry
        return timeMatch && titleMatch && !e.blockId;
      }
    }).length;
    
    countEl.textContent = `${count} ${count === 1 ? 'person' : 'people'} on the waitlist`;
  } catch (e) {
    console.error('Failed to load waitlist count', e);
    countEl.textContent = 'Waitlist count unavailable';
  }
}

/* ================= CALENDAR ================= */
function buildCalendarSkeleton(){
  calendarRenderVersion++;
  document.getElementById('calendar').innerHTML = '';
  document.getElementById('slots').innerHTML = '';
  document.getElementById('blockSlots').innerHTML = '';
  selectedDate = null;
  selectedSlot = null;

  // Reset the availability heading to default
  (document.querySelector('.available-title') || {textContent: null}).textContent = 'SELECT A DATE';
  
  // Hide all forms and payment modal
  hideBlockConfirmation();
  hidePaymentInstructions();
  showBookingForm(null);
  
  // Clear form inputs
  document.getElementById('name').value = '';
  document.getElementById('email').value = '';
  document.getElementById('waitlistName').value = '';
  document.getElementById('waitlistEmail').value = '';

  const year = currentDisplayDate.getFullYear();
  const month = currentDisplayDate.getMonth();
  // Build month grid with Monday as the first column
  const rawFirstDay = new Date(year, month, 1).getDay(); // 0=Sun,1=Mon...
  const firstDay = (rawFirstDay === 0) ? 6 : rawFirstDay - 1; // shift so 0=Mon..6=Sun
  const daysInMonth = new Date(year, month + 1, 0).getDate();

  const monthNames = [
    "January","February","March","April","May","June",
    "July","August","September","October","November","December"
  ];
  document.getElementById('monthYear').textContent =
    `${monthNames[month]} ${year}`;

  // Add leading empty cells for the first week
  for (let i = 0; i < firstDay; i++) {
    document.getElementById('calendar').appendChild(document.createElement('div'));
  }

  for (let d = 1; d <= daysInMonth; d++) {
    const dateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
    const div = document.createElement('div');
    div.className = 'day';
    div.dataset.date = dateStr;
    div.innerHTML = `<span>${d}</span>`;
    document.getElementById('calendar').appendChild(div);
  }

  refreshDateAvailability(true);
}

/* ================= AVAILABILITY ================= */
async function dateHasAvailableSlots(dateStr){
  const slotsData = await getAvailableSlots();
  const bookingsData = await getBookings();
  const slots = [...(slotsData[dateStr] || [])];
  // Fallback: include block sessions that list this date but are stored on another date
  const blockKey = (s) => `${s.blockId || ''}|${s.time || ''}|${s.title || ''}`;
  const existingBlockKeys = new Set(
    slots
      .filter(s => s && s.blockId && Array.isArray(s.blockDates))
      .map(s => blockKey(s))
  );
  for (const [otherDate, otherSlots] of Object.entries(slotsData || {})) {
    if (!Array.isArray(otherSlots)) continue;
    for (const s of otherSlots) {
      if (!s || !s.blockId || !Array.isArray(s.blockDates)) continue;
      if (!s.blockDates.includes(dateStr)) continue;
      const key = blockKey(s);
      if (existingBlockKeys.has(key)) continue;
      slots.push(s);
      existingBlockKeys.add(key);
    }
  }
  return slots.some(s => {
    const isBlock = s.blockId && s.blockDates;
    
    if (isBlock) {
      // For block sessions: check capacity across ALL dates in the block
      const uniqueEmails = new Set();
      for (const blockDate of s.blockDates) {
        if (bookingsData && bookingsData[blockDate]) {
          bookingsData[blockDate].forEach(b => {
            const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
            const bTime = parts ? parts[1] : null;
            const titleMatch = b.match(/-\s*(.+?)\s*\(/);
            const bTitle = titleMatch ? titleMatch[1].trim() : null;
            const emailMatch = b.match(/\(([^)]+@[^)]+)\)$/);
            if (bTime === s.time && bTitle === s.title && emailMatch) {
              uniqueEmails.add(emailMatch[1].toLowerCase());
            }
          });
        }
      }
      const bookedCount = uniqueEmails.size;
      return bookedCount < (s.numberOfSpots||1);
    } else {
      // Single session: derive booked count from bookings.json for this date only
      let booked = 0;
      if (bookingsData && bookingsData[dateStr]) {
        booked = bookingsData[dateStr].filter(b => {
          const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
          const bTime = parts ? parts[1] : null;
          const titleMatch = b.match(/-\s*(.+?)\s*\(/);
          const bTitle = titleMatch ? titleMatch[1].trim() : null;
          return bTime === s.time && bTitle === s.title;
        }).length;
      } else {
        booked = (s.bookedUsers||[]).length;
      }
      return booked < (s.numberOfSpots||1);
    }
  });
}

async function refreshDateAvailability(initial=false){
  const renderVersion = calendarRenderVersion;
  const days = document.querySelectorAll('.day[data-date]');
  const slotsData = await getAvailableSlots();
  const bookingsData = await getBookings();

  for (const div of days) {
    const dateStr = div.dataset.date;
    const date = new Date(dateStr);
    const today = new Date();
    today.setHours(0,0,0,0);

    if (date < today) {
      div.classList.add('disabled');
      continue;
    }

    const slots = slotsData[dateStr] || [];
    
    // Helper to get booked count for a slot
    const getBookedCount = (slot) => {
      let booked = 0;
      if (bookingsData && bookingsData[dateStr]) {
        booked = bookingsData[dateStr].filter(b => {
          const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
          const bTime = parts ? parts[1] : null;
          const titleMatch = b.match(/-\s*(.+?)\s*\(/);
          const bTitle = titleMatch ? titleMatch[1].trim() : null;
          return bTime === slot.time && bTitle === slot.title;
        }).length;
      } else {
        booked = (slot.bookedUsers||[]).length;
      }
      return booked;
    };

    // Determine color based on slot availability/booking status
    let hasAvailableSlots = false;
    let hasBlockSlots = false;
    let hasFullyBooked = false;
    let hasBridgeState = false;
    let allFullyBooked = true;

    for (const slot of slots) {
      const isBlock = slot.blockId && slot.blockDates;
      const isFirstDate = isBlock && slot.blockDates[0] === dateStr;
      const inBridgeState = slot.bridgeState === true;
      
      console.log(`üåâ Calendar check ${dateStr}: ${slot.title} bridgeState=${inBridgeState}`);
      
      let full = false;
      
      if (isBlock) {
        // For block sessions: check capacity across ALL dates in the block
        const uniqueEmails = new Set();
        for (const blockDate of slot.blockDates) {
          if (bookingsData && bookingsData[blockDate]) {
            bookingsData[blockDate].forEach(b => {
              const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
              const bTime = parts ? parts[1] : null;
              const titleMatch = b.match(/-\s*(.+?)\s*\(/);
              const bTitle = titleMatch ? titleMatch[1].trim() : null;
              const emailMatch = b.match(/\(([^)]+@[^)]+)\)$/);
              if (bTime === slot.time && bTitle === slot.title && emailMatch) {
                uniqueEmails.add(emailMatch[1].toLowerCase());
              }
            });
          }
        }
        const bookedCount = uniqueEmails.size;
        const spots = slot.numberOfSpots || 1;
        full = bookedCount >= spots;
      } else {
        // Single session: check only this date
        const booked = getBookedCount(slot);
        const spots = slot.numberOfSpots || 1;
        full = booked >= spots;
      }

      if (inBridgeState) {
        hasBridgeState = true;
        allFullyBooked = false;
      } else if (!full) {
        allFullyBooked = false;
        if (isFirstDate || !isBlock) {
          hasAvailableSlots = true; // GREEN: available on first date or single session
        } else if (isBlock) {
          hasBlockSlots = true; // BLUE: block session on non-first date
        }
      } else if (full) {
        hasFullyBooked = true;
      }
    }
    
    if (renderVersion !== calendarRenderVersion) return;

    // Remove any previous color classes
    div.classList.remove('available', 'block', 'full');

    let colorStatus = 'none';

    if (slots.length === 0) {
      // No slots at all
      div.classList.add('disabled');
      colorStatus = 'disabled';
    } else {
      div.classList.remove('disabled');
      
      if (hasBridgeState) {
        // GREY: At least one session in bridge state
        div.classList.add('bridge');
        colorStatus = 'grey-bridge';
        console.log(`üìÖ ${dateStr}: BRIDGE STATE`);
      } else if (allFullyBooked) {
        // RED: All sessions fully booked
        div.classList.add('full');
        colorStatus = 'red';
      } else if (hasAvailableSlots) {
        // GREEN: At least one available slot on first date or single
        div.classList.add('available');
        colorStatus = 'green';
      } else if (hasBlockSlots) {
        // BLUE: Block sessions available on non-first dates
        div.classList.add('block');
        colorStatus = 'blue';
      }
      
      div.onclick = () => handleDateClick(div, dateStr);
    }
    
    // DEBUG LOGGING
    if (slots.length > 0) {
      console.log(`üìÖ Date: ${dateStr} | Status: ${colorStatus} | Classes: ${div.className} | Slots: ${slots.length}`);
    }
  }
}

/* ================= DATE CLICK ================= */
async function handleDateClick(div, dateStr){
  console.log('%c[STEP 1: DATE SELECT]%c ' + dateStr, 'color:#10b981;font-weight:bold;', 'color:inherit;');
  slotRenderVersion++;
  const renderVersion = slotRenderVersion;
  
  selectedDate = dateStr;
  // Update availability header to show the selected date
  try {
    const hdr = document.querySelector('.available-title');
    if (hdr) hdr.innerHTML = 'SELECTED DATE: ' + formatSelectedDateHeader(dateStr);
  } catch (err) { /* ignore */ }
  document.querySelectorAll('.day').forEach(d => d.classList.remove('selected'));
  div.classList.add('selected');

  document.getElementById('slots').innerHTML = '';
  document.getElementById('blockSlots').innerHTML = '';
  selectedSlot = null;

  clearInlineMessage(document.getElementById('bookingMessageBanner'));
  clearInlineMessage(document.getElementById('waitlistMessageBanner'));
  
  // Reset forms when changing date
  hideBlockConfirmation();
  hidePaymentInstructions();
  showBookingForm(null);
  
  // Clear form inputs
  document.getElementById('name').value = '';
  document.getElementById('email').value = '';
  document.getElementById('waitlistName').value = '';
  document.getElementById('waitlistEmail').value = '';

  const slotsData = await getAvailableSlots();
  const bookingsData = await getBookings();
  
  // Discard this render if a newer one has started
  if (renderVersion !== slotRenderVersion) {
    console.log('üü° Discarding stale slot render (v' + renderVersion + ', current v' + slotRenderVersion + ')');
    return;
  }
  
  const slots = slotsData[dateStr] || [];
  const processedBlockIds = new Set();

  slots.forEach(slot => {
    const isBlock = slot.blockId && slot.blockDates;
    const spots = slot.numberOfSpots || 1;
    let booked = 0;
    let full = false;
    
    if (isBlock) {
      // For block sessions: aggregate unique emails across ALL dates in the block
      const uniqueEmails = new Set();
      for (const blockDate of slot.blockDates) {
        if (bookingsData && bookingsData[blockDate]) {
          bookingsData[blockDate].forEach(b => {
            const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
            const bTime = parts ? parts[1] : null;
            const titleMatch = b.match(/-\s*(.+?)\s*\(/);
            const bTitle = titleMatch ? titleMatch[1].trim() : null;
            const emailMatch = b.match(/\(([^)]+@[^)]+)\)$/);
            if (bTime === slot.time && bTitle === slot.title && emailMatch) {
              uniqueEmails.add(emailMatch[1].toLowerCase());
            }
          });
        }
      }
      booked = uniqueEmails.size;
      full = booked >= spots;
    } else {
      // Single session: derive booked count from bookings.json for this date only
      if (bookingsData && bookingsData[dateStr]) {
        booked = bookingsData[dateStr].filter(b => {
          const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
          const bTime = parts ? parts[1] : null;
          const titleMatch = b.match(/-\s*(.+?)\s*\(/);
          const bTitle = titleMatch ? titleMatch[1].trim() : null;
          return bTime === slot.time && bTitle === slot.title;
        }).length;
      } else {
        booked = (slot.bookedUsers || []).length;
      }
      full = booked >= spots;
    }

    if (isBlock && processedBlockIds.has(slot.blockId)) return;
    if (isBlock) processedBlockIds.add(slot.blockId);

    /* ===== BLOCK SESSION ===== */
    if (isBlock) {
      const el = document.createElement('div');
      el.className = 'slot-card block-card';

      // Determine if this is first date in block for color coding
      const isFirstDate = slot.blockDates[0] === dateStr;
      let colorClass = isFirstDate ? 'block-color-green' : 'block-color-blue';
      
      // Bridge State takes priority: grey out if in bridge mode
      const inBridgeState = slot.bridgeState === true;
      console.log(`üåâ Block slot ${slot.title}: bridgeState=${inBridgeState} full=${full}`);
      
      if (inBridgeState) {
        colorClass = 'bridge-state';
        console.log(`  ‚Üí BRIDGE STATE - showing grey`);
      }
      // Override with red if fully booked (but not in bridge state)
      else if (full) {
        colorClass = 'block-color-red';
      }

      let priceVal = slot.price;
      if (typeof priceVal === 'string') priceVal = parseFloat(priceVal);
      const priceDisplay = priceVal ? `¬£${!isNaN(priceVal) ? priceVal.toFixed(2) : slot.price}` : '';
      const locationDisplay = slot.location ? slot.location : '';

      el.innerHTML = `
        <div class="block-inner">
          <div class="slot-card-inner">
            <div class="block-info">
              <div class="slot-header">
                <div class="slot-title-row">
                  <span class="slot-title">${slot.title}</span>
                  ${!full ? `<span class="pill spots-pill ${isFirstDate ? 'block-first' : 'block-subsequent'}">${Math.max(0, (spots - booked))} / ${spots} spots left</span>` : ''}
                </div>
                <div class="slot-actions">
                  ${full ? '<span class="pill fully-booked-pill">Fully Booked</span>' : ''}
                </div>
              </div>
              <div class="slot-meta">
                <div class="slot-time">${slot.time}${slot.endTime ? ` - ${slot.endTime}` : ''} (4-Week Block)</div>
              </div>
              ${priceDisplay || locationDisplay ? `<div class="slot-extra">${priceDisplay ? `<div class="price-row"><span class="meta-icon"><object data="bank.jpg" type="image/jpeg" class="icon icon--price"></object></span><span class="price-text">${priceDisplay}</span></div>` : ''}${locationDisplay ? `<div class="location-row"><span class="meta-icon"><svg class="icon icon--location" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 21s7-4.5 7-10a7 7 0 1 0-14 0c0 5.5 7 10 7 10zM12 11a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg></span><span class="location-text">${locationDisplay}</span></div>` : ''}</div>` : ''}
            </div>
          </div>
          <!-- selectable indicator (bottom-right) -->
          <div class="select-indicator" role="button" aria-pressed="false" tabindex="0" title="Select session"></div>
        </div>
      `;

    el.classList.add(colorClass);

    // Add bridge state message if applicable
    if (inBridgeState) {
      console.log(`  ‚Üí Adding bridge message`);
      const bridgeMsg = document.createElement('div');
      bridgeMsg.className = 'bridge-message';
      bridgeMsg.innerHTML = `
        <div style="cursor: pointer;">
          This session has available spaces, but we're prioritising the waitlist. <strong>Don't worry‚Äîclick here to join the waitlist!</strong>
        </div>
      `;
      el.appendChild(bridgeMsg);
      bridgeMsg.addEventListener('click', (event) => {
        event.stopPropagation();
        document.getElementById('blockSlots').parentElement.querySelectorAll('.slot-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
        selectedSlot = slot;
        selectedDate = dateStr;
        showBookingForm(true);
        updateWaitlistCount();
      });
    }

// Toggle selection when clicking a block card; indicator reflects selected state
    el.onclick = () => {
      console.log('%c[STEP 2: SLOT SELECT]%c Clicked. inBridgeState=' + inBridgeState, 'color:#3b82f6;font-weight:bold;', 'color:inherit;');
      // Don't allow selection if in bridge state
      if (inBridgeState) {
        console.log(`    ‚Üí In bridge state, showing waitlist only`);
        document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
        el.classList.add('selected');
        selectedSlot = slot;
        selectedDate = dateStr;
        updateWaitlistCount();
        showBlockConfirmation(slot, true); // Always show block details in waitlist mode
        showBookingForm(true); // Show waitlist form only
        return;
      }
      
      const wasSelected = el.classList.contains('selected');
      document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
      if (!wasSelected) {
        el.classList.add('selected');
        selectedSlot = slot;
        // Always show block confirmation for block sessions
        showBlockConfirmation(slot, full);
        showBookingForm(full ? true : false);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','true');

        // Auto-scroll to show selected session and next step
        const blockDetails = document.getElementById('blockConfirmation');
        const formTarget = full ? document.getElementById('waitlistNote') : (blockDetails || document.getElementById('bookingForm'));
        formTarget?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      } else {
        // deselect
        selectedSlot = null;
        hideBlockConfirmation();
        showBookingForm(null);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','false');
      }
    };

    // Make the indicator itself keyboard + pointer interactive and mirror card click
    setTimeout(()=>{
      const ind = el.querySelector('.select-indicator');
      if (!ind) return;
      ind.addEventListener('click', (ev)=>{ ev.stopPropagation(); el.click(); });
      ind.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); el.click(); } });
    }, 0);

      // Check if this render is still current before appending
      if (renderVersion !== slotRenderVersion) {
        console.log('üü° Discarding block slot append for outdated render (v' + renderVersion + ', current v' + slotRenderVersion + ')');
        return;
      }

      // Append to blockSlots container (layout unified via CSS)
      document.getElementById('blockSlots').appendChild(el);
      return;
    }

    // SINGLE SLOT CARD ‚Äî render solo sessions (details panel removed; booking opens directly)
    const el = document.createElement('div');
    el.className = 'slot-card';
    let colorClass = 'slot-color-green';
    
    // Bridge State takes priority: grey out if in bridge mode
    const inBridgeState = slot.bridgeState === true;
    
    if (inBridgeState) {
      colorClass = 'bridge-state';
      console.log(`üåâ Single slot ${slot.title}: bridgeState=${inBridgeState} - showing grey`);
    } else if (full) {
      colorClass = 'slot-color-red';
      console.log(`üåâ Single slot ${slot.title}: full=${full} - showing red`);
    } else {
      console.log(`üåâ Single slot ${slot.title}: available - showing green`);
    }

    let priceVal = slot.price;
    if (typeof priceVal === 'string') {
      priceVal = parseFloat(priceVal);
    }
    const priceDisplay = priceVal ? `¬£${!isNaN(priceVal) ? priceVal.toFixed(2) : slot.price}` : '';
    const locationDisplay = slot.location ? slot.location : '';

    el.innerHTML = `
      <div class="slot-card-inner">
        <div class="single-slot-content">
          <div class="slot-header">
            <div class="slot-title-row">
              <span class="slot-title title-text">${slot.title}</span>
              ${spots === 1 ? ' <span class="pill session-type">Solo Session</span>' : ''}
              ${spots > 1 && !full ? `<span class="pill spots-pill">${Math.max(0, (spots - booked))} / ${spots} spots left</span>` : ''}
            </div>
            <div class="slot-actions">
              ${full ? '<span class="pill fully-booked-pill">Fully Booked</span>' : ''}
            </div>
          </div>
          <div class="slot-meta">
            <div class="slot-time">${slot.time}</div>
            ${priceDisplay || locationDisplay ? `<div class="slot-extra">${priceDisplay ? `<div class="price-row"><span class="meta-icon"><svg class="icon icon--price" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20.59 13.41L13.41 20.59a2 2 0 0 1-2.83 0L2 12l7.17-7.17a2 2 0 0 1 2.83 0L20.59 13.41z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/><circle cx="7.5" cy="7.5" r="1.5" fill="currentColor"/></svg></span><span class="price-text">${priceDisplay}</span></div>` : ''}${locationDisplay ? `<div class="location-row"><span class="meta-icon"><svg class="icon icon--location" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 21s7-4.5 7-10a7 7 0 1 0-14 0c0 5.5 7 10 7 10zM12 11a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg></span><span class="location-text">${locationDisplay}</span></div>` : ''}</div>` : ''}
          </div>
            <!-- selectable indicator for single session -->
            <div class="select-indicator" role="button" aria-pressed="false" tabindex="0" title="Select session"></div>
        </div>
      </div>
    `;

    el.classList.add(colorClass);

    // Add bridge state message if applicable
    if (inBridgeState) {
      console.log(`  ‚Üí Adding bridge message`);
      const bridgeMsg = document.createElement('div');
      bridgeMsg.className = 'bridge-message';
      bridgeMsg.innerHTML = `
        <div style="cursor: pointer;">
          This session has available spaces, but we're prioritising the waitlist. <strong>Don't worry‚Äîclick here to join the waitlist!</strong>
        </div>
      `;
      el.appendChild(bridgeMsg);
      bridgeMsg.addEventListener('click', (event) => {
        event.stopPropagation();
        document.querySelectorAll('.slot-card').forEach(c => c.classList.remove('selected'));
        el.classList.add('selected');
        selectedSlot = slot;
        selectedDate = dateStr;
        showBookingForm(true);
        updateWaitlistCount();
      });
    }

    // Toggle selection for single session cards (click card or indicator)
    el.onclick = () => {
      console.log(`  ‚Üí Clicked. inBridgeState=${inBridgeState}`);
      // Don't allow selection if in bridge state
      if (inBridgeState) {
        console.log(`    ‚Üí In bridge state, showing waitlist only`);
        document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
        el.classList.add('selected');
        selectedSlot = slot;
        selectedDate = dateStr;
        updateWaitlistCount();
        showBookingForm(true); // Show waitlist form only
        // Always scroll to waitlistNote or waitlistForm for fully booked
        const waitlistNote = document.getElementById('waitlistNote');
        const waitlistForm = document.getElementById('waitlistForm');
        (waitlistNote || waitlistForm)?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        return;
      }
      
      const wasSelected = el.classList.contains('selected');
      document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
      if (!wasSelected) {
        el.classList.add('selected');
        selectedSlot = slot;
        hideBlockConfirmation();
        showBookingForm(full ? true : false);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','true');

        // Auto-scroll to show selected session and next step
        if (full) {
          // For fully booked, always show waitlistNote or waitlistForm
          const waitlistNote = document.getElementById('waitlistNote');
          const waitlistForm = document.getElementById('waitlistForm');
          (waitlistNote || waitlistForm)?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
          const blockDetails = document.getElementById('blockConfirmation');
          const bookingForm = document.getElementById('bookingForm');
          (blockDetails || bookingForm)?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      } else {
        selectedSlot = null;
        hideBlockConfirmation();
        showBookingForm(null);
        el.querySelector('.select-indicator')?.setAttribute('aria-pressed','false');
      }
    };

    // Make the small indicator interactive and keyboard accessible
    setTimeout(()=>{
      const ind = el.querySelector('.select-indicator');
      if (!ind) return;
      ind.addEventListener('click', (ev)=>{ ev.stopPropagation(); el.click(); });
      ind.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); el.click(); } });
    }, 0);

    // Check if this render is still current before appending
    if (renderVersion !== slotRenderVersion) {
      console.log('üü° Discarding slot append for outdated render (v' + renderVersion + ', current v' + slotRenderVersion + ')');
      return;
    }

    document.getElementById('slots').appendChild(el);
  });
  
  // Auto-scroll to show calendar and availability section after slots render
  const slotsSection = document.querySelector('.available-slots');
  if (slotsSection) {
    slotsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
}

/* ================= NAV ================= */
// Safely advance the calendar by `delta` months without day-overflow bugs
// (e.g. Jan 31 + 1 month -> Mar 3). We normalise to the first of the target
// month which prevents accidental month-skips caused by Date overflow.
function advanceCalendarMonth(delta) {
  const y = currentDisplayDate.getFullYear();
  const m = currentDisplayDate.getMonth() + delta;
  // Set to first day of the target month to avoid overflow rolling into the following month
  currentDisplayDate = new Date(y, m, 1);
}

prevMonth.onclick = () => {
  advanceCalendarMonth(-1);
  buildCalendarSkeleton();
};
nextMonth.onclick = () => {
  advanceCalendarMonth(1);
  buildCalendarSkeleton();
};

/* ================= BLOCK CONFIRMATION ================= */
function showBlockConfirmation(slot, isWaitlist = false) {
    const checkbox = document.getElementById('blockCheckbox');
    // Remove any previous handler to avoid duplicates
    if (checkbox) checkbox.onchange = null;

    // In waitlist mode, show waitlist form only after checkbox is checked
    if (isWaitlist && checkbox) {
      const waitlistForm = document.getElementById('waitlistForm');
      waitlistForm.classList.add('hidden');
      waitlistForm.style.display = 'none';
      checkbox.onchange = (e) => {
        if (e.target.checked) {
          waitlistForm.classList.remove('hidden');
          waitlistForm.style.display = '';
          setTimeout(() => {
            waitlistForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }, 200);
        } else {
          waitlistForm.classList.add('hidden');
          waitlistForm.style.display = 'none';
        }
      };
    }
  const confirmEl = document.getElementById('blockConfirmation');
  const datesList = document.getElementById('blockDatesList');
  // Block session card fields
  const titleEl = document.getElementById('blockTitle');
  const spotsPill = document.getElementById('blockSpotsPill');
  const fullPill = document.getElementById('blockFullPill');
  const timeEl = document.getElementById('blockTime');
  const extraEl = document.getElementById('blockExtra');

  const blockDates = slot.blockDates || [];
  datesList.innerHTML = blockDates.map(d => `<li>${formatDateWithOrdinal(d)}</li>`).join('');
  function formatDateWithOrdinal(dateStr) {
    const [year, month, day] = dateStr.split('-');
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
      'July', 'August', 'September', 'October', 'November', 'December'];
    const dayNum = parseInt(day);
    let ord = 'th';
    if (dayNum % 10 === 1 && dayNum !== 11) ord = 'st';
    else if (dayNum % 10 === 2 && dayNum !== 12) ord = 'nd';
    else if (dayNum % 10 === 3 && dayNum !== 13) ord = 'rd';
    ord = ord.toLowerCase();
    const monthName = monthNames[parseInt(month) - 1];
    return `${dayNum}<sup>${ord}</sup> ${monthName} ${year}`;
  }
  checkbox.checked = false;

  // Populate card fields
  if (titleEl) titleEl.textContent = slot.title || '-';
  if (timeEl) timeEl.textContent = slot.time || '-';
  // Spots pill logic
  if (spotsPill) {
    if (slot.full) {
      spotsPill.style.display = 'none';
    } else {
      spotsPill.style.display = '';
      spotsPill.textContent = `${Math.max(0, (slot.spots - slot.booked))} / ${slot.spots} spots left`;
    }
  }
  if (fullPill) fullPill.style.display = slot.full ? '' : 'none';
  // Price/location
  let priceVal2 = slot.price;
  if (typeof priceVal2 === 'string') priceVal2 = parseFloat(priceVal2);
  const priceText = priceVal2 ? `¬£${!isNaN(priceVal2) ? priceVal2.toFixed(2) : slot.price}` : '';
  const locationText = slot.location || '';
  let extraHtml = '';
  if (priceText) {
    extraHtml += `<div class="price-row"><span class="meta-icon"><object data="bank.jpg" type="image/jpeg" class="icon icon--price"></object></span><span class="price-text">${priceText}</span></div>`;
  }
  if (locationText) {
    extraHtml += `<div class="location-row"><span class="meta-icon"><svg class="icon icon--location" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 21s7-4.5 7-10a7 7 0 1 0-14 0c0 5.5 7 10 7 10zM12 11a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/></svg></span><span class="location-text">${locationText}</span></div>`;
  }
  if (extraEl) extraEl.innerHTML = extraHtml;

  // Add red color scheme if waitlist mode
  if (isWaitlist) {
    confirmEl.classList.add('waitlist-mode');
  } else {
    confirmEl.classList.remove('waitlist-mode');
  }

  confirmEl.classList.remove('hidden');
} 
function hideBlockConfirmation() {
  const confirmEl = document.getElementById('blockConfirmation');
  const titleEl = document.getElementById('blockConfirmationTitle');
  confirmEl.classList.add('hidden');
  titleEl?.classList.add('hidden');
}


/* ================= FORM TOGGLE ================= */
function showBookingForm(isFullyBooked) {
  const bookingForm = document.getElementById('bookingForm');
  const waitlistForm = document.getElementById('waitlistForm');
  const waitlistNote = document.getElementById('waitlistNote');
  const waitlistConfirm = document.getElementById('waitlistConfirm');
  const regForm = document.getElementById('playerRegistrationForm');
  const regHostBooking = document.getElementById('playerRegistrationHostBooking');
  const regHostWaitlist = document.getElementById('playerRegistrationHostWaitlist');
  const blockCheckbox = document.getElementById('blockCheckbox');
  const titleEl = document.getElementById('playerRegistrationTitle');
  
  // If no session selected (both false/undefined), hide both forms
  if (isFullyBooked === null || isFullyBooked === undefined) {
    if (bookingForm) {
      bookingForm.classList.add('hidden');
      bookingForm.style.display = 'none';
    }
    if (waitlistForm) {
      waitlistForm.classList.add('hidden');
      waitlistForm.style.display = 'none';
    }
    if (waitlistNote) {
      waitlistNote.classList.add('hidden');
      waitlistNote.style.display = 'none';
    }
    if (waitlistConfirm) waitlistConfirm.checked = false;
    // Remove handler if present
    if (waitlistConfirm) waitlistConfirm.onchange = null;
    return;
  }
  
  if (isFullyBooked) {
    // Ensure the normal booking form is hidden (both class and inline styles)
    if (bookingForm) {
      bookingForm.classList.add('hidden');
      bookingForm.style.display = 'none';
    }
    if (titleEl) titleEl.classList.add('hidden');
    if (regForm) regForm.classList.add('hidden');

    // Show waitlist note, but keep waitlist form hidden until checkbox is checked
    if (waitlistForm) {
      waitlistForm.classList.add('hidden');
      waitlistForm.style.display = 'none';
    }
    if (waitlistNote) {
      waitlistNote.classList.remove('hidden');
      waitlistNote.style.display = '';
    }
    if (waitlistConfirm) waitlistConfirm.checked = false;
    // Assign waitlist checkbox handler only when form is shown
    if (waitlistConfirm) {
      waitlistConfirm.onchange = (e) => {
        const waitlistForm = document.getElementById('waitlistForm');
        if (waitlistForm && e.target.checked) {
          waitlistForm.classList.remove('hidden');
          waitlistForm.style.display = '';
          setTimeout(() => {
            waitlistForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }, 200);
          if (window.selectedSlot && window.selectedSlot.blockId) {
            showBlockConfirmation(window.selectedSlot, true);
            const blockDetails = document.getElementById('blockConfirmation');
            blockDetails?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        } else if (waitlistForm) {
          waitlistForm.classList.add('hidden');
          waitlistForm.style.display = 'none';
          hideBlockConfirmation();
        }
      };
    }
    updateWaitlistCount();

    // Move registration form into waitlist form container
    if (regForm && regHostWaitlist && regForm.parentElement !== regHostWaitlist) {
      regHostWaitlist.appendChild(regForm);
    }
  } else {
    // Check if this is a block session
    if (selectedSlot && selectedSlot.blockId) {
      // For block sessions: hide booking form until checkbox is checked
      bookingForm.classList.add('hidden');
      bookingForm.style.display = 'none';
      titleEl?.classList.add('hidden');
      regForm?.classList.add('hidden');
      blockCheckbox.checked = false;
    } else {
      // For regular single sessions: show booking form immediately
      bookingForm.classList.remove('hidden');
      bookingForm.style.display = '';
      // Move registration form back into booking form container
      if (regForm && regHostBooking && regForm.parentElement !== regHostBooking) {
        regHostBooking.appendChild(regForm);
      }
    }

    // Hide waitlist form (both class and inline)
    waitlistForm.classList.add('hidden');
    waitlistForm.style.display = 'none';
    waitlistNote.classList.add('hidden');
    waitlistNote.style.display = 'none';
    if (waitlistConfirm) waitlistConfirm.checked = false;
    // Remove handler if present
    if (waitlistConfirm) waitlistConfirm.onchange = null;
  }
}

/* ================= PAYMENT INSTRUCTIONS ================= */
function generatePaymentReference() {
  // Generate reference: FULLNAME-SESSIONNAME
  // This will be set when showPaymentInstructions is called with actual data
  return null; // Will be set dynamically
}

function showPaymentInstructions(slot, name, email, date, bookingId) {
  console.log('%c[STEP 6: PAYMENT INSTRUCTIONS]%c', 'color:#10b981;font-weight:bold;', 'color:inherit;', { slot, name, email, date, bookingId });
  console.log('üîµ BookingId received:', bookingId);
  const modal = document.getElementById('paymentModal');
  console.log('üü† Modal element:', modal, 'Has hidden class:', modal.classList.contains('hidden'));
  
  // Store bookingId globally for email sending
  currentBookingId = bookingId;
  console.log('üîµ currentBookingId set to:', currentBookingId);
  
  // Generate payment reference in format: FULLNAME-SESSIONNAME
  const fullName = name.toUpperCase().replace(/\s+/g, '');
  const sessionName = slot.title.toUpperCase().replace(/\s+/g, '');
  const paymentRef = `${fullName}-${sessionName}`;
  
  // Calculate deadline (24 hours from now)
  const deadline = new Date();
  deadline.setHours(deadline.getHours() + 24);
  const deadlineStr = deadline.toLocaleString('en-GB', { 
    weekday: 'short',
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
  
  // Format date for display
  const dateDisplay = formatDateForDisplay(date);
  
  // Get price (default to ¬£25 if not specified)
  let priceVal3 = slot.price;
  if (typeof priceVal3 === 'string') priceVal3 = parseFloat(priceVal3);
  const price = priceVal3 ? `¬£${!isNaN(priceVal3) ? priceVal3.toFixed(2) : slot.price}` : '¬£25.00';
  
  // Populate payment details
  document.getElementById('paymentDate').textContent = dateDisplay;
  document.getElementById('paymentTime').textContent = slot.time;
  document.getElementById('paymentTitle').textContent = slot.title;
  document.getElementById('paymentPrice').textContent = price;
  document.getElementById('paymentReference').textContent = paymentRef;
  document.getElementById('paymentDeadline').textContent = deadlineStr;
  document.getElementById('accountNumber').textContent = BANK_DETAILS.accountNumber;
  document.getElementById('sortCode').textContent = BANK_DETAILS.sortCode;
  
  // Store booking data for cancellation
  currentBookingData = {
    slot: slot,
    name: name,
    email: email,
    date: date,
    paymentRef: paymentRef,
    deadline: deadline,
    isBlock: !!slot.blockId,
    blockDates: slot.blockDates
  };
  
  // Show modal (using same approach as user guide modal)
  console.log('üü† About to show modal - before removal. Classes:', modal.className);
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  console.log('üü† After removing hidden class:', modal.className);
  
  // Add body class to prevent iOS zoom
  document.body.classList.add('modal-open-payment');
  
  // Ensure the modal content is scrolled to top
  const modalContent = modal.querySelector('.payment-modal-content');
  if (modalContent) {
    modalContent.scrollTop = 0;
  }

  // Hide the booking form
  const bookingForm = document.getElementById('bookingForm');
  if (bookingForm) bookingForm.style.display = 'none';
}

function hidePaymentInstructions() {
  const modal = document.getElementById('paymentModal');
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  
  // Remove body class
  document.body.classList.remove('modal-open-payment');
  
  // Show the booking form
  const bookingForm = document.getElementById('bookingForm');
  if (bookingForm) bookingForm.style.display = 'block';

  // Remove any dynamic viewport listeners
  const modalContent = modal.querySelector('.payment-modal-content');
  if (modalContent && modalContent._vcResizeHandler) {
    if (window.visualViewport) window.visualViewport.removeEventListener('resize', modalContent._vcResizeHandler);
    window.removeEventListener('orientationchange', modalContent._vcResizeHandler);
    delete modalContent._vcResizeHandler;
  }
  
  currentBookingData = null;
}

function showWaitlistConfirmationModal(position) {
  const modal = document.getElementById('waitlistConfirmationModal');
  const positionEl = document.getElementById('waitlistPositionValue');
  if (!modal || !positionEl) return;

  positionEl.textContent = position || '-';
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  document.body.classList.add('modal-open-payment');

  const content = modal.querySelector('.payment-modal-content');
  if (content) content.scrollTop = 0;
}

function hideWaitlistConfirmationModal() {
  const modal = document.getElementById('waitlistConfirmationModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('modal-open-payment');
}

function showWaitlistEmailConflictModal() {
  const modal = document.getElementById('waitlistEmailConflictModal');
  if (!modal) return;
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  document.body.classList.add('modal-open-payment');
  const content = modal.querySelector('.payment-modal-content');
  if (content) content.scrollTop = 0;
    setTimeout(function() {
      const nameField = document.getElementById('waitlistName');
      if (nameField) {
        nameField.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _waitlistConflictModalActive = true;
}

function hideWaitlistEmailConflictModal() {
  const modal = document.getElementById('waitlistEmailConflictModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('modal-open-payment');
    setTimeout(function() {
      const formSection = document.getElementById('waitlistForm');
      if (formSection) {
        formSection.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _waitlistConflictModalActive = false;
}

function showWaitlistNameConflictModal() {
  const modal = document.getElementById('waitlistNameConflictModal');
  if (!modal) return;
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  document.body.classList.add('modal-open-payment');
  const content = modal.querySelector('.payment-modal-content');
  if (content) content.scrollTop = 0;
    setTimeout(function() {
      const nameField = document.getElementById('waitlistName');
      if (nameField) {
        nameField.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _waitlistConflictModalActive = true;
}

function hideWaitlistNameConflictModal() {
  const modal = document.getElementById('waitlistNameConflictModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('modal-open-payment');
    setTimeout(function() {
      const formSection = document.getElementById('waitlistForm');
      if (formSection) {
        formSection.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _waitlistConflictModalActive = false;
}

function showBookingEmailConflictModal() {
  const modal = document.getElementById('bookingEmailConflictModal');
  if (!modal) return;
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  document.body.classList.add('modal-open-payment');
  const content = modal.querySelector('.payment-modal-content');
  if (content) content.scrollTop = 0;
    setTimeout(function() {
      const nameField = document.getElementById('name');
      if (nameField) {
        nameField.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _bookingConflictModalActive = true;
}

function hideBookingEmailConflictModal() {
  const modal = document.getElementById('bookingEmailConflictModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('modal-open-payment');
    setTimeout(function() {
      const formSection = document.getElementById('bookingForm');
      if (formSection) {
        formSection.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _bookingConflictModalActive = false;
}

function showBookingNameConflictModal() {
  const modal = document.getElementById('bookingNameConflictModal');
  if (!modal) return;
  modal.classList.remove('hidden');
  modal.setAttribute('aria-hidden', 'false');
  document.body.classList.add('modal-open-payment');
  const content = modal.querySelector('.payment-modal-content');
  if (content) content.scrollTop = 0;
    setTimeout(function() {
      const nameField = document.getElementById('name');
      if (nameField) {
        nameField.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _bookingConflictModalActive = true;
}

function hideBookingNameConflictModal() {
  const modal = document.getElementById('bookingNameConflictModal');
  if (!modal) return;
  modal.classList.add('hidden');
  modal.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('modal-open-payment');
    setTimeout(function() {
      const formSection = document.getElementById('bookingForm');
      if (formSection) {
        formSection.scrollIntoView({behavior: 'smooth', block: 'center'});
      }
    }, 200);
    _bookingConflictModalActive = false;
}

function copyToClipboard(element, btnElement) {
  const text = element.textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = btnElement;
    const originalHTML = btn.innerHTML;
    
    // Show success state
    btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>';
    btn.style.background = '#10b981';
    
    // Revert after 2 seconds
    setTimeout(() => {
      btn.innerHTML = originalHTML;
      btn.style.background = '';
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
  });
}

/* ================= PAYMENT EMAIL ================= */
async function sendReservationEmail() {
  if (!currentBookingData) {
    console.error('sendReservationEmail: No currentBookingData');
    showBookingMessage('Error: Could not send email. Please try again.', 'error');
    return false;
  }
  
  // Calculate deadline (24 hours from now)
  const deadline = new Date();
  deadline.setHours(deadline.getHours() + 24);
  const deadlineStr = deadline.toLocaleString('en-GB', { 
    weekday: 'short',
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
  
  const emailPayload = {
    type: 'temporary_reservation',
    email: currentBookingData.email,
    name: currentBookingData.name,
    slot: currentBookingData.slot.time,
    title: currentBookingData.slot.title,
    date: currentBookingData.date,
    blockDates: currentBookingData.blockDates || [],
    paymentRef: currentBookingData.paymentRef,
    deadline: deadlineStr,
    price: currentBookingData.slot.price || '25.00',
    location: currentBookingData.slot.location || 'Hoop Theory',
    bookingId: currentBookingId || ''
  };
  
  console.log('Sending reservation email with payload:', emailPayload);
  console.log('üîµ Current Booking ID:', currentBookingId);
  console.log('üîµ Price:', currentBookingData.slot.price);
  console.log('üîµ Location:', currentBookingData.slot.location);
  
  try {
    const response = await fetch(PHP_PATH + 'sendEmail.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(emailPayload)
    });
    
    const responseText = await response.text();
    console.log('Email API response status:', response.status);
    console.log('Email API response text:', responseText);
    let result = null;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      console.error('‚úó Email response not valid JSON:', e);
      showBookingMessage('Email response error. Please contact support.', 'error');
      return false;
    }
    if (response.ok && result && result.success) {
      console.log('‚úì Reservation email sent successfully');
      return true;
    } else {
      console.error('‚úó Email send failed - HTTP ' + response.status + ' - ' + (result && result.error ? result.error : 'Unknown error'));
      showBookingMessage('Email could not be sent. Please contact support.', 'error');
      return false;
    }
  } catch (error) {
    console.error('‚úó Email send error:', error);
    showBookingMessage('Error sending email. Please try again.', 'error');
    return false;
  }
}

async function sendWaitlistConfirmationEmail(payload) {
  if (!payload) return false;
  const emailPayload = {
    type: 'waitlist_confirmation',
    email: payload.email,
    name: payload.name,
    slot: payload.slot?.time || '',
    title: payload.slot?.title || '',
    date: payload.date || '',
    blockDates: payload.slot?.blockDates || [],
    waitlistPosition: payload.waitlistPosition || '',
    price: payload.slot?.price || '25.00',
    location: payload.slot?.location || 'Hoop Theory'
  };

  try {
    const response = await fetch(PHP_PATH + 'sendEmail.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(emailPayload)
    });

    const responseText = await response.text();
    console.log('Waitlist email response status:', response.status);
    console.log('Waitlist email response text:', responseText);
    return response.ok;
  } catch (error) {
    console.error('Waitlist email send error:', error);
    return false;
  }
}

/* ================= BOOKING ================= */
async function saveBooking(slot, name, email) {
  const payload = {
    name: name,
    email: email,
    date: selectedDate,
    slot: {
      title: slot.title,
      time: slot.time,
      price: slot.price,
      location: slot.location
    }
  };
  console.log('%c[STEP 5: BOOKING SAVE]%c', 'color:#6366f1;font-weight:bold;', 'color:inherit;', payload);
  const response = await fetch(PHP_PATH + 'saveBookings.php', {
    method: 'POST',
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    console.error('saveBooking HTTP error:', response.status);
    throw new Error('HTTP ' + response.status);
  }
  const result = await response.json();
  if (result.status === 'error' && result.message && result.message.includes('expired')) {
    showBookingMessage('Booking expired or removed. Please try again.', 'error');
    throw new Error('Booking expired or removed');
  }
  console.log('saveBooking response:', result);
  console.log('üî¥ saveBooking returned bookingId:', result.bookingId);
  return result;
}

async function saveBlockBooking(slot, name, email) {
  const payload = {
    name: name,
    email: email,
    blockId: slot.blockId,
    blockDates: slot.blockDates,
    slot: {
      title: slot.title,
      time: slot.time,
      price: slot.price,
      location: slot.location
    }
  };
  console.log('%c[STEP 5: BLOCK BOOKING SAVE]%c', 'color:#6366f1;font-weight:bold;', 'color:inherit;', payload);
  const response = await fetch(PHP_PATH + 'saveBookings.php', {
    method: 'POST',
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    console.error('saveBlockBooking HTTP error:', response.status);
    throw new Error('HTTP ' + response.status);
  }
  const result = await response.json();
  console.log('saveBlockBooking response:', result);
  return result;
}

// Helper: check if player is registered (calls backend)
async function checkPlayerRegistered(name, email) {
  try {
    console.log('Calling backend isPlayerRegistered for:', name, email);
    const res = await fetch(PHP_PATH + 'isPlayerRegistered.php', {
      method: 'POST',
      body: JSON.stringify({ name, email })
    });
    if (!res.ok) {
      console.log('isPlayerRegistered: non-OK response');
      return false;
    }
    const j = await res.json();
    console.log('Backend isPlayerRegistered result:', j);
    return j;
  } catch (e) {
    console.error('Player registration check failed', e);
    return { registered: false };
  }
}

function showPlayerRegistration(prefill={}, isWaitlistOnly=false){
    console.log('%c[STEP 4: REGISTRATION FORM]%c Shown for ' + (prefill.name || '') + ', ' + (prefill.email || ''), 'color:#ef4444;font-weight:bold;', 'color:inherit;');
  // Cancel other checks so they won't accidentally hide the form while we show it
  _registrationCheckId++;

  // Only show booking form if not in waitlist-only mode
  if (!isWaitlistOnly) {
    // Ensure booking form container is visible so registration form can be seen
    const bookingForm = document.getElementById('bookingForm');
    if (bookingForm) {
      bookingForm.classList.remove('hidden');
      bookingForm.style.display = '';
    }
  }

  const form = document.getElementById('playerRegistrationForm');
  const titleEl = document.getElementById('playerRegistrationTitle');
  form.classList.remove('hidden');
  titleEl?.classList.remove('hidden');
  // ensure animated class toggle for smooth transition - don't scroll or force focus
  requestAnimationFrame(() => {
    form.classList.add('visible');
  });

  document.getElementById('bookBtn').disabled = false;
  console.log('Player registration form shown for', prefill.name || '', prefill.email || '');
  // store a snapshot of the booking so we can continue reliably even if selectedSlot changes
  pendingBooking = { slot: selectedSlot, date: selectedDate, name: prefill.name || '', email: prefill.email || '' };
  console.log('Pending booking saved:', pendingBooking);
  // populate name/email from booking form
  if (prefill.name) document.getElementById('name').value = prefill.name;
  if (prefill.email) document.getElementById('email').value = prefill.email;
  
  // Update welcome message with player name
  const welcomeMsg = document.getElementById('registrationWelcomeMessage');
  if (welcomeMsg && prefill.name) {
    welcomeMsg.textContent = `Welcome ${prefill.name}. Please complete this mandatory form to help us manage your booking and ensure your safety.`;
  }
  
  // copy booking inputs into form where relevant
  document.getElementById('player_age').value = prefill.age || '';
  document.getElementById('player_experience').value = prefill.experience || '';
  document.getElementById('player_medical').value = prefill.medical || '';
  document.getElementById('emergency_name').value = prefill.emergency?.name || '';
  document.getElementById('emergency_phone').value = prefill.emergency?.phone || '';
  document.getElementById('emergency_relationship').value = prefill.emergency?.relationship || '';

  // Update consent/waiver text with player name if available
  const playerName = prefill.name || document.getElementById('name').value.trim() || '[Player Name]';
  const consentLabel = document.getElementById('media_consent_label');
  const waiverLabel = document.getElementById('waiver_label');
  if (consentLabel) consentLabel.textContent = `I, the parent/guardian of ${playerName}, grant permission for Hoop Theory to use photos and videos taken during sessions for promotional purposes, including social media and marketing materials.`;
  if (waiverLabel) waiverLabel.textContent = `I, the parent/guardian of ${playerName}, agree to allow my child to participate in Hoop Theory sessions, understand the inherent risks of sports, and waive any claims against Hoop Theory for injuries incurred.`;
}
function hidePlayerRegistration(immediate = false){
  const form = document.getElementById('playerRegistrationForm');
  const titleEl = document.getElementById('playerRegistrationTitle');
  if (!form) {
    console.warn('‚ö†Ô∏è playerRegistrationForm element not found');
    return;
  }
  // Cancel in-flight checks
  _registrationCheckId++;
  // remove visible class to trigger animation
  form.classList.remove('visible');
  // if immediate is requested, hide instantly
  if (immediate) {
    form.classList.add('hidden');
    titleEl?.classList.add('hidden');
  } else {
    // after transition completes, add hidden to remove from flow
    setTimeout(() => {
      form.classList.add('hidden');
      titleEl?.classList.add('hidden');
    }, 220);
  }
  const playerFormError = document.getElementById('playerFormError');
  if (playerFormError) playerFormError.classList.add('hidden');
  document.getElementById('bookBtn').disabled = false;
  console.log('Player registration form hidden');
  // clear pending booking snapshot if the user cancelled
  pendingBooking = null;
}

function showPlayerFormError(msg){
  const el = document.getElementById('playerRegistrationErrorBanner');
  if (!el) return;
  el.textContent = msg;
  el.classList.remove('hidden');
  setTimeout(() => {
    el.scrollIntoView({behavior: 'smooth', block: 'center'});
  }, 50);
}

function collectRegistrationData(){
  const email = document.getElementById('email').value.trim();
  const name = document.getElementById('name').value.trim();
  const age = document.getElementById('player_age').value;
  const experience = document.getElementById('player_experience').value;
  const medical = document.getElementById('player_medical').value.trim();
  const emergency = {
    name: document.getElementById('emergency_name').value.trim(),
    phone: document.getElementById('emergency_phone').value.trim(),
    relationship: document.getElementById('emergency_relationship').value.trim()
  };
  const mediaConsent = !!document.getElementById('media_consent').checked;
  const waiverAck = !!document.getElementById('waiver_ack').checked;
  const mediaText = document.getElementById('media_consent_label')?.textContent || '';
  const waiverText = document.getElementById('waiver_label')?.textContent || '';

  return {
    name, email, age, experience, medical, emergency,
    media_consent: mediaConsent, media_consent_text: mediaText,
    waiver_acknowledged: waiverAck, waiver_text: waiverText,
    registration_complete: true
  };
}

function validateRegistration(profile){
  const errors = [];
  if (!profile.name) errors.push('Name is required');
  if (!profile.email || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(profile.email)) errors.push('Valid email is required');
  if (profile.age === '' || profile.age === null || profile.age === undefined) errors.push('Age is required');
  else if (isNaN(parseInt(profile.age)) || parseInt(profile.age) < 0) errors.push('Age must be a non-negative number');
  const allowed = ['No experience','Beginner','Regular player but no team','Local league','National league'];
  if (!allowed.includes(profile.experience)) errors.push('Playing experience is required');
  if (!profile.medical) errors.push('Medical information is required');
  if (!profile.emergency || !profile.emergency.name) errors.push('Emergency contact name is required');
  if (!profile.emergency || !profile.emergency.phone) {
    errors.push('Emergency contact phone is required');
  } else {
    // Phone validation: at least 8 digits, max 15, allow numbers, spaces, dashes, parentheses, plus
    const phone = profile.emergency.phone;
    const digits = phone.replace(/\D/g, '');
    if (digits.length < 8 || !/^[- +()0-9]+$/.test(phone)) {
      errors.push('Enter a valid phone number (at least 8 digits)');
    } else if (digits.length > 15) {
      errors.push('Phone number is too long (max 15 digits)');
    }
  }
  if (!profile.emergency || !profile.emergency.relationship) errors.push('Emergency contact relationship is required');
  if (!profile.media_consent) errors.push('Media consent must be accepted');
  if (!profile.waiver_acknowledged) errors.push('Waiver must be acknowledged');
  return errors;
}

async function submitRegistrationAndContinue(){
  const profile = collectRegistrationData();
  const alreadyFilled = document.getElementById('already_filled_registration')?.checked;
  if (alreadyFilled) {
    console.log('Already filled registration checkbox is checked ‚Äî proceeding without saving');
    if (!confirm('You indicated you have already filled out registration elsewhere. Proceed without saving?')) return false;
    hidePlayerRegistration();
    return true; // caller should continue booking
  }

  const errs = validateRegistration(profile);
  if (errs.length > 0) {
    showPlayerFormError(errs.join('; '));
    return false;
  }

  try {
    console.log('üîµ ===== STARTING PROFILE SAVE =====');
    console.log('üîµ Profile data to save:', JSON.stringify(profile, null, 2));
    console.log('üîµ Sending POST to:', PHP_PATH + 'savePlayerProfile.php');
    
    const res = await fetch(PHP_PATH + 'savePlayerProfile.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(profile)
    });
    
    console.log('üîµ Response status:', res.status, res.statusText);
    const raw = await res.text();
    console.log('üîµ Raw response:', raw);
    
    let j = null;
    try {
      j = raw ? JSON.parse(raw) : null;
    } catch (parseErr) {
      console.error('‚ùå savePlayerProfile: invalid JSON response', raw);
      showPlayerFormError('Failed to save profile (invalid server response)');
      return false;
    }
    
    console.log('üîµ Parsed response:', j);
    
    if (!res.ok || !j || !j.success) {
      console.error('‚ùå savePlayerProfile failed:', { status: res.status, response: j });
      showPlayerFormError((j && j.errors ? j.errors : ['Failed to save profile']).join('; '));
      return false;
    }
    
    console.log('‚úÖ Backend confirmed profile save SUCCESS');
    console.log('‚úÖ Saved profile:', JSON.stringify(j.profile, null, 2));
    
    // Verify it persisted
    try {
      const verifyUrl = PHP_PATH + 'getPlayers.php?email=' + encodeURIComponent(profile.email) + '&t=' + Date.now();
      console.log('üîµ Verifying with:', verifyUrl);
      
      const verifyRes = await fetch(verifyUrl);
      console.log('üîµ Verify response status:', verifyRes.status);
      
      if (!verifyRes.ok) {
        console.warn('‚ö†Ô∏è Verification returned non-OK status:', verifyRes.status);
      }
      
      const verifyProfile = await verifyRes.json();
      console.log('üîµ Verification result:', JSON.stringify(verifyProfile, null, 2));
      
      if (!verifyProfile || (!verifyProfile.email && !verifyProfile.name)) {
        console.error('‚ùå Profile verification failed: missing profile', verifyProfile);
        showPlayerFormError('Profile was not saved. Please try again.');
        return false;
      }
      
      console.log('‚úÖ PROFILE VERIFIED IN DATABASE');
    } catch (verifyErr) {
      console.error('‚ùå Profile verification error', verifyErr);
      showPlayerFormError('Profile saved but verification failed. Please try again.');
      return false;
    }

    console.log('‚úÖ‚úÖ‚úÖ PROFILE SAVED SUCCESSFULLY FOR:', profile.name, '(' + profile.email + ')');
    console.log('üîµ ===== PROFILE SAVE COMPLETE =====');
    hidePlayerRegistration();
    return true;
  } catch (e) {
    console.error('Save player profile failed', e);
    showPlayerFormError('Failed to save profile');
    return false;
  }
}


// Save Player Registration button handler removed - logic integrated into Reserve Booking button
/*
document.getElementById('savePlayerRegistrationBtn').onclick = async (e) => {
  e.preventDefault();
  const profile = collectRegistrationData();
  // Remove previous error highlights and asterisks
  clearRegistrationFieldErrors();
  const errs = validateRegistration(profile);
  if (errs.length > 0) {
    showRegistrationFieldErrors(profile);
    // No error message: only visual indicators
    return;
  }
  // Print profile JSON to console as required
  try {
    console.log('Profile JSON to save:', JSON.stringify(profile, null, 2));
  } catch (e) {
    console.log('Profile object:', profile);
  }

  const ok = await submitRegistrationAndContinue();
  if (ok) {
    // proceed with pending booking
    proceedWithBookingAfterProfile();
  }
};
*/

// Helper: clear previous error highlights and asterisks
function clearRegistrationFieldErrors() {
  const labelIds = [
    'nameLabel', 'emailLabel', 'ageLabel', 'experienceLabel', 'medicalLabel',
    'emergencyNameLabel', 'emergencyPhoneLabel', 'emergencyRelationshipLabel'
  ];
  labelIds.forEach(id => {
    const label = document.getElementById(id);
    if (label) {
      // Remove only .asterisk spans, do not touch other HTML
      label.querySelectorAll('.asterisk').forEach(el => el.remove());
      label.classList.remove('field-error');
    }
  });
  const fieldIds = [
    'name', 'email', 'player_age', 'player_experience', 'player_medical',
    'emergency_name', 'emergency_phone', 'emergency_relationship'
  ];
  fieldIds.forEach(id => {
    const field = document.getElementById(id);
    if (field) field.classList.remove('field-error');
  });
}

// Helper: show asterisks and highlight missing required fields
function showRegistrationFieldErrors(profile) {
  // Name
  if (!profile.name) markFieldError('nameLabel', 'name');
  // Email
  if (!profile.email || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(profile.email)) markFieldError('emailLabel', 'email');
  // Age
  if (profile.age === '' || profile.age === null || profile.age === undefined || isNaN(parseInt(profile.age)) || parseInt(profile.age) < 0) markFieldError('ageLabel', 'player_age');
  // Experience
  const allowed = ['No experience','Beginner','Regular player but no team','Local league','National league'];
  if (!allowed.includes(profile.experience)) markFieldError('experienceLabel', 'player_experience');
  // Medical
  if (!profile.medical) markFieldError('medicalLabel', 'player_medical');
  // Emergency contact
  if (!profile.emergency || !profile.emergency.name) markFieldError('emergencyNameLabel', 'emergency_name');
  if (!profile.emergency || !profile.emergency.phone) {
    markFieldError('emergencyPhoneLabel', 'emergency_phone');
  } else {
    // Simple phone validation: at least 8 digits, allow numbers, spaces, dashes, parentheses, plus
    const phone = profile.emergency.phone;
    const digits = phone.replace(/\D/g, '');
    if (digits.length < 8 || !/^[- +()0-9]+$/.test(phone)) {
      markFieldError('emergencyPhoneLabel', 'emergency_phone');
    }
  }
  if (!profile.emergency || !profile.emergency.relationship) markFieldError('emergencyRelationshipLabel', 'emergency_relationship');
}

function markFieldError(labelId, fieldId) {
  const label = document.getElementById(labelId);
  if (label) {
    let asterisk = label.querySelector('.asterisk');
    if (!asterisk) {
      asterisk = document.createElement('span');
      asterisk.className = 'asterisk';
      asterisk.textContent = ' *';
      label.appendChild(asterisk);
    }
    // Always re-trigger the animation
    asterisk.classList.remove('asterisk-pop');
    void asterisk.offsetWidth;
    asterisk.classList.add('asterisk-pop');
    label.classList.add('field-error');
  }
  const field = document.getElementById(fieldId);
  if (field) field.classList.add('field-error');
}

// Field-change logging and booking-area checkbox handling
const fieldIds = ['player_age','player_experience','player_medical','emergency_name','emergency_phone','emergency_relationship','media_consent','waiver_ack','already_filled_registration'];
fieldIds.forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  const ev = (el.tagName === 'INPUT' && el.type === 'checkbox') || el.tagName === 'SELECT' ? 'change' : 'input';
  el.addEventListener(ev, (e) => {
    const val = (el.type === 'checkbox') ? el.checked : el.value;
    console.log('Field changed:', id, val);
    // special handling for the booking-area already-filled checkbox
    if (id === 'already_filled_registration') {
      console.log('Already filled checkbox checked/unchecked');
      if (val) {
        console.log('Already filled registration checkbox checked - hiding registration form');
        hidePlayerRegistration(true);
      } else {
        console.log('Already filled registration checkbox unchecked - no-op');
      }
    }
  });
});

// cancel handler (if user opened the form and changed their mind)
const cancelBtn = document.getElementById('cancelPlayerBtn');
if (cancelBtn) cancelBtn.onclick = (e) => { e.preventDefault(); console.log('Cancel Player Registration clicked'); hidePlayerRegistration(); };


// Centralized continuation after profile saved or skip
async function proceedWithBookingAfterProfile(){
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();

  // prefer the live selectedSlot but fall back to the snapshot saved when the form was shown
  const slotToUse = selectedSlot || (pendingBooking && pendingBooking.slot) || null;
  const dateToUse = selectedDate || (pendingBooking && pendingBooking.date) || null;

  if (!slotToUse) {
    console.warn('No session selected while trying to continue booking after registration');
    showBookingMessage('No session selected. Please re-select a session to continue booking.', 'error');
    return;
  }

  try {
    console.log('Proceeding with booking after profile. slot:', slotToUse, 'date:', dateToUse, 'name:', name, 'email:', email);

    let bookingResult;
    if (slotToUse.blockId) {
      bookingResult = await saveBlockBooking(slotToUse, name, email);
    } else {
      bookingResult = await saveBooking(slotToUse, name, email);
    }

    // Capture bookingId from response
    const bookingId = bookingResult && bookingResult.bookingId ? bookingResult.bookingId : null;

    showPaymentInstructions(slotToUse, name, email, dateToUse, bookingId);

    // Clear pending booking now that booking is created
    pendingBooking = null;
  } catch (err) {
    console.error('Booking after profile failed', err);
    showBookingMessage('Error confirming booking. Please try again.', 'error');
  }
}

// Debounce helper and live registration checking
const debounce = (fn, wait = 600) => {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
};

const handleNameEmailChange = debounce(async () => {
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();
  console.log('%c[STEP 3: NAME/EMAIL ENTRY]%c ' + name + ', ' + email, 'color:#f59e0b;font-weight:bold;', 'color:inherit;');
  const note = document.getElementById('playerCheckNote');
  const emailConflictBanner = document.getElementById('emailConflictBanner');
  const nameConflictBanner = document.getElementById('nameConflictBanner');
  const duplicateBookingBanner = document.getElementById('duplicateBookingBanner');
  const bookBtn = document.getElementById('bookBtn');

  // Hide form if inputs incomplete or invalid
  const emailValid = /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email);
  if (!name || !email || !emailValid) {
    // Cancel any in-flight checks
    _registrationCheckId++;
    hidePlayerRegistration(true);
    emailConflictBanner?.classList.add('hidden');
    nameConflictBanner?.classList.add('hidden');
    duplicateBookingBanner?.classList.add('hidden');
    hideBookingEmailConflictModal();
    hideBookingNameConflictModal();
    if (bookBtn) bookBtn.disabled = false;
    _bookingNameConflictConfirmed = false;
    _bookingEmailConflictConfirmed = false;
    _lastCheckedName = '';
    _lastCheckedEmail = '';
    return;
  }

  // Reset confirmation flag if name or email changed
  if (name !== _lastCheckedName || email !== _lastCheckedEmail) {
    _bookingNameConflictConfirmed = false;
    _bookingEmailConflictConfirmed = false;
    _lastCheckedName = name;
    _lastCheckedEmail = email;
  }

  // Start a new check token
  const checkId = ++_registrationCheckId;

  // Show checking note (no-op if note element missing)
  note?.classList.remove('hidden');
  console.log('Checking profile for:', name, email, ' (checkId=', checkId, ')');

  try {
    const checkResult = await checkPlayerRegistered(name, email);
    // If another check started since we began, ignore this result
    if (checkId !== _registrationCheckId) {
      console.log('Stale registration check result ignored (checkId', checkId, 'current', _registrationCheckId, ')');
      return;
    }

    console.log('Checking profile for:', name, email, 'found:', !!checkResult.registered);

    // Log if name exists with different email
    // Check for duplicate by both name and email
    const nameEmailMatch = checkResult.nameExists && checkResult.emailExists && existingName === inputName && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() === email.toLowerCase();
    if (nameEmailMatch) {
      console.debug('[DUPLICATE CHECK] Player with this name and email already exists:', name, email);
    } else if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      console.warn('‚ö†Ô∏è Name "' + name + '" already exists with a different email:', checkResult.existingEmail);
    }

    // Check if player is already booked on this session
    console.log('Checking for duplicate booking - email:', email, 'date:', selectedDate, 'slot:', selectedSlot);
    if (checkResult.registered && selectedSlot && selectedDate) {
      const alreadyBooked = await isPlayerAlreadyBooked(email, selectedDate, selectedSlot);
      console.log('Duplicate booking check result:', alreadyBooked);
      if (alreadyBooked) {
        console.warn('Player profile already booked onto session');
        note?.classList.add('hidden');
        duplicateBookingBanner?.classList.remove('hidden');
        emailConflictBanner?.classList.add('hidden');
        nameConflictBanner?.classList.add('hidden');
        hidePlayerRegistration(true);
        if (bookBtn) bookBtn.disabled = true;
        return;
      }
    }
    duplicateBookingBanner?.classList.add('hidden');

    note?.classList.add('hidden');

    const existingName = (checkResult.existingName || '').trim().toLowerCase();
    const inputName = name.trim().toLowerCase();

    if (checkResult.registered) {
      // Email + name match - hide registration form
      hidePlayerRegistration(true);
      emailConflictBanner?.classList.add('hidden');
      nameConflictBanner?.classList.add('hidden');
      hideBookingEmailConflictModal();
      hideBookingNameConflictModal();
      if (bookBtn) bookBtn.disabled = false;
    }
    if (checkResult.emailExists && existingName && existingName !== inputName) {
      // Email exists but with different name - show error banner, hide form, and disable submit
      if (!_bookingEmailConflictConfirmed && !_bookingConflictModalActive) {
        emailConflictBanner?.classList.add('hidden');
        nameConflictBanner?.classList.add('hidden');
        showBookingEmailConflictModal();
        hidePlayerRegistration(true);
        if (bookBtn) bookBtn.disabled = true;
      } else if (_bookingEmailConflictConfirmed) {
        showPlayerRegistration({ name, email });
        emailConflictBanner?.classList.add('hidden');
        nameConflictBanner?.classList.add('hidden');
        hideBookingEmailConflictModal();
        if (bookBtn) bookBtn.disabled = false;
      }
      // If modal was cancelled, do nothing until user changes details
    } else if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      // Name exists with different email - show warning banner only if not already confirmed
      if (!_bookingNameConflictConfirmed && !_bookingConflictModalActive) {
        nameConflictBanner?.classList.add('hidden');
        emailConflictBanner?.classList.add('hidden');
        showBookingNameConflictModal();
        hidePlayerRegistration(true);
        if (bookBtn) bookBtn.disabled = false;
      } else if (_bookingNameConflictConfirmed) {
        // Already confirmed, show form
        showPlayerRegistration({ name, email });
        emailConflictBanner?.classList.add('hidden');
        nameConflictBanner?.classList.add('hidden');
        hideBookingNameConflictModal();
        if (bookBtn) bookBtn.disabled = false;
      }
      // If modal was cancelled, do nothing until user changes details
    } else {
      // Email not found - show form normally
      showPlayerRegistration({ name, email });
      emailConflictBanner?.classList.add('hidden');
      nameConflictBanner?.classList.add('hidden');
      hideBookingEmailConflictModal();
      hideBookingNameConflictModal();
      if (bookBtn) bookBtn.disabled = false;
    }
  } catch (err) {
    console.error('Registration check failed', err);
    note?.classList.add('hidden');
  }
}, 600);

// Waitlist: live registration checking (same logic as booking form)
const handleWaitlistNameEmailChange = debounce(async () => {
    // Always clear all banners and modals on input change
    document.getElementById('waitlistEmailConflictBanner')?.classList.add('hidden');
    document.getElementById('waitlistNameConflictBanner')?.classList.add('hidden');
    document.getElementById('waitlistDuplicateWaitlistBanner')?.classList.add('hidden');
    document.getElementById('waitlistMessageBanner')?.classList.add('hidden');
    hideWaitlistEmailConflictModal();
    hideWaitlistNameConflictModal();
  const name = document.getElementById('waitlistName').value.trim();
  const email = document.getElementById('waitlistEmail').value.trim();
  const waitlistBanner = document.getElementById('waitlistEmailConflictBanner');
  const waitlistNameBanner = document.getElementById('waitlistNameConflictBanner');
  // Removed waitlistDuplicateBookingBanner (gray) for duplicate booking; only use waitlistMessageBanner (red)
  const waitlistDuplicateWaitlistBanner = document.getElementById('waitlistDuplicateWaitlistBanner');
  const waitlistBtn = document.getElementById('waitlistBtn');

  // Hide form if inputs incomplete or invalid
  const emailValid = /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email);
  if (!name || !email || !emailValid) {
    _registrationCheckId++;
    hidePlayerRegistration(true);
    waitlistBanner?.classList.add('hidden');
    waitlistNameBanner?.classList.add('hidden');
    // waitlistDuplicateBanner removed
    waitlistDuplicateWaitlistBanner?.classList.add('hidden');
    hideWaitlistEmailConflictModal();
    hideWaitlistNameConflictModal();
    if (waitlistBtn) waitlistBtn.disabled = false;
    _waitlistEmailConflictConfirmed = false;
    _waitlistNameConflictConfirmed = false;
    return;
  }

  const checkId = ++_registrationCheckId;
  console.log('Waitlist: checking profile for:', name, email, '(checkId=', checkId, ')');

  try {
    const checkResult = await checkPlayerRegistered(name, email);
    if (checkId !== _registrationCheckId) {
      console.log('Waitlist: stale registration check ignored (checkId', checkId, 'current', _registrationCheckId, ')');
      return;
    }

    console.log('Waitlist: profile found:', !!checkResult.registered);

    const existingName = (checkResult.existingName || '').trim().toLowerCase();
    const inputName = name.trim().toLowerCase();

    // Log if name exists with different email
    // Check for duplicate by both name and email
    const nameEmailMatch = checkResult.nameExists && checkResult.emailExists && existingName === inputName && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() === email.toLowerCase();
    if (nameEmailMatch) {
      console.debug('[DUPLICATE CHECK] Player with this name and email already exists:', name, email);
    } else if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      console.warn('‚ö†Ô∏è Waitlist: Name "' + name + '" already exists with a different email:', checkResult.existingEmail);
    }

    // Check if player is already booked on this session (even when joining waitlist)
    console.log('Waitlist: checking for duplicate booking - email:', email, 'date:', selectedDate, 'slot:', selectedSlot);
    if (checkResult.registered && selectedSlot && selectedDate) {
      const alreadyBooked = await isPlayerAlreadyBooked(email, selectedDate, selectedSlot);
      console.log('Waitlist: duplicate booking check result:', alreadyBooked);
      if (alreadyBooked) {
        console.warn('Player profile already booked onto session');
        showWaitlistMessage('You cannot join the waitlist for this session because you are already booked.', 'error');
        hidePlayerRegistration(true);
        if (waitlistBtn) waitlistBtn.disabled = true;
        return;
      }
    }

    if (checkResult.emailExists && existingName && existingName !== inputName && !_waitlistEmailConflictConfirmed && !_waitlistConflictModalActive) {
      waitlistBanner?.classList.add('hidden');
      waitlistNameBanner?.classList.add('hidden');
      showWaitlistEmailConflictModal();
      hidePlayerRegistration(true);
      if (waitlistBtn) waitlistBtn.disabled = true;
      return;
    }

    if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase() && !_waitlistNameConflictConfirmed && !_waitlistConflictModalActive) {
      waitlistNameBanner?.classList.add('hidden');
      waitlistBanner?.classList.add('hidden');
      showWaitlistNameConflictModal();
      hidePlayerRegistration(true);
      if (waitlistBtn) waitlistBtn.disabled = false;
      return;
    }
    if (selectedSlot && selectedDate) {
      const alreadyOnWaitlist = await isPlayerAlreadyOnWaitlist(email, selectedDate, selectedSlot);
      console.log('Waitlist: already on waitlist check result:', alreadyOnWaitlist);
      if (alreadyOnWaitlist) {
        console.warn('Player is already on the waitlist for this session');
        waitlistDuplicateWaitlistBanner?.classList.remove('hidden');
        waitlistBanner?.classList.add('hidden');
        waitlistNameBanner?.classList.add('hidden');
        hidePlayerRegistration(true);
        if (waitlistBtn) waitlistBtn.disabled = true;
        return;
      }
    }
    waitlistDuplicateWaitlistBanner?.classList.add('hidden');

    if (checkResult.registered) {
      hidePlayerRegistration(true);
      waitlistBanner?.classList.add('hidden');
      waitlistNameBanner?.classList.add('hidden');
      if (waitlistBtn) waitlistBtn.disabled = false;
    } else if (checkResult.emailExists && existingName && existingName !== inputName) {
      // Email exists with different name (already confirmed)
      document.getElementById('waitlistName').value = name;
      document.getElementById('waitlistEmail').value = email;
      showPlayerRegistration({ name, email }, true);
      waitlistBanner?.classList.add('hidden');
      waitlistNameBanner?.classList.add('hidden');
      hideWaitlistEmailConflictModal();
      if (waitlistBtn) waitlistBtn.disabled = false;
    } else if (checkResult.nameExists && checkResult.existingEmail && checkResult.existingEmail.toLowerCase() !== email.toLowerCase()) {
      // Name exists with different email (already confirmed)
      document.getElementById('waitlistName').value = name;
      document.getElementById('waitlistEmail').value = email;
      showPlayerRegistration({ name, email }, true);
      waitlistBanner?.classList.add('hidden');
      waitlistNameBanner?.classList.add('hidden');
      hideWaitlistNameConflictModal();
      if (waitlistBtn) waitlistBtn.disabled = false;
    } else {
      // Pre-fill waitlist form and show registration form (waitlist only, don't show booking form)
      document.getElementById('waitlistName').value = name;
      document.getElementById('waitlistEmail').value = email;
      showPlayerRegistration({ name, email }, true);
      waitlistBanner?.classList.add('hidden');
      waitlistNameBanner?.classList.add('hidden');
      if (waitlistBtn) waitlistBtn.disabled = false;
    }
  } catch (err) {
    console.error('Waitlist: registration check failed', err);
  }
}, 600);

['input','change'].forEach(ev => {
  document.getElementById('name').addEventListener(ev, handleNameEmailChange);
  document.getElementById('email').addEventListener(ev, handleNameEmailChange);
});

['input','change'].forEach(ev => {
  document.getElementById('waitlistName').addEventListener(ev, handleWaitlistNameEmailChange);
  document.getElementById('waitlistEmail').addEventListener(ev, handleWaitlistNameEmailChange);
});

// Handle "Yes, Continue" button for name conflict in booking form
document.getElementById('bookingNameConflictYesBtn')?.addEventListener('click', () => {
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();
  hideBookingNameConflictModal();
  _bookingNameConflictConfirmed = true;
  showPlayerRegistration({ name, email });
  handleNameEmailChange();
});

// Handle "Yes, Continue" button for email conflict in booking form
document.getElementById('bookingEmailConflictYesBtn')?.addEventListener('click', () => {
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();
  hideBookingEmailConflictModal();
  _bookingEmailConflictConfirmed = true;
  showPlayerRegistration({ name, email });
  handleNameEmailChange();
});

document.getElementById('bookingEmailConflictCancelBtn')?.addEventListener('click', () => {
  hideBookingEmailConflictModal();
});

document.getElementById('closeBookingEmailConflictModal')?.addEventListener('click', () => {
  hideBookingEmailConflictModal();
});

document.getElementById('bookingNameConflictCancelBtn')?.addEventListener('click', () => {
  hideBookingNameConflictModal();
});

document.getElementById('closeBookingNameConflictModal')?.addEventListener('click', () => {
  hideBookingNameConflictModal();
});

// Handle "Yes, Continue" button for name conflict in waitlist form
document.getElementById('waitlistNameConflictYesBtn')?.addEventListener('click', () => {
  const name = document.getElementById('waitlistName').value.trim();
  const email = document.getElementById('waitlistEmail').value.trim();
  hideWaitlistNameConflictModal();
  _waitlistNameConflictConfirmed = true;
  document.getElementById('waitlistName').value = name;
  document.getElementById('waitlistEmail').value = email;
  showPlayerRegistration({ name, email }, true);
  handleWaitlistNameEmailChange();
});

// Handle "Yes, Continue" button for email conflict in waitlist form
document.getElementById('waitlistEmailConflictYesBtn')?.addEventListener('click', () => {
  const name = document.getElementById('waitlistName').value.trim();
  const email = document.getElementById('waitlistEmail').value.trim();
  hideWaitlistEmailConflictModal();
  _waitlistEmailConflictConfirmed = true;
  document.getElementById('waitlistName').value = name;
  document.getElementById('waitlistEmail').value = email;
  showPlayerRegistration({ name, email }, true);
  handleWaitlistNameEmailChange();
});

document.getElementById('waitlistEmailConflictCancelBtn')?.addEventListener('click', () => {
  hideWaitlistEmailConflictModal();
});

document.getElementById('closeWaitlistEmailConflictModal')?.addEventListener('click', () => {
  hideWaitlistEmailConflictModal();
});

document.getElementById('waitlistNameConflictCancelBtn')?.addEventListener('click', () => {
  hideWaitlistNameConflictModal();
});

document.getElementById('closeWaitlistNameConflictModal')?.addEventListener('click', () => {
  hideWaitlistNameConflictModal();
});

// New book button flow which checks registration first
document.getElementById('bookBtn').onclick = async () => {
  console.log('üî¥ RESERVE BUTTON CLICKED');
  const name = document.getElementById('name').value.trim();
  const email = document.getElementById('email').value.trim();
  console.log('üìù Name:', name, 'Email:', email, 'SelectedSlot:', selectedSlot);
  const confirmEl = document.getElementById('blockConfirmation');

  // Validate inputs
  if (!selectedSlot) {
    console.warn('‚ùå No slot selected');
    showBookingMessage('Please select a session', 'error');
    return;
  }
  if (!name) {
    showBookingMessage('Please enter your name', 'error');
    return;
  }
  if (!email) {
    showBookingMessage('Please enter your email', 'error');
    return;
  }

  // If block session, validate checkbox
  if (selectedSlot.blockId) {
    const checkbox = document.getElementById('blockCheckbox');
    if (!checkbox.checked) {
      showBookingMessage('Please confirm you understand this is a 4-date block session', 'error');
      return;
    }
  }

  try {
    // Check registration first
    const registrationCheck = await checkPlayerRegistered(name, email);
    const registered = registrationCheck && registrationCheck.registered;
    
    console.log('üü° Registration check result:', registrationCheck);
    console.log('üü° Is player registered?', registered);
    
    if (registered) {
      console.log('‚úÖ Player is registered, continuing to book');
      // proceed with normal booking flow
      let bookingResult;
      try {
        if (selectedSlot.blockId) {
          bookingResult = await saveBlockBooking(selectedSlot, name, email);
        } else {
          bookingResult = await saveBooking(selectedSlot, name, email);
        }
        console.log('Booking saved, result:', bookingResult);
      } catch (err) {
        console.error('Error saving booking:', err);
        showBookingMessage('Error saving booking. Please try again.', 'error');
        return;
      }
      const bookingId = bookingResult && bookingResult.bookingId ? bookingResult.bookingId : null;
      console.log('Calling showPaymentInstructions with bookingId:', bookingId);
      console.log('üü¢ Full bookingResult:', JSON.stringify(bookingResult));
      console.log('üü¢ Extracted bookingId:', bookingId);
      if (!bookingId) {
        console.error('‚ùå WARNING: bookingId is null/undefined! Email cancellation link will not work!');
      }
      console.log('üü¢ showPaymentInstructions about to be called with:', { selectedSlot, name, email, selectedDate, bookingId });
      showPaymentInstructions(selectedSlot, name, email, selectedDate, bookingId);
      console.log('üü¢ showPaymentInstructions returned');
    } else {
      // Player not registered - check if registration form is shown
      const regForm = document.getElementById('playerRegistrationForm');
      const isRegShown = regForm && !regForm.classList.contains('hidden');
      
      console.log('üü° Player not registered. RegForm shown?', isRegShown);
      
      if (isRegShown) {
        // Registration form is showing - validate and save it
        console.log('üü° Registration form is showing, collecting data...');
        const profile = collectRegistrationData();
        clearRegistrationFieldErrors();
        const errs = validateRegistration(profile);
        
        if (errs.length > 0) {
          console.log('üü° Validation errors:', errs);
          showRegistrationFieldErrors(profile);
          showBookingMessage('Please complete all required registration fields', 'error');
          return;
        }
        
        // Save registration and proceed with booking
        console.log('üü° Validation passed, calling submitRegistrationAndContinue...');
        console.log('Profile JSON to save:', JSON.stringify(profile, null, 2));
        const ok = await submitRegistrationAndContinue();
        
        if (ok) {
          // Registration saved, now get fresh values from form and proceed with booking
          const finalName = document.getElementById('name').value.trim();
          const finalEmail = document.getElementById('email').value.trim();
          console.log('Using final values after registration:', finalName, finalEmail);
          
          let bookingResult;
          try {
            if (selectedSlot.blockId) {
              bookingResult = await saveBlockBooking(selectedSlot, finalName, finalEmail);
            } else {
              bookingResult = await saveBooking(selectedSlot, finalName, finalEmail);
            }
            console.log('Booking saved after registration, result:', bookingResult);
          } catch (err) {
            console.error('Error saving booking:', err);
            showBookingMessage('Error saving booking. Please try again.', 'error');
            return;
          }
          const bookingId = bookingResult && bookingResult.bookingId ? bookingResult.bookingId : null;
          console.log('Calling showPaymentInstructions with bookingId:', bookingId);
          showPaymentInstructions(selectedSlot, finalName, finalEmail, selectedDate, bookingId);
        }
      } else {
        // Show registration form for first time
        showPlayerRegistration({ name, email });
      }
    }
  } catch (error) {
    console.error('Booking error:', error);
    showBookingMessage('Error confirming booking. Please try again.', 'error');
  }
};

/* ================= PAYMENT COPY BUTTONS ================= */
document.getElementById('copyAccountBtn').onclick = (e) => {
  e.preventDefault();
  copyToClipboard(document.getElementById('accountNumber'), document.getElementById('copyAccountBtn'));
};

document.getElementById('copySortBtn').onclick = (e) => {
  e.preventDefault();
  copyToClipboard(document.getElementById('sortCode'), document.getElementById('copySortBtn'));
};

document.getElementById('copyRefBtn').onclick = (e) => {
  e.preventDefault();
  copyToClipboard(document.getElementById('paymentReference'), document.getElementById('copyRefBtn'));
};

/* ================= MODAL CONTROLS ================= */
document.getElementById('closePaymentModal').onclick = async () => {
  console.log('X button clicked - sending reservation email and closing');
  const emailSent = await sendReservationEmail();
  if (emailSent) {
    currentBookingData = null;
    currentBookingId = null;
    hidePaymentInstructions();
    setTimeout(() => {
      console.log('Auto-refreshing page to show pending reservation state');
      location.reload();
    }, 1000);
  }
};

document.getElementById('closePaymentBtn').onclick = async () => {
  console.log('Close button clicked - sending reservation email and closing');
  const emailSent = await sendReservationEmail();
  if (emailSent) {
    currentBookingData = null;
    currentBookingId = null;
    hidePaymentInstructions();
    setTimeout(() => {
      console.log('Auto-refreshing page to show pending reservation state');
      location.reload();
    }, 1000);
  }
};

// Disable overlay click to close (only allow explicit close via button)
document.getElementById('paymentModal').addEventListener('click', (e) => {
  if (e.target.id === 'paymentModal') {
    console.log('Overlay click ignored - must use Close button or Cancel');
  }
});

// ------------------- WAITLIST CONFIRMATION MODAL -------------------
const closeWaitlistModal = document.getElementById('closeWaitlistModal');
const closeWaitlistBtn = document.getElementById('closeWaitlistBtn');
const waitlistConfirmationModal = document.getElementById('waitlistConfirmationModal');

if (closeWaitlistModal) {
  closeWaitlistModal.onclick = () => {
    hideWaitlistConfirmationModal();
  };
}

if (closeWaitlistBtn) {
  closeWaitlistBtn.onclick = () => {
    hideWaitlistConfirmationModal();
  };
}

if (waitlistConfirmationModal) {
  waitlistConfirmationModal.addEventListener('click', (e) => {
    if (e.target.id === 'waitlistConfirmationModal' || e.target.classList.contains('payment-modal-overlay')) {
      hideWaitlistConfirmationModal();
    }
  });
}

// ------------------- USER GUIDE MODAL (UI-only) -------------------
const userGuideModal = document.getElementById('userGuideModal');
const openUserGuideBtn = document.getElementById('openUserGuideBtn');
const closeUserGuideBtn = document.getElementById('closeUserGuideBtn');
const closeUserGuideX = document.getElementById('closeUserGuide');
let _lastFocusedBeforeGuide = null;

function openUserGuide(){
  if (!userGuideModal) return;
  _lastFocusedBeforeGuide = document.activeElement;
  userGuideModal.classList.remove('hidden');
  userGuideModal.setAttribute('aria-hidden','false');
  document.body.classList.add('modal-open-payment');
  const content = userGuideModal.querySelector('.payment-modal-content');
  content.focus();
  document.addEventListener('keydown', _userGuideKeyHandler);
}

function closeUserGuide(){
  if (!userGuideModal) return;
  userGuideModal.classList.add('hidden');
  userGuideModal.setAttribute('aria-hidden','true');
  document.body.classList.remove('modal-open-payment');
  document.removeEventListener('keydown', _userGuideKeyHandler);
  try { _lastFocusedBeforeGuide?.focus(); } catch (err) {}
}

function _userGuideKeyHandler(e){
  if (e.key === 'Escape') closeUserGuide();
}

openUserGuideBtn?.addEventListener('click', (e)=>{ e.preventDefault(); openUserGuide(); });
closeUserGuideBtn?.addEventListener('click', (e)=>{ e.preventDefault(); closeUserGuide(); });
closeUserGuideX?.addEventListener('click', (e)=>{ e.preventDefault(); closeUserGuide(); });

// Close when clicking overlay area (user expects this for help dialogs)
userGuideModal?.addEventListener('click', (e)=>{ if (e.target.id === 'userGuideModal') closeUserGuide(); });

// Accessibility: allow focus to land inside the dialog
userGuideModal?.querySelector('.payment-modal-content')?.setAttribute('tabindex','-1');
// -----------------------------------------------------------------

/* ================= CANCEL BOOKING ================= */
document.getElementById('cancelBookingBtn').onclick = async () => {
  if (!currentBookingData) {
    showBookingMessage('Error: No booking data found', 'error');
    return;
  }
  
  console.log('Cancel button clicked - user does NOT want to reserve');
  console.log('Booking Reference (NOT sending email):', currentBookingData.paymentRef);
  
  if (!confirm('Are you sure? This will remove your booking and you can re-book if the slot is available.')) {
    return;
  }
  
  try {
    console.log('Calling cancelBooking.php to delete reservation');
    const response = await fetch(PHP_PATH + 'cancelBooking.php', {
      method: 'POST',
      body: JSON.stringify({
        name: currentBookingData.name,
        email: currentBookingData.email,
        date: currentBookingData.date,
        time: currentBookingData.slot.time,
        title: currentBookingData.slot.title,
        isBlock: currentBookingData.isBlock,
        blockDates: currentBookingData.blockDates,
        bookingId: currentBookingId || ''
      })
    });
    
    if (!response.ok) {
      throw new Error('Failed to cancel booking');
    }
    
    const result = await response.json();
    
    if (result.status === 'ok') {
      console.log('‚úì Booking cancelled successfully - NO email sent (as intended)');
      showBookingMessage('Booking cancelled. Your slot has been released.', 'success');
      
      // Reset UI
      hidePaymentInstructions();
      document.getElementById('name').value = '';
      document.getElementById('email').value = '';
      selectedSlot = null;
      hideBlockConfirmation();
      document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
      
      // Refresh calendar and slots
      buildCalendarSkeleton();
    } else {
      showBookingMessage('Error: ' + (result.message || 'Failed to cancel booking'), 'error');
    }
  } catch (error) {
    console.error('Cancellation error:', error);
    showBookingMessage('Error cancelling booking. Please try again.', 'error');
  }
};
document.getElementById('waitlistBtn').onclick = async () => {
    // Phone validation will be run after registration form is shown (for new users) or before saving waitlist (for existing users)
  const name = document.getElementById('waitlistName').value.trim();
  const email = document.getElementById('waitlistEmail').value.trim();
  // For block sessions, use blockCheckbox; for single, use waitlistConfirm
  let isConfirmed = false;
  const blockCheckbox = document.getElementById('blockCheckbox');
  const waitlistConfirmEl = document.getElementById('waitlistConfirm');
  if (blockCheckbox && !blockCheckbox.classList.contains('hidden') && blockCheckbox.offsetParent !== null) {
    isConfirmed = blockCheckbox.checked;
  } else if (waitlistConfirmEl) {
    isConfirmed = waitlistConfirmEl.checked;
  }
  // Removed waitlistDuplicateBookingBanner (gray) for duplicate booking; only use waitlistMessageBanner (red)
  const waitlistDuplicateWaitlistBanner = document.getElementById('waitlistDuplicateWaitlistBanner');
  const waitlistMessageBanner = document.getElementById('waitlistMessageBanner');
  // waitlistDuplicateBanner removed
  waitlistDuplicateWaitlistBanner?.classList.add('hidden');
  waitlistMessageBanner?.classList.add('hidden');
  console.log('üü† WAITLIST BUTTON CLICKED', { name, email, selectedSlot, selectedDate, isConfirmed });
  
  // Validate inputs
  if (!selectedSlot) {
    showWaitlistMessage('Please select a session', 'error');
    return;
  }
  if (!name) {
    showWaitlistMessage('Please enter your name', 'error');
    return;
  }
  if (!email) {
    showWaitlistMessage('Please enter your email', 'error');
    return;
  }
  if (!isConfirmed) {
    showWaitlistMessage('Please check the confirmation box before joining the waitlist', 'error');
    return;
  }
  
  try {
    // Guard: duplicate booking or duplicate waitlist
    if (selectedSlot && selectedDate) {
      const alreadyBooked = await isPlayerAlreadyBooked(email, selectedDate, selectedSlot);
      if (alreadyBooked) {
        showWaitlistMessage('You cannot join the waitlist for this session because you are already booked.', 'error');
        return;
      }

      const alreadyOnWaitlist = await isPlayerAlreadyOnWaitlist(email, selectedDate, selectedSlot);
      if (alreadyOnWaitlist) {
        waitlistDuplicateWaitlistBanner?.classList.remove('hidden');
        showWaitlistMessage('This user is already on the waitlist for this session.', 'error');
        return;
      }
    }

    console.log('üü† Waitlist: starting registration check');
    const saveWaitlistEntry = async (finalName, finalEmail) => {
      console.log('üü† Waitlist: saving entry for', finalName, finalEmail);
      
      // For block sessions, ALWAYS use the first date regardless of which date user clicked
      let dateToSend = selectedDate;
      if (selectedSlot.blockId && selectedSlot.blockDates && selectedSlot.blockDates.length > 0) {
        dateToSend = selectedSlot.blockDates[0];
        console.log('üü† Waitlist: Block session detected, using first date:', dateToSend, 'instead of clicked date:', selectedDate);
      }
      
      const response = await fetch(PHP_PATH + 'saveWaitlist.php', {
        method: 'POST',
        body: JSON.stringify({
          slot: selectedSlot,
          name: finalName,
          email: finalEmail,
          date: dateToSend,
          blockId: selectedSlot.blockId,
          blockDates: selectedSlot.blockDates
        })
      });
      const result = await response.json().catch(() => ({}));
      console.log('üü† Waitlist: saveWaitlist response:', result);
      if (!response.ok) throw new Error(result.message || 'Failed to add to waitlist');
      return result;
    };

    // Check registration first (same logic as booking)
    const registeredResult = await checkPlayerRegistered(name, email);
    const registered = !!registeredResult.registered;
    const existingName = (registeredResult.existingName || '').trim().toLowerCase();
    const inputName = name.trim().toLowerCase();

    if (!registered && registeredResult.emailExists && existingName && existingName !== inputName && !_waitlistEmailConflictConfirmed) {
      showWaitlistEmailConflictModal();
      return;
    }

    if (!registered && registeredResult.nameExists && registeredResult.existingEmail && registeredResult.existingEmail.toLowerCase() !== email.toLowerCase() && !_waitlistNameConflictConfirmed) {
      showWaitlistNameConflictModal();
      return;
    }
    
    console.log('üü† Waitlist: registered?', registered, registeredResult);

    let finalName = name;
    let finalEmail = email;
    let waitlistResult = null;

    if (registered) {
      // Validate emergency phone for existing users
      // If player is already registered, skip emergency contact validation
      waitlistResult = await saveWaitlistEntry(name, email);
    } else {
      const regForm = document.getElementById('playerRegistrationForm');
      const isRegVisible = regForm && !regForm.classList.contains('hidden');

      // Ensure profile save uses the waitlist name/email
      document.getElementById('name').value = name;
      document.getElementById('email').value = email;

      if (!isRegVisible) {
        // Pre-fill registration form fields for new player, then show registration form (waitlist only)
        document.getElementById('waitlistName').value = name;
        document.getElementById('waitlistEmail').value = email;
        showPlayerRegistration({ name, email }, true);
        return;
      }

      const profile = collectRegistrationData();
      clearRegistrationFieldErrors();
      const phone = profile.emergency?.phone || '';
      const phoneDigits = phone.replace(/\D/g, '');
      let phoneError = false;
      if (phone.length === 0) {
        showWaitlistMessage('Emergency contact phone is required', 'error');
        markFieldError('emergencyPhoneLabel', 'emergency_phone');
        phoneError = true;
      } else if (phoneDigits.length < 8 || !/^[- +()0-9]+$/.test(phone)) {
        showWaitlistMessage('Enter a valid emergency contact phone (at least 8 digits)', 'error');
        markFieldError('emergencyPhoneLabel', 'emergency_phone');
        phoneError = true;
      }
      const errs = validateRegistration(profile);
      if (errs.length > 0 || phoneError) {
        showRegistrationFieldErrors(profile);
        if (!phoneError) showWaitlistMessage('Please complete all required registration fields', 'error');
        return;
      }

      const ok = await submitRegistrationAndContinue();
      if (!ok) return;

      finalName = document.getElementById('name').value.trim();
      finalEmail = document.getElementById('email').value.trim();
      waitlistResult = await saveWaitlistEntry(finalName, finalEmail);
    }

    const waitlistSlot = selectedSlot;
    const waitlistDate = selectedDate;
    console.log('üü† Waitlist result object:', waitlistResult);
    const waitlistPosition = waitlistResult?.waitlistPosition || '-';
    console.log('üü† Extracted waitlist position:', waitlistPosition);
    showWaitlistConfirmationModal(waitlistPosition);
    sendWaitlistConfirmationEmail({
      name: finalName,
      email: finalEmail,
      slot: waitlistSlot,
      date: waitlistDate,
      waitlistPosition: waitlistPosition
    });

    // Reset form
    document.getElementById('waitlistName').value = '';
    document.getElementById('waitlistEmail').value = '';
    const waitlistConfirm = document.getElementById('waitlistConfirm');
    if (waitlistConfirm) waitlistConfirm.checked = false;
    const waitlistForm = document.getElementById('waitlistForm');
    if (waitlistForm) {
      waitlistForm.classList.add('hidden');
      waitlistForm.style.display = 'none';
    }
    selectedSlot = null;
    hideBlockConfirmation();
    document.querySelectorAll('.slot-card').forEach(s => { s.classList.remove('selected'); s.querySelector('.select-indicator')?.setAttribute('aria-pressed','false'); });
    
    // Refresh calendar and slots
    buildCalendarSkeleton();
  } catch (error) {

    console.error('Waitlist error:', error);
    showWaitlistMessage('Error adding to waitlist. Please try again.', 'error');
  }
};

// Show waitlist form only after checkbox is checked
const waitlistConfirmElem = document.getElementById('waitlistConfirm');
if (waitlistConfirmElem) {
  waitlistConfirmElem.onchange = (e) => {
    const waitlistForm = document.getElementById('waitlistForm');
    if (e.target.checked) {
      waitlistForm.classList.remove('hidden');
      waitlistForm.style.display = '';
      // Auto-scroll to waitlist form
      setTimeout(() => {
        waitlistForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 200);
      // Show block confirmation in waitlist mode if a block session is selected
      if (selectedSlot && selectedSlot.blockId) {
        showBlockConfirmation(selectedSlot, true);
        // Auto-scroll to show confirmation and next step
        const blockDetails = document.getElementById('blockConfirmation');
        blockDetails?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    } else {
      waitlistForm.classList.add('hidden');
      waitlistForm.style.display = 'none';
      // Hide block confirmation when unchecked
      hideBlockConfirmation();
    }
  };
}

// Show booking form only after block checkbox is checked
document.getElementById('blockCheckbox').onchange = (e) => {
  const bookingForm = document.getElementById('bookingForm');
  const titleEl = document.getElementById('playerRegistrationTitle');
  const regForm = document.getElementById('playerRegistrationForm');
  const blockConfirmation = document.getElementById('blockConfirmation');
  const isWaitlistMode = blockConfirmation?.classList.contains('waitlist-mode');
  
  if (e.target.checked) {
    // Only show booking form if NOT in waitlist mode (i.e., session is not fully booked)
    if (!isWaitlistMode) {
      // Show booking form (with name/email fields)
      bookingForm.classList.remove('hidden');
      bookingForm.style.display = '';
      // Show player registration title and form
      titleEl?.classList.remove('hidden');
      regForm?.classList.remove('hidden');
      // Auto-scroll to show confirmation and next step
      bookingForm?.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }
  } else {
    // Hide all forms when unchecked
    bookingForm.classList.add('hidden');
    bookingForm.style.display = 'none';
    titleEl?.classList.add('hidden');
    regForm?.classList.add('hidden');
  }
};



/* ================= INIT ================= */
buildCalendarSkeleton();
</script>

<!-- Help link at bottom of page -->
<div style="text-align:center; padding:24px 12px; color:var(--muted);">
  <button id="bottomHelpLink" class="help-link" type="button">
    <span>Need help cancelling a session?</span>
  </button>
</div>

<script>
document.getElementById('bottomHelpLink')?.addEventListener('click', (e)=>{ e.preventDefault(); openUserGuide(); });
</script>

</body>
</html>
