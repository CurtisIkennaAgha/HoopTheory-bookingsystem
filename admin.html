<!-- Activity Modal -->
<div id="activityCentreModal" class="pt-modal" style="display:none;z-index:13000;" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="pt-modal-overlay" id="activityCentreModalOverlay"></div>
  <div class="pt-modal-content" role="document" aria-labelledby="activityCentreModalTitle" style="max-width: 400px; background: #fff; color: #222; border-radius: 14px; box-shadow: 0 8px 32px rgba(0,0,0,0.12); padding: 0; overflow: hidden;">
    <div style="display: flex; align-items: center; justify-content: space-between; background: #f8fafc; padding: 16px 20px 12px 20px; border-bottom: 1px solid #e5e7eb;">
      <h3 id="activityCentreModalTitle" style="margin: 0; font-size: 1.15rem; font-weight: 700; letter-spacing: 0.2px; color: #222;">Activity</h3>
      <button class="pt-modal-close" id="activityCentreModalClose" aria-label="Close dialog" style="background: none; border: none; color: #222; font-size: 1.5rem; font-family: 'Inter', Arial, sans-serif; cursor: pointer; padding: 0 0 0 16px;">&#215;</button>
    </div>
    <div id="activityCentreBody" class="pt-modal-body" style="padding: 18px 0 8px 0; max-height: 320px; overflow-y: auto; background: #fff;">
      <div style="color:#888; font-size:0.98em; text-align:center; padding: 18px 0 0 0;" id="activityCentreEmpty">Loading notifications...</div>
    </div>
  </div>
</div>


<!-- (JS code block removed from top of file; should be inside <script> at the end) -->
<!-- Edit Booking Modal -->
<div id="editBookingModal" style="display:none; position:fixed; z-index:10000; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.45); align-items:center; justify-content:center;">
  <div style="background:#fff; border-radius:10px; max-width:420px; width:95vw; padding:28px 24px 18px 24px; box-shadow:0 8px 32px rgba(0,0,0,0.18); position:relative;">
    <button id="closeEditBookingModal" style="position:absolute; top:10px; right:12px; background:none; border:none; font-size:1.5rem; color:#888; font-family: 'Inter', Arial, sans-serif; cursor:pointer;">&#215;</button>
    <h2 style="margin-top:0; font-size:1.25rem; margin-bottom:18px; text-align:center;">Edit Booking</h2>
    <form id="editBookingForm" autocomplete="off">
      <div style="margin-bottom:12px;">
        <label>Name<br><input type="text" id="editBookingName" name="name" style="width:100%;padding:6px 8px;"></label>
      </div>
      <div style="margin-bottom:12px;">
        <label>Email<br><input type="email" id="editBookingEmail" name="email" style="width:100%;padding:6px 8px;"></label>
      </div>
      <!-- Only Name, Email, and Status fields remain -->
      <div style="margin-bottom:12px;">
        <label>Status<br>
          <select id="editBookingStatus" name="status" style="width:100%;padding:6px 8px;">
            <option value="confirmed">Confirmed</option>
            <option value="pending">Pending</option>
          </select>
        </label>
      </div>
      <div style="margin-bottom:18px; text-align:center;">
        <button type="submit" style="background:#2196F3;color:#fff;padding:8px 24px;border:none;border-radius:6px;font-size:1rem;font-weight:600;cursor:pointer;">Save Changes</button>
      </div>
    </form>
  </div>
</div>

<script>
// ========== ADMIN SETTINGS MODAL (BOOKING EXPIRY CONFIG) ========== 
document.addEventListener('DOMContentLoaded', function() {
    // ========== SEND TEST EMAILS BUTTON HANDLER ========== 
    const sendTestEmailsBtn = document.getElementById('sendTestEmailsBtn');
    if (sendTestEmailsBtn) {
      sendTestEmailsBtn.addEventListener('click', async () => {
        const email = prompt('Enter the email address to send test emails to:');
        if (!email || !/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) {
          expirySettingsFeedback.textContent = 'Invalid email address.';
          expirySettingsFeedback.style.color = '#ef4444';
          return;
        }
        sendTestEmailsBtn.disabled = true;
        sendTestEmailsBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sending...';
        expirySettingsFeedback.textContent = '';
        expirySettingsFeedback.style.color = '';
        const testPayloads = [
          {
            type: 'confirmation',
            email,
            name: 'Test User',
            slot: '18:00',
            date: '2026-02-18',
            title: 'Test Session',
            price: '10',
            location: 'Test Gym',
            paymentRef: 'TESTUSER-TESTSESSION',
            deadline: '2026-02-19 18:00',
            bookingId: 'test-booking-id'
          },
          {
            type: 'temporary_reservation',
            email,
            name: 'Test User',
            slot: '18:00',
            date: '2026-02-18',
            title: 'Test Session',
            price: '10',
            location: 'Test Gym',
            paymentRef: 'TESTUSER-TESTSESSION',
            deadline: '2026-02-19 18:00',
            bookingId: 'test-booking-id'
          },
          {
            type: 'waitlist_confirmation',
            email,
            name: 'Test User',
            slot: '18:00',
            date: '2026-02-18',
            title: 'Test Session',
            waitlistPosition: 1
          },
          {
            type: 'waitlist_offer',
            email,
            name: 'Test User',
            slot: '18:00',
            date: '2026-02-18',
            title: 'Test Session',
            price: '10',
            location: 'Test Gym',
            paymentRef: 'TESTUSER-TESTSESSION',
            deadline: '2026-02-19 18:00',
            bookingId: 'test-booking-id'
          },
          {
            type: 'booking_edited',
            email,
            name: 'Test User',
            slot: '18:00',
            date: '2026-02-18',
            title: 'Test Session',
            price: '10',
            location: 'Test Gym',
            changedFields: {
              price: { old: '8', new: '10' },
              location: { old: 'Old Gym', new: 'Test Gym' }
            }
          },
          {
            type: 'booking_cancellation',
            email,
            name: 'Test User',
            slot: '18:00',
            date: '2026-02-18',
            title: 'Test Session',
            bookingId: 'test-booking-id'
          }
        ];
        let successCount = 0;
        let failCount = 0;
        for (const payload of testPayloads) {
          try {
            let endpoint = 'php/sendEmail.php';
            // For waitlist_offer, use sendOfferEmail.php
            if (payload.type === 'waitlist_offer') {
              endpoint = 'php/sendOfferEmail.php';
            }
            const res = await fetch(endpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            const result = await res.json();
            if (result.success) {
              successCount++;
            } else {
              failCount++;
            }
          } catch (e) {
            failCount++;
          }
        }
        sendTestEmailsBtn.disabled = false;
        sendTestEmailsBtn.innerHTML = '<i class="fas fa-envelope"></i> Send Test Emails';
        if (successCount > 0) {
          expirySettingsFeedback.textContent = `Sent ${successCount} test email(s) to ${email}.`;
          expirySettingsFeedback.style.color = '#22c55e';
        } else {
          expirySettingsFeedback.textContent = 'Failed to send test emails.';
          expirySettingsFeedback.style.color = '#ef4444';
        }
      });
    }
  // Auto-run cleanupExpiredOffers.php to remove expired offers/waitlist entries
  fetch('php/cleanupExpiredOffers.php', { method: 'GET' })
    .then(r => r.text())
    .then(txt => { console.log('CleanupExpiredOffers:', txt); })
    .catch(err => { console.warn('CleanupExpiredOffers error:', err); });
  const openSettingsModalBtn = document.getElementById('openSettingsModal');
  const adminSettingsModal = document.getElementById('adminSettingsModal');
  const adminSettingsModalOverlay = document.getElementById('adminSettingsModalOverlay');
  const adminSettingsModalClose = document.getElementById('adminSettingsModalClose');
  const saveExpiryBtn = document.getElementById('saveExpiryBtn');
  const cancelExpiryBtn = document.getElementById('cancelExpiryBtn');
  // Booking expiry fields
  const expiryHoursInput = document.getElementById('expiryHours');
  const expiryMinutesInput = document.getElementById('expiryMinutes');
  const expirySecondsInput = document.getElementById('expirySeconds');
  const currentExpiryDisplay = document.getElementById('currentExpiryDisplay');
  // Offer expiry fields
  const offerExpiryHoursInput = document.getElementById('offerExpiryHours');
  const offerExpiryMinutesInput = document.getElementById('offerExpiryMinutes');
  const offerExpirySecondsInput = document.getElementById('offerExpirySeconds');
  const currentOfferExpiryDisplay = document.getElementById('currentOfferExpiryDisplay');
  const expirySettingsFeedback = document.getElementById('expirySettingsFeedback');

  function openSettingsModal() {
    expirySettingsFeedback.textContent = '';
    // Booking expiry
    fetch('data/bookingExpiryConfig.json?t=' + Date.now())
      .then(r => r.json())
      .then(cfg => {
        let secs = parseInt(cfg.expirySeconds || 0);
        const h = Math.floor(secs / 3600);
        secs -= h * 3600;
        const m = Math.floor(secs / 60);
        const s = secs - m * 60;
        expiryHoursInput.value = h;
        expiryMinutesInput.value = m;
        expirySecondsInput.value = s;
        currentExpiryDisplay.textContent = `Current expiry: ${h}h ${m}m ${s}s`;
      })
      .catch(() => {
        expiryHoursInput.value = 0;
        expiryMinutesInput.value = 0;
        expirySecondsInput.value = 0;
        currentExpiryDisplay.textContent = 'Current expiry: unknown';
      });
    // Offer expiry
    fetch('data/offerExpiryConfig.json?t=' + Date.now())
      .then(r => r.json())
      .then(cfg => {
        let secs = parseInt(cfg.expirySeconds || 0);
        const h = Math.floor(secs / 3600);
        secs -= h * 3600;
        const m = Math.floor(secs / 60);
        const s = secs - m * 60;
        offerExpiryHoursInput.value = h;
        offerExpiryMinutesInput.value = m;
        offerExpirySecondsInput.value = s;
        currentOfferExpiryDisplay.textContent = `Current offer expiry: ${h}h ${m}m ${s}s`;
      })
      .catch(() => {
        offerExpiryHoursInput.value = 0;
        offerExpiryMinutesInput.value = 0;
        offerExpirySecondsInput.value = 0;
        currentOfferExpiryDisplay.textContent = 'Current offer expiry: unknown';
      });
    adminSettingsModal.style.display = 'flex';
    adminSettingsModal.classList.add('open');
    document.body.classList.add('modal-open');
  }
  function closeSettingsModal() {
    adminSettingsModal.style.display = 'none';
    adminSettingsModal.classList.remove('open');
    document.body.classList.remove('modal-open');
  }
  if (openSettingsModalBtn) openSettingsModalBtn.onclick = openSettingsModal;
  if (adminSettingsModalOverlay) adminSettingsModalOverlay.onclick = closeSettingsModal;
  if (adminSettingsModalClose) adminSettingsModalClose.onclick = closeSettingsModal;
  if (cancelExpiryBtn) cancelExpiryBtn.onclick = closeSettingsModal;
  if (saveExpiryBtn) saveExpiryBtn.onclick = async function() {
    expirySettingsFeedback.textContent = '';
    // Booking expiry
    const h = parseInt(expiryHoursInput.value) || 0;
    const m = parseInt(expiryMinutesInput.value) || 0;
    const s = parseInt(expirySecondsInput.value) || 0;
    const totalSeconds = h * 3600 + m * 60 + s;
    // Offer expiry
    const oh = parseInt(offerExpiryHoursInput.value) || 0;
    const om = parseInt(offerExpiryMinutesInput.value) || 0;
    const os = parseInt(offerExpirySecondsInput.value) || 0;
    const offerTotalSeconds = oh * 3600 + om * 60 + os;
    if (totalSeconds < 10 || offerTotalSeconds < 10) {
      expirySettingsFeedback.textContent = 'Expiry must be at least 10 seconds for both.';
      expirySettingsFeedback.style.color = '#ef4444';
      return;
    }
    saveExpiryBtn.disabled = true;
    saveExpiryBtn.textContent = 'Saving...';
    try {
      // Update booking expiry
      const res = await fetch('php/saveBookingExpiry.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ expirySeconds: totalSeconds })
      });
      // Update offer expiry
      const offerRes = await fetch('php/saveOfferExpiry.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ expirySeconds: offerTotalSeconds })
      });
      // Run cleanup after expiry update
      await fetch('php/cleanupExpiredOffers.php', { method: 'GET' });
      const data = await res.json();
      const offerData = await offerRes.json();
      if (data.success && offerData.success) {
        expirySettingsFeedback.textContent = 'Expiry updated for bookings and waitlist offers.';
        expirySettingsFeedback.style.color = '#22c55e';
        currentExpiryDisplay.textContent = `Current expiry: ${h}h ${m}m ${s}s`;
        currentOfferExpiryDisplay.textContent = `Current offer expiry: ${oh}h ${om} ${os}s`;
        setTimeout(() => { closeSettingsModal(); }, 1200);
        if (typeof renderAllBookings === 'function') await renderAllBookings();
      } else {
        let msg = 'Failed to update:';
        if (!data.success) msg += ' bookings (' + (data.error || 'Unknown error') + ')';
        if (!offerData.success) msg += ' offers (' + (offerData.error || 'Unknown error') + ')';
        expirySettingsFeedback.textContent = msg;
        expirySettingsFeedback.style.color = '#ef4444';
      }
    } catch (err) {
      expirySettingsFeedback.textContent = 'Error: ' + err.message;
      expirySettingsFeedback.style.color = '#ef4444';
    } finally {
      saveExpiryBtn.disabled = false;
      saveExpiryBtn.textContent = 'Save';
    }
  };
});
</script>
<script>
// ========== BLOCK SESSION PREVIEW LOGIC (MODAL-AWARE) ========== //
// This logic attaches only after the session modal is created and shown.
// It auto-generates session dates/times based on admin input, but preserves manual edits.

function attachBlockSessionPreviewLogic() {
  console.log('[BLOCK PREVIEW] attachBlockSessionPreviewLogic called');
  // Field selectors (modal block session fields)
  const startDateInput = document.getElementById('modalBlockFirstDate');
  const startTimeInput = document.getElementById('modalBlockStartTime');
  const durationInput = document.getElementById('modalBlockDuration');
  const numSessionsInput = document.getElementById('modalBlockNumberOfSessions');
  console.log('[BLOCK PREVIEW] Inputs:', {
    startDateInput, startTimeInput, durationInput, numSessionsInput
  });
  const previewRows = Array.from(document.querySelectorAll('#blockSessionPreviewRows .block-session-row'));
  console.log('[BLOCK PREVIEW] previewRows:', previewRows);
  const rowFields = previewRows.map((row, idx) => {
    const inputs = row.querySelectorAll('input');
    console.log(`[BLOCK PREVIEW] Row ${idx} inputs:`, inputs);
    return {
      date: inputs[0],
      time: inputs[1]
    };
  });
  const customRows = new Set();
  function parseDate(str) {
    if (!str) return null;
    const [y, m, d] = str.split('-').map(Number);
    if (!y || !m || !d) return null;
    return new Date(y, m - 1, d);
  }
  function formatDate(date) {
    if (!(date instanceof Date)) return '';
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    return `${date.getFullYear()}-${mm}-${dd}`;
  }
  function formatTime(date) {
    if (!(date instanceof Date)) return '';
    return date.toTimeString().slice(0,5);
  }
  function parseTime(str) {
    if (!str) return null;
    const [h, m] = str.split(':').map(Number);
    if (isNaN(h) || isNaN(m)) return null;
    const d = new Date();
    d.setHours(h, m, 0, 0);
    return d;
  }
  function updatePreviewRows() {
    console.log('[BLOCK PREVIEW] updatePreviewRows called');
    if (!startDateInput || !startTimeInput || !durationInput || !numSessionsInput) {
      console.warn('[BLOCK PREVIEW] One or more modal input fields are missing:', {
        startDateInput, startTimeInput, durationInput, numSessionsInput
      });
      return;
    }
    const startDate = parseDate(startDateInput.value);
    const startTime = parseTime(startTimeInput.value);
    const duration = parseInt(durationInput.value, 10);
    let numSessions = parseInt(numSessionsInput.value, 10);
    console.log('[BLOCK PREVIEW] Values:', {
      startDateInput: startDateInput.value,
      startTimeInput: startTimeInput.value,
      durationInput: durationInput.value,
      numSessionsInput: numSessionsInput.value,
      startDate, startTime, duration, numSessions
    });
    if (!numSessions || numSessions < 1) numSessions = 1;
    if (numSessions > rowFields.length) numSessions = rowFields.length;
    for (let i = 0; i < rowFields.length; ++i) {
      if (!customRows.has(i)) {
        if (i < numSessions && startDate && startTime && duration) {
          const sessionDate = new Date(startDate.getTime());
          sessionDate.setDate(sessionDate.getDate() + i * 7);
          const sessionTime = new Date(startTime.getTime());
          console.log(`[BLOCK PREVIEW] Autofilling row ${i}:`, {
            sessionDate, sessionTime
          });
          if (!rowFields[i].date.value) rowFields[i].date.value = formatDate(sessionDate);
          if (!rowFields[i].time.value) rowFields[i].time.value = formatTime(sessionTime);
        } else {
          console.log(`[BLOCK PREVIEW] Clearing row ${i}`);
          if (!rowFields[i].date.value || !customRows.has(i)) rowFields[i].date.value = '';
          if (!rowFields[i].time.value || !customRows.has(i)) rowFields[i].time.value = '';
        }
      } else {
        console.log(`[BLOCK PREVIEW] Row ${i} is custom, skipping autofill`);
      }
    }
  }
  rowFields.forEach((fields, idx) => {
    fields.date.addEventListener('input', () => {
      if (fields.date.value) {
        customRows.add(idx);
        console.log(`[BLOCK PREVIEW] Row ${idx} date manually edited, marking as custom`);
      }
    });
    fields.time.addEventListener('input', () => {
      if (fields.time.value) {
        customRows.add(idx);
        console.log(`[BLOCK PREVIEW] Row ${idx} time manually edited, marking as custom`);
      }
    });
  });
  [startDateInput, startTimeInput, durationInput, numSessionsInput].forEach((input, idx) => {
    if (input) {
      input.addEventListener('input', updatePreviewRows);
      console.log(`[BLOCK PREVIEW] Attached input event to field ${input.id}`);
    } else {
      console.warn(`[BLOCK PREVIEW] Input field missing for index ${idx}`);
    }
  });
  updatePreviewRows();
  console.log('[BLOCK PREVIEW] Initial updatePreviewRows complete');
}

// Patch modal open logic to call attachBlockSessionPreviewLogic after modal is inserted
console.log('[BLOCK PREVIEW] Patching showSessionModal');
if (window.showSessionModal) {
  const origShowSessionModal = window.showSessionModal;
  window.showSessionModal = function(...args) {
    console.log('[BLOCK PREVIEW] showSessionModal called', args);
    const result = origShowSessionModal.apply(this, args);
    setTimeout(() => {
      console.log('[BLOCK PREVIEW] setTimeout after showSessionModal');
      attachBlockSessionPreviewLogic();
    }, 0);
    return result;
  };
} else {
  console.warn('[BLOCK PREVIEW] showSessionModal is not defined at patch time');
}

// Force run preview logic on page load for debugging
window.addEventListener('DOMContentLoaded', () => {
  console.log('[BLOCK PREVIEW] DOMContentLoaded - forcibly running attachBlockSessionPreviewLogic');
  attachBlockSessionPreviewLogic();
});


// Dynamically adjust preview rows to match number of sessions
function ensureBlockSessionPreviewRows(numSessions) {
  const maxSessions = 8;
  const n = Math.max(1, Math.min(numSessions || 1, maxSessions));
  const container = document.getElementById('blockSessionPreviewRows');
  if (!container) return;
  let currentRows = container.querySelectorAll('.block-session-row');
  currentRows = Array.from(currentRows);
  // Add rows if needed
  while (currentRows.length < n) {
    const idx = currentRows.length;
    const row = document.createElement('div');
    row.className = 'block-session-row';
    row.setAttribute('style', 'display:flex; align-items:center; gap:12px; background:#fff; border-radius:6px; padding:10px 8px; border:1px solid #e0e7ef;');
    row.innerHTML = `
      <span style="min-width:32px; font-weight:600; color:#374151; margin-left:8px;">#${idx + 1}</span>
      <input type="date" style="width:80px; min-width:0; max-width:100px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;" />
      <input type="time" style="width:64px; min-width:0; max-width:80px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;" />
    `;
    container.appendChild(row);
    currentRows.push(row);
  }
  // Remove rows if needed
  while (currentRows.length > n) {
    container.removeChild(currentRows.pop());
  }
}

// Patch attachBlockSessionPreviewLogic to support dynamic rows
const origAttachBlockSessionPreviewLogic = attachBlockSessionPreviewLogic;
attachBlockSessionPreviewLogic = function() {
  // Get numSessions from input
  const numSessionsInput = document.getElementById('modalBlockNumberOfSessions');
  let numSessions = 1;
  if (numSessionsInput && numSessionsInput.value) {
    numSessions = parseInt(numSessionsInput.value, 10) || 1;
  }
  ensureBlockSessionPreviewRows(numSessions);
  // Now call original logic (which will re-query the rows)
  origAttachBlockSessionPreviewLogic();
  // Also, re-adjust rows on input change
  if (numSessionsInput && !numSessionsInput._blockPreviewPatched) {
    numSessionsInput.addEventListener('input', function() {
      let n = parseInt(numSessionsInput.value, 10) || 1;
      ensureBlockSessionPreviewRows(n);
      origAttachBlockSessionPreviewLogic();
    });
    numSessionsInput._blockPreviewPatched = true;
  }
};
</script>
</script>
<!-- ...existing code... -->
<!DOCTYPE html>
<html lang="en">
<head>
<style id="tableModeStyle" disabled>
  .admin-table, .admin-table th, .admin-table td {
    border: 1px solid #bbb;
    border-radius: 0;
    background: #fff;
    color: #222;
    box-shadow: none;
    font-size: 0.5rem !important;
    font-family: inherit;
    padding: 1px 2px;
  }
  .admin-table .delete-btn {
    background: none;
    border: none;
    color: #0074d9;
    font-size: 0.5rem !important;
    padding: 0;
    box-shadow: none;
    margin: 0;
    cursor: pointer;
    text-decoration: underline;
  }
  .admin-table * {
    font-size: 0.5rem !important;
  }
  .admin-table .actions { white-space: normal; }
  /* Wrapper that enables horizontal scrolling for wide tables */
  .admin-table-wrapper {
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  .admin-table th, .admin-table td { white-space: nowrap !important; word-break: normal !important; overflow-wrap: normal !important; }
  /* Allow specific table cells to wrap across multiple words (stack vertically) */
  .admin-table td.wrap-words {
    white-space: normal !important;
    word-break: normal !important;
    overflow-wrap: break-word !important;
  }
</style>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Admin - Booking System</title>
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
  /* Admin page additional styles */
  .admin-container {
    max-width: 760px;
    margin: 20px auto;
    padding: clamp(16px, 5vw, 28px);
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
  }

  /* Toggle Switch Styles */
  .view-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-bottom: 20px;
  }

  .toggle-label {
    font-size: 0.75rem;
    font-weight: 500;
    color: #666;
    user-select: none;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 38px;
    height: 20px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #e0e0e0;
    transition: 0.3s;
    border-radius: 20px;
  }

  .slider:before {
    position: absolute;
    content: "";
    height: 14px;
    width: 14px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }

  input:checked + .slider {
    background-color: #2a2a2a;
  }

  input:checked + .slider:before {
    transform: translateX(18px);
  }
  #allBookingsSection .refresh-info {
    padding: clamp(8px, 2vw, 12px);
    background: rgba(255,255,255,0.6);
    border-radius: 6px;
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

#allBookingsSection .refresh-info i {
  animation: spin 2s linear infinite;
  flex-shrink: 0;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.all-bookings-container {
  display: grid;
  gap: 12px;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 8px;
  min-height: auto;
  height: auto;
  width: 100%;
  max-height: calc(100vh - 340px);
  grid-template-columns: repeat(auto-fill, minmax(min(600px, 100%), 1fr));
  box-sizing: border-box;
}

.all-bookings-container::-webkit-scrollbar {
  width: 6px;
}

.all-bookings-container::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.05);
  border-radius: 10px;
}

.all-bookings-container::-webkit-scrollbar-thumb {
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
}

.all-booking-card {
  padding: clamp(12px, 3vw, 16px);
  background: white;
  border-radius: 10px;
  border-left: 4px solid #4CAF50;
  box-shadow: 0 2px 8px rgba(0,0,0,0.06);
  display: flex;
  justify-content: flex-start;
  align-items: flex-start;
  transition: all 0.3s ease;
  cursor: pointer;
  flex-wrap: wrap;
  gap: 12px;
  max-width: 100%;
  width: 100%;
  box-sizing: border-box;
  overflow: hidden;
}

.all-booking-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  transform: translateX(2px);
}

.all-booking-card.pending {
  border-left-color: #FF9800;
}

.all-booking-card.confirmed {
  border-left-color: #4CAF50;
}

/* Compact view - show only header with name/email/status */
.all-booking-card .booking-details {
  display: none;
  width: 100%;
}

.all-booking-card.expanded {
  flex-direction: column;
  align-items: flex-start;
  gap: 12px;
}

.all-booking-card.expanded .booking-details {
  display: block;
}

.booking-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  width: 100%;
  gap: 12px;
  flex-direction: column;
}

.booking-header-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
  overflow: hidden;
  width: 100%;
}

.booking-date-time {
  font-weight: 600;
  color: #333;
  font-size: clamp(0.85rem, 2vw, 0.95rem);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  overflow: hidden;
}

.booking-date-time i {
  color: #4CAF50;
  flex-shrink: 0;
}

.booking-person {
  font-size: clamp(0.75rem, 2vw, 0.85rem);
  color: #666;
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
  word-break: break-word;
  overflow-wrap: break-word;
  overflow: hidden;
}

.booking-person i {
  flex-shrink: 0;
}

.booking-status-badge {
  padding: clamp(4px, 1vw, 6px) clamp(8px, 2vw, 12px);
  border-radius: 20px;
  font-size: clamp(0.65rem, 1.5vw, 0.8rem);
  font-weight: 600;
  text-transform: uppercase;
  white-space: nowrap;
  flex-shrink: 0;
  align-self: flex-start;
}

.booking-status-badge.pending {
  background: #FFE0B2;
  color: #E65100;
}

.booking-status-badge.confirmed {
  background: #C8E6C9;
  color: #2E7D32;
}

.booking-actions {
  display: none;
  width: 100%;
  gap: clamp(8px, 2vw, 12px);
  margin-top: 10px;
  flex-direction: row;
  flex-wrap: nowrap;
}

.all-booking-card.expanded .booking-actions {
  display: flex;
}

.booking-actions button {
  flex: 1;
  min-width: 0;
  padding: clamp(10px, 2.5vw, 12px) clamp(12px, 3vw, 16px);
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: clamp(0.8rem, 2vw, 0.9rem);
  transition: all 0.2s ease;
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.booking-actions .confirm {
  background: #4CAF50;
  color: white;
}

.booking-actions .confirm:hover {
  background: #45a049;
}

.booking-actions .confirm:active {
  transform: scale(0.98);
}

.booking-actions .delete {
  background: #f44336;
  color: white;
}

.booking-actions .delete:hover {
  background: #da190b;
}

.booking-actions .delete:active {
  transform: scale(0.98);
}

.empty-bookings {
  text-align: center;
  padding: clamp(20px, 8vw, 40px);
  color: #999;
  font-style: italic;
  font-size: clamp(0.9rem, 2vw, 1rem);
}

.empty-bookings i {
  font-size: clamp(1.5rem, 8vw, 2.5rem);
  margin-bottom: 10px;
  display: block;
  opacity: 0.5;
}

/* All sessions section */
#allAvailableSlotsSection {
  margin-top: clamp(20px, 5vh, 30px);
  padding: clamp(16px, 4vw, 24px);
  background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
  border-radius: 12px;
  box-shadow: 0 8px 16px rgba(0,0,0,0.08);
}

#allAvailableSlotsSection h2 {
  margin: 0 0 15px 0;
  font-size: clamp(1.1rem, 4vw, 1.3rem);
  color: #1b5e20;
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.available-slots-container {
  display: grid;
  gap: 10px;
  overflow-y: auto;
  padding-right: 8px;
  max-height: calc(100vh - 340px);
}

.available-slots-container::-webkit-scrollbar {
  width: 6px;
}

.available-slots-container::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.05);
  border-radius: 10px;
}

.available-slots-container::-webkit-scrollbar-thumb {
  background: rgba(0,0,0,0.2);
  border-radius: 10px;
}

.available-slot-card {
  padding: clamp(10px, 2.5vw, 12px);
  background: white;
  border-radius: 10px;
  border-left: 4px solid #4CAF50;
  box-shadow: 0 2px 8px rgba(0,0,0,0.06);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  transition: all 0.2s ease;
  gap: 12px;
  flex-wrap: wrap;
  min-height: auto;
}

.available-slot-card.expanded {
  padding: clamp(12px, 3vw, 16px);
}

.available-slot-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.available-slot-info {
  flex: 1;
  min-width: 150px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}

.available-slot-date {
  font-weight: 600;
  color: #1b5e20;
  font-size: clamp(0.85rem, 2vw, 0.95rem);
  display: flex;
  align-items: center;
  gap: 8px;
}

.available-slot-date i {
  color: #4CAF50;
}

.available-slot-times {
  font-size: clamp(0.75rem, 2vw, 0.85rem);
  color: #558b2f;
  margin-top: 4px;
}

.available-slot-times.compact {
  overflow: hidden;
  word-wrap: break-word;
}

.available-slot-remove-btn {
  background: #f44336;
  color: white;
  border: none;
  padding: clamp(6px, 2vw, 8px) clamp(10px, 2.5vw, 12px);
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: clamp(0.65rem, 1.5vw, 0.75rem);
  transition: all 0.2s ease;
  min-height: auto;
  display: none;
  align-items: center;
  justify-content: center;
  gap: 4px;
  flex-shrink: 0;
  white-space: nowrap;
}

.available-slot-card.expanded .available-slot-remove-btn {
  display: flex;
}

.available-slot-toggle-btn {
  background: none;
  border: none;
  color: #4CAF50;
  cursor: pointer;
  padding: 4px 6px;
  font-size: 0.9rem;
  transition: transform 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.available-slot-card.expanded .available-slot-toggle-btn {
  transform: rotate(180deg);
}

.available-slot-remove-btn:hover {
  background: #da190b;
}

.available-slot-remove-btn:active {
  transform: scale(0.98);
}

.empty-slots-message {
  text-align: center;
  padding: clamp(20px, 8vw, 30px);
  color: #999;
  font-style: italic;
  font-size: clamp(0.9rem, 2vw, 1rem);
}

/* Mobile responsive adjustments */
@media (max-width: 640px) {
  .admin-container {
    margin: 12px auto;
    border-radius: 10px;
  }

  .all-booking-card {
    flex-direction: column;
    align-items: flex-start;
  }

  .booking-status-badge {
    align-self: flex-start;
  }

  .all-booking-card:not(.expanded) .booking-status-badge {
    margin-left: auto;
  }

  .booking-actions button {
    min-width: calc(50% - 6px);
  }
}

@media (max-width: 480px) {
  .admin-container {
    padding: 14px 10px;
  }

  .admin-slots {
    grid-template-columns: repeat(auto-fill, minmax(55px, 1fr));
  }

  .admin-slot {
    font-size: 0.7rem;
    padding: 6px 4px;
  }

  .booking-actions {
    flex-direction: column;
  }

  .booking-actions button {
    width: 100%;
  }

  .all-bookings-container {
    max-height: calc(70vh - 266px);
  }

  .available-slots-container {
    max-height: calc(70vh - 266px);
  }

  .player-profiles-container {
    max-height: calc(70vh - 266px);
  }

  #waitlistContainer {
    max-height: calc(70vh - 266px) !important;
  }
}

#allBookingsSection .refresh-info {
  font-size: 0.85rem;
  color: #666;
  margin-bottom: 10px;
  padding: 8px 12px;
  background: rgba(255,255,255,0.6);
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 8px;
}

#allBookingsSection .refresh-info i {
  animation: spin 2s linear infinite;
}

.all-booking-card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  transform: translateX(2px);
}

.all-booking-card.pending {
  border-left-color: #FF9800;
}

.all-booking-card.confirmed {
  border-left-color: #4CAF50;
}

.all-booking-card.expanded {
  flex-direction: column;
  align-items: flex-start;
  gap: 12px;
}

.booking-info {
  flex: 1;
  width: 100%;
}

.booking-date-time {
  font-weight: 600;
  color: #333;
  font-size: 0.95rem;
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.booking-date-time i {
  color: #4CAF50;
}

.booking-person {
  font-size: 0.85rem;
  color: #666;
  display: flex;
  align-items: center;
  gap: 6px;
}

.booking-status-badge {
  padding: 4px 10px;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
  margin-right: 10px;
}

.booking-status-badge.pending {
  background: #FFE0B2;
  color: #E65100;
}

.booking-status-badge.confirmed {
  background: #C8E6C9;
  color: #2E7D32;
}

.booking-actions {
  display: none;
  width: 100%;
  gap: 10px;
  margin-top: 10px;
}

.all-booking-card.expanded .booking-actions {
  display: flex;
}

.booking-actions button {
  flex: 1;
  padding: 8px 12px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.85rem;
  transition: all 0.2s ease;
}

.booking-actions .confirm {
  background: #4CAF50;
  color: white;
}

.booking-actions .confirm:hover {
  background: #45a049;
}

.booking-actions .delete {
  background: #f44336;
  color: white;
}

.booking-actions .delete:hover {
  background: #da190b;
}

.empty-bookings {
  text-align: center;
  padding: 30px 20px;
  color: #999;
  font-style: italic;
}

.empty-bookings i {
  font-size: 2rem;
  margin-bottom: 10px;
  display: block;
  opacity: 0.5;
}

/* Player Profiles - admin section (indigo theme) */
#playerProfilesSection {
  margin-top: clamp(20px, 5vh, 30px);
  padding: clamp(16px, 4vw, 24px);
  background: linear-gradient(135deg, #fbf8ff 0%, #f3f2ff 100%); /* light indigo */
  border-radius: 12px;
  box-shadow: 0 10px 26px rgba(99,102,241,0.06);
}
#playerProfilesSection h2 {
  margin: 0 0 15px 0;
  font-size: clamp(1.1rem, 4vw, 1.3rem);
  color: #312e81; /* indigo-800 */
  display: flex;
  align-items: center;
  gap: 10px;
}
.player-profiles-container {
  display: grid;
  gap: 12px;
  overflow-y: auto;
  padding-right: 8px;
  min-height: auto;
  height: auto;
  max-height: calc(100vh - 340px);
  grid-auto-rows: min-content;
}
.profile-card {
  padding: clamp(12px, 3vw, 14px);
  background: linear-gradient(180deg, #ffffff 0%, #faf8ff 100%);
  border-radius: 10px;
  border-left: 4px solid #6d28d9; /* indigo accent */
  box-shadow: 0 8px 30px rgba(99,102,241,0.06);
  display: flex;
  justify-content: flex-start;
  align-items: center;
  gap: 12px;
  cursor: pointer;
  transition: transform 150ms ease, box-shadow 150ms ease;
  max-width: 100%;
  width: 100%;
  box-sizing: border-box;
}
.profile-card:hover { transform: translateY(-2px); box-shadow: 0 12px 40px rgba(99,102,241,0.08); }
.profile-meta { color: #6b7280; font-size: 0.95rem; }
.profile-status { font-weight: 600; text-transform: none; padding: 6px 12px; border-radius: 20px; font-size: 0.78rem; white-space: nowrap; }
.profile-status.found { background: #ecfdf5; color: #065f46; }
.profile-status.missing { background: #fff1f2; color: #831843; }
.profile-status.checking { background: transparent; color: #6b7280; font-weight:600; display:flex; align-items:center; gap:8px; }
.checking-dots span { display: inline-block; margin-left: 2px; }


/* keep mobile-friendly spacing */
@media (max-width: 640px) {
  .profile-card { flex-direction: column; align-items: flex-start; gap: 8px; }
  .profile-status { align-self: flex-end; }
}

/* Collapsible admin sections */
.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 16px;
  cursor: pointer;
  border-radius: 10px;
  background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(250,250,250,0.6));
}
.section-header h2 { margin: 0; font-size: 1.05rem; display: flex; align-items: center; gap: 10px; }
.section-header:focus { outline: 3px solid rgba(59,130,246,0.12); outline-offset: 3px; }
.section-chevron {
  width: 18px; height: 18px; flex: 0 0 18px; display: inline-flex; align-items: center; justify-content: center; color: #6b7280; transition: transform 220ms cubic-bezier(.2,.9,.2,1);
}
.section-body { overflow: hidden; transition: height 260ms cubic-bezier(.2,.9,.2,1), opacity 180ms ease; will-change: height, opacity; }
.section-body-inner { padding-top: 12px; border-top: 1px solid rgba(15,23,42,0.04); border-radius: 0 0 10px 10px; }
.section-collapsed .section-chevron { transform: rotate(-90deg); }
.section-collapsed .section-body { opacity: 0; }

@media (max-width:640px){ .section-header { padding: 12px; } .section-header h2 { font-size: 1rem; } }

/* Summary Bar Styles */
.summary-card {
  background: #fff;
  border-radius: 6px;
  padding: 4px 2px;
  text-align: center;
  box-shadow: 0 1px 2px rgba(0,0,0,0.04);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.summary-card:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.08);
}
.summary-value {
  font-size: clamp(0.85rem, 2.5vw, 1rem);
  font-weight: 700;
  color: #2c3e50;
  line-height: 1;
  margin-bottom: 2px;
}
.summary-label {
  font-size: clamp(0.5rem, 1.2vw, 0.6rem);
  color: #6b7280;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.2px;
  line-height: 1.1;
}

/* Player Profiles modal (view-only) */
.pt-modal { 
  position: fixed; 
  inset: 0; 
  display: none; 
  align-items: center; 
  justify-content: center; 
  z-index: 12000; 
  top: 0; 
  left: 0; 
  right: 0; 
  bottom: 0; 
  width: 100%; 
  height: 100%; 
  padding: 20px; 
  box-sizing: border-box; 
}
.pt-modal.open { 
  display: flex; 
  position: fixed; 
}
/* Prevent zoom when modal opens on iOS */
body.modal-open { 
  overflow: hidden; 
  position: fixed; 
  width: 100%; 
  height: 100vh; 
}
/* Ensure proper stacking on iOS */
.pt-modal-overlay { 
  position: absolute; 
  inset: 0; 
  background: rgba(2,6,23,0.55); 
  backdrop-filter: blur(2px); 
  -webkit-backdrop-filter: blur(2px); 
}
/* Modal content with iOS-friendly sizing */
.pt-modal-content { 
  position: relative; 
  background: #fff; 
  width: min(90vw, 600px); 
  max-width: 90vw; 
  max-height: min(75vh, 70vh); 
  overflow-y: auto; 
  -webkit-overflow-scrolling: touch; 
  border-radius: 14px; 
  box-shadow: 0 30px 80px rgba(2,6,23,0.25); 
  padding: 22px; 
  z-index: 2; 
  border: 1px solid rgba(2,6,23,0.04); 
  box-sizing: border-box; 
}
/* iOS input styling to prevent zoom on focus */
input, select, textarea {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  font-size: 16px !important;
  -webkit-user-zoom: 1;
  -webkit-text-size-adjust: 100%;
  touch-action: manipulation;
}
input[type="date"], 
input[type="time"] {
  font-size: 16px !important;
}
input:focus, select:focus, textarea:focus {
  outline: 2px solid #0066ff;
  outline-offset: 2px;
}
/* Prevent iOS zoom on modal */
@supports (-webkit-touch-callout: none) {
  .pt-modal {
    -webkit-user-select: none;
    user-select: none;
  }
  input, select, textarea {
    font-size: 16px;
  }
}
/* Make the modal close button corner-anchored and non-stretching (fixes full-width 'X' issue) */
.pt-modal-close {
  position: absolute;
  right: 14px;
  top: 12px;
  border: none;
  background: transparent;
  font-size: 20px;
  line-height: 1;
  cursor: pointer;
  color: #374151;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: auto !important;
  min-width: 0 !important;
  height: 36px;
  padding: 0 10px;
  border-radius: 8px;
  z-index: 3; /* sit above modal content */
}
.pt-modal-close:focus { outline: 3px solid rgba(59,130,246,0.18); outline-offset: 2px; }
.pt-modal-close:hover { background: rgba(2,6,23,0.04); }

/* Ensure heading/body styles remain unchanged */
.pt-modal h3 { margin: 0 0 12px 0; font-size: 1.1rem; color: #0f172a; }
.pt-modal-body { display: grid; gap: 12px; padding-bottom: 6px; max-height: calc(70vh - 200px); overflow-y: auto; -webkit-overflow-scrolling: touch; }
.pt-modal-body input, .pt-modal-body select, .pt-modal-body textarea { font-size: 16px !important; -webkit-appearance: none; -moz-appearance: none; appearance: none; }
.pt-modal-body input[type="date"], .pt-modal-body input[type="time"] { font-size: 16px !important; }
.pt-modal-body label { font-size: 14px; }

/* Responsive modal fields: limit width and center on mobile */
.pt-modal-body input,
.pt-modal-body select,
.pt-modal-body textarea {
  max-width: 400px;
  width: 100%;
  margin-left: auto;
  margin-right: auto;
  box-sizing: border-box;
}

@media (max-width: 600px) {
  .pt-modal-body input,
  .pt-modal-body select,
  .pt-modal-body textarea {
    max-width: 95vw;
    min-width: 0;
    font-size: 15px !important;
  }
}
.pt-row { display: flex; gap: 16px; align-items: flex-start; padding: 12px; border-radius: 8px; border: 1px solid rgba(15,23,42,0.04); background: #fff; }
.pt-label { min-width: 160px; color: #374151; font-weight: 700; font-size: 0.9rem; }

/* Player Notes styling (admin modal + standalone notes page) */
.notes-empty { color: #6b7280; padding: 18px 12px; text-align: center; border-radius: 8px; background: #fbfdff; border: 1px dashed rgba(15,23,42,0.04); }
.notes-list { display: grid; gap: 12px; margin-top: 6px; }
.note-item { background: #fff; border-radius: 10px; padding: 12px; border: 1px solid rgba(15,23,42,0.04); box-shadow: 0 2px 8px rgba(2,6,23,0.03); }
.note-meta { display:flex; gap:12px; align-items:center; color:#6b7280; font-size:0.88rem; margin-bottom:8px; }
.note-author { font-weight:700; color:#111827; }
.note-date { color:#6b7280; font-size:0.86rem; }
.note-content { color:#111827; line-height:1.45; white-space:pre-wrap; }
.notes-form { display: grid; gap:10px; margin-top:12px; }
.notes-form textarea { width:100%; min-height:90px; padding:12px; border-radius:8px; border:1px solid rgba(15,23,42,0.06); background:#fff; resize:vertical; font-family:inherit; }
.notes-actions { display:flex; gap:10px; align-items:center; justify-content:flex-end; margin-top:6px; }
.notes-actions .btn { padding:8px 12px; border-radius:8px; }
@media (max-width:640px){ .note-meta { flex-direction: column; align-items:flex-start; gap:6px; } }

.pt-value { color: #374151; font-size: 0.95rem; white-space: pre-wrap; }
.pt-row.missing-field { background: #fff7f7; border-left: 4px solid #ffb4b4; }
.pt-actions { display:flex; gap:12px; justify-content:flex-end; margin-top:12px; }
.pt-actions .btn { background: #111827; color: #fff; padding: 8px 12px; border-radius: 8px; text-decoration: none; font-weight:600; }
.pt-meta { margin-top: 8px; color: #6b7280; font-size: 0.88rem; }
@media (max-width:640px){ .pt-row { flex-direction: column; } .pt-label { min-width: 0; width: 100%; } .pt-actions { justify-content: stretch; } }

</style>
</head>
<body>

<!-- Admin Login Modal -->
<style>
  #adminLoginModal .custom-checkbox {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    user-select: none;
  }
  
  #adminLoginModal .custom-checkbox input[type="checkbox"] {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    width: 20px;
    height: 20px;
    border: 2px solid #4CAF50;
    border-radius: 4px;
    cursor: pointer;
    position: relative;
    background: white;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }
  
  #adminLoginModal .custom-checkbox input[type="checkbox"]:hover {
    border-color: #45a049;
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
  }
  
  #adminLoginModal .custom-checkbox input[type="checkbox"]:checked {
    background: #4CAF50;
    border-color: #4CAF50;
  }
  
  #adminLoginModal .custom-checkbox input[type="checkbox"]:checked::after {
    content: 'âœ“';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 14px;
    font-weight: bold;
  }
  
  #adminLoginModal .custom-checkbox span {
    color: #555;
    font-size: 14px;
  }

  /* Summary bar buttons - override global button styles */
  #summaryBar button {
    min-height: auto !important;
    padding: 0px 2px !important;
    margin: 0 !important;
    height: 24px !important;
  }
</style>
<div id="adminLoginModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 99999; align-items: center; justify-content: center;">
  <div style="background: white; padding: 32px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
    <img src="NewLogo.png" alt="Logo" style="display: block; margin: 0 auto 20px; width: 80%; max-width: 300px;">
    <h2 style="margin: 0 0 24px 0; text-align: center; color: #2c3e50;">Admin Login</h2>
    <form id="adminLoginForm">
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; color: #333; font-weight: 600;">Username</label>
        <input type="text" id="adminUsername" required style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
      </div>
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; color: #333; font-weight: 600;">Password</label>
        <input type="password" id="adminPassword" required style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
      </div>
      <div style="margin-bottom: 20px;">
        <label for="adminRememberMe" class="custom-checkbox">
          <input type="checkbox" id="adminRememberMe">
          <span>Remember me</span>
        </label>
      </div>
      <button type="submit" style="width: 100%; padding: 12px; background: #000000; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: background 0.3s;">
        Login
      </button>
      <div id="adminLoginError" style="display: none; margin-top: 16px; padding: 12px; background: #ffebee; color: #c62828; border-radius: 8px; text-align: center; font-size: 14px;"></div>
    </form>
  </div>
</div>

<!-- Logout Button (hidden by default, shown after login) -->
<div id="adminLogoutContainer" style="display: none; position: absolute; top: -5px; right: 25px; z-index: 10001;">
  <button id="adminLogoutBtn" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
    <i class="fas fa-sign-out-alt"></i> Logout
  </button>
</div>

<div class="admin-container">
  <img src="NewLogo.png" alt="Logo" style="display:block;margin:0 auto 2px;width:70vw;max-width:600px;">
  <h1>ADMIN - MANAGE SLOTS & BOOKINGS</h1>

  <!-- Summary Bar -->
      <!-- Settings Button -->
  <!-- Admin Settings Modal for Expiry Config -->
  <div id="adminSettingsModal" class="pt-modal" style="display:none;z-index:13000;" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="pt-modal-overlay" id="adminSettingsModalOverlay"></div>
    <div class="pt-modal-content" role="document" aria-labelledby="adminSettingsModalTitle" style="max-width: 420px;">
      <button class="pt-modal-close" id="adminSettingsModalClose" aria-label="Close dialog" style="font-family: 'Inter', Arial, sans-serif;">&#215;</button>
      <h3 id="adminSettingsModalTitle">Booking Expiry Settings</h3>
      <div class="pt-modal-body" style="display:flex;flex-direction:column;gap:16px;">
        <div>
          <label for="expiryHours" style="font-weight:600;">Booking Expiry Time</label>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <input type="number" id="expiryHours" min="0" max="168" value="0" style="width:60px;padding:8px;border-radius:6px;border:1px solid #ccc;"> <span>h</span>
            <input type="number" id="expiryMinutes" min="0" max="59" value="0" style="width:60px;padding:8px;border-radius:6px;border:1px solid #ccc;"> <span>m</span>
            <input type="number" id="expirySeconds" min="0" max="59" value="0" style="width:60px;padding:8px;border-radius:6px;border:1px solid #ccc;"> <span>s</span>
          </div>
          <div id="currentExpiryDisplay" style="margin-top:8px;color:#666;font-size:0.95em;"></div>
        </div>
        <div>
          <label for="offerExpiryHours" style="font-weight:600;">Waitlist Offer Expiry Time</label>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
            <input type="number" id="offerExpiryHours" min="0" max="168" value="0" style="width:60px;padding:8px;border-radius:6px;border:1px solid #ccc;"> <span>h</span>
            <input type="number" id="offerExpiryMinutes" min="0" max="59" value="0" style="width:60px;padding:8px;border-radius:6px;border:1px solid #ccc;"> <span>m</span>
            <input type="number" id="offerExpirySeconds" min="0" max="59" value="0" style="width:60px;padding:8px;border-radius:6px;border:1px solid #ccc;"> <span>s</span>
          </div>
          <div id="currentOfferExpiryDisplay" style="margin-top:8px;color:#666;font-size:0.95em;"></div>
        </div>
        <div class="pt-actions" style="display:flex;gap:12px;margin-top:8px;">
          <button class="btn" id="saveExpiryBtn" style="flex:1;background:#6366f1;color:white;">Save</button>
          <button class="btn" id="cancelExpiryBtn" style="flex:1;background:transparent;color:#666;border:1px solid #ccc;">Cancel</button>
        </div>
        <div style="margin-top:16px;">
          <button id="clearDataBtn" style="width:100%;background:#e74c3c;color:white;padding:12px 0;border:none;border-radius:8px;font-weight:700;font-size:1rem;display:flex;align-items:center;justify-content:center;gap:8px;">
            <i class="fas fa-trash"></i> Clear ALL Data
          </button>
          <div style="margin-top:8px;font-size:0.92em;color:#b91c1c;text-align:center;">This will delete ALL sessions, bookings, waitlist entries, player profiles, and players. This cannot be undone.</div>
        </div>
        <div style="margin-top:8px;">
          <button id="sendTestEmailsBtn" style="width:100%;background:#6366f1;color:white;padding:12px 0;border:none;border-radius:8px;font-weight:700;font-size:1rem;display:flex;align-items:center;justify-content:center;gap:8px;">
            <i class="fas fa-envelope"></i> Send Test Emails
          </button>
        </div>
        <div id="expirySettingsFeedback" style="margin-top:8px;font-size:0.95em;"></div>
      </div>
    </div>
  </div>
  <div id="summaryBar" style="margin: 12px 0; padding: clamp(8px, 3vw, 16px); background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.06); display: flex; flex-direction: column; gap: clamp(6px, 1.5vw, 10px); width: 100%; box-sizing: border-box;">
    <!-- Summary Cards -->
    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: clamp(4px, 1vw, 8px); width: 100%; box-sizing: border-box;">
      <div style="padding: clamp(12px, 2vw, 16px); background: white; border-radius: 6px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.04); box-sizing: border-box; min-width: 0; overflow: hidden;">
        <div style="font-weight: 700; font-size: clamp(1.1rem, 4vw, 1.5rem); color: #2c3e50;" id="summaryWeeklySessions">-</div>
        <div style="font-size: clamp(0.6rem, 1.6vw, 0.75rem); color: #7f8c8d; margin-top: 0px; font-weight: 500; line-height: 1.2;">This Week</div>
      </div>
      <div style="padding: clamp(12px, 2vw, 16px); background: white; border-radius: 6px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.04); box-sizing: border-box; min-width: 0; overflow: hidden;">
        <div style="font-weight: 700; font-size: clamp(1.1rem, 4vw, 1.5rem); color: #2c3e50;" id="summaryTotalBookings">-</div>
        <div style="font-size: clamp(0.6rem, 1.6vw, 0.75rem); color: #7f8c8d; margin-top: 0px; font-weight: 500; line-height: 1.2;">Bookings</div>
      </div>
      <div style="padding: clamp(12px, 2vw, 16px); background: white; border-radius: 6px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.04); box-sizing: border-box; min-width: 0; overflow: hidden;">
        <div style="font-weight: 700; font-size: clamp(1.1rem, 4vw, 1.5rem); color: #2c3e50;" id="summaryPendingPayments">-</div>
        <div style="font-size: clamp(0.6rem, 1.6vw, 0.75rem); color: #7f8c8d; margin-top: 0px; font-weight: 500; line-height: 1.2;">Pending</div>
      </div>
      <div style="padding: clamp(12px, 2vw, 16px); background: white; border-radius: 6px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.04); box-sizing: border-box; min-width: 0; overflow: hidden;">
        <div style="font-weight: 700; font-size: clamp(1.1rem, 4vw, 1.5rem); color: #2c3e50;" id="summaryConfirmedPayments">-</div>
        <div style="font-size: clamp(0.6rem, 1.6vw, 0.75rem); color: #7f8c8d; margin-top: 0px; font-weight: 500; line-height: 1.2;">Confirmed</div>
      </div>
      <div style="padding: clamp(12px, 2vw, 16px); background: white; border-radius: 6px; text-align: center; box-shadow: 0 1px 2px rgba(0,0,0,0.04); box-sizing: border-box; min-width: 0; overflow: hidden;">
        <div style="font-weight: 700; font-size: clamp(1.1rem, 4vw, 1.5rem); color: #2c3e50;" id="summaryWaitlistTotal">-</div>
        <div style="font-size: clamp(0.6rem, 1.6vw, 0.75rem); color: #7f8c8d; margin-top: 0px; font-weight: 500; line-height: 1.2;">Waitlist</div>
      </div>
    </div>
    
    <!-- Controls Row: Table Switch + Sync to Calendar + Clear Data Button + Analytics Button -->
    <div style="display: flex; align-items: center; gap: clamp(4px, 1.5vw, 8px); justify-content: flex-start; width: 100%; box-sizing: border-box; flex-wrap: nowrap;">
      <!-- Switch -->
      <div style="display: flex; align-items: center; gap: clamp(4px, 1vw, 6px); white-space: nowrap; flex-shrink: 0; min-width: 0;">
        <label class="switch" style="margin: 0;">
          <input type="checkbox" id="viewModeSwitch">
          <span class="slider"></span>
        </label>
        <span style="font-size: clamp(0.55rem, 1.2vw, 0.7rem); color: #7f8c8d; font-weight: 500;">Table</span>
      </div>
      
      <!-- Sync to Calendar Button -->
      <button id="syncToCalendarBtn" style="padding: 0px 2px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 8px; white-space: nowrap; display: flex; align-items: center; justify-content: center; gap: 3px; transition: background 0.2s ease; flex-shrink: 1; line-height: 0.8; height: 18px;">
        <i class="fas fa-calendar" style="flex-shrink: 0; font-size: 0.6rem;"></i> <span style="overflow: hidden; text-overflow: ellipsis; font-size: 8px;">Sync</span>
      </button>
      
      
      <!-- Analytics Button (smaller, secondary) -->
      <button id="analyticsBtn" style="padding: 0px 2px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 8px; white-space: nowrap; display: flex; align-items: center; justify-content: center; gap: 3px; transition: background 0.2s ease; opacity: 0.8; flex-shrink: 1; line-height: 0.8; height: 18px;">
        <i class="fas fa-chart-bar" style="flex-shrink: 0; font-size: 0.6rem;"></i> <span style="overflow: hidden; text-overflow: ellipsis; font-size: 8px;">Analytics</span>
      </button>
      <!-- Settings Button (styled like others) -->
      <button id="openSettingsModal" style="padding: 0px 2px; background: #6366f1; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 8px; white-space: nowrap; display: flex; align-items: center; justify-content: center; gap: 3px; transition: background 0.2s ease; flex-shrink: 1; line-height: 0.8; height: 18px;">
        <i class="fas fa-cog" style="flex-shrink: 0; font-size: 0.6rem;"></i> <span style="overflow: hidden; text-overflow: ellipsis; font-size: 8px;">Settings</span>
      </button>

      <!-- NEW BUTTON: Customize as needed -->
      <button id="activityCentreBtn" style="padding: 0px 2px; background: #111; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 8px; white-space: nowrap; display: flex; align-items: center; justify-content: center; gap: 3px; transition: background 0.2s ease; flex-shrink: 1; line-height: 0.8; height: 18px;">
        <i class="fas fa-bell" style="flex-shrink: 0; font-size: 0.6rem; color: white;"></i> <span style="overflow: hidden; text-overflow: ellipsis; font-size: 8px;">Activity</span>
      </button>
    <script>
    // Activity Modal logic
    const activityCentreBtn = document.getElementById('activityCentreBtn');
    // Add red dot indicator to Activity button if unseen notifications exist
    function updateActivityCentreIndicator() {
      fetch('php/getActivityLog.php', { cache: 'no-store' })
        .then(res => res.json())
        .then(logs => {
          const hasUnseen = Array.isArray(logs) && logs.some(entry => entry.seen === false || entry.seen === undefined);
          let dot = document.getElementById('activityCentreBtnDot');
          if (hasUnseen) {
            if (!dot) {
              dot = document.createElement('span');
              dot.id = 'activityCentreBtnDot';
              dot.style.cssText = 'position:absolute;top:-6px;right:-6px;width:13px;height:13px;background:#ef4444;border-radius:50%;display:inline-block;border:2px solid #fff;z-index:10; box-shadow:0 2px 6px rgba(0,0,0,0.12);';
              activityCentreBtn.style.position = 'relative';
              activityCentreBtn.appendChild(dot);
            }
            dot.style.display = 'inline-block';
          } else if (dot) {
            dot.style.display = 'none';
          }
        });
    }
    // Initial check on page load
    updateActivityCentreIndicator();
    const activityCentreModal = document.getElementById('activityCentreModal');
    const activityCentreModalOverlay = document.getElementById('activityCentreModalOverlay');
    const activityCentreModalClose = document.getElementById('activityCentreModalClose');

    // Dynamic Activity Log Loader
    function renderActivityLog(logs) {
      const activityCentreBody = document.getElementById('activityCentreBody');
      if (!Array.isArray(logs) || logs.length === 0) {
        activityCentreBody.innerHTML = '<div style="color:#888; font-size:0.98em; text-align:center; padding: 18px 0 0 0;">No notifications.</div>';
        return;
      }
      activityCentreBody.innerHTML = logs.map(entry => {
        const date = entry.timestamp ? new Date(entry.timestamp) : null;
        const timeStr = date ? date.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' }) : '';
        const unseen = entry.seen === false || entry.seen === undefined;
        return `
          <div class="notification-item" style="display: flex; align-items: flex-start; gap: 0; padding: 14px 24px; border-bottom: 1px solid #e5e7eb; background: ${unseen ? '#e0e7ef' : '#f1f5f9'};">
            <div style="flex:1;">
              <div style="font-weight:${unseen ? '700' : '600'}; font-size:1rem; color:#222;">${entry.title || ''}</div>
              <div style="font-size:0.93rem; color:#334155; margin-top:2px;">${entry.message || ''}</div>
              <div style="font-size:0.8rem; color:#64748b; margin-top:4px;">${timeStr}</div>
            </div>
          </div>
        `;
      }).join('');
      // Scroll to latest notification (bottom)
      setTimeout(() => {
        activityCentreBody.scrollTop = activityCentreBody.scrollHeight;
      }, 0);
    }

    async function loadActivityLog() {
      const activityCentreBody = document.getElementById('activityCentreBody');
      if (!activityCentreBody) return;
      activityCentreBody.innerHTML = '<div style="color:#888; font-size:0.98em; text-align:center; padding: 18px 0 0 0;">Loading notifications...</div>';
      try {
        const res = await fetch('php/getActivityLog.php', { cache: 'no-store' });
        if (!res.ok) throw new Error('Failed to load activity log');
        const logs = await res.json();
        renderActivityLog(logs);
      } catch (e) {
        activityCentreBody.innerHTML = '<div style="color:#ef4444; font-size:0.98em; text-align:center; padding: 18px 0 0 0;">Error loading notifications.</div>';
      }
    }

    if (activityCentreBtn && activityCentreModal) {
      activityCentreBtn.onclick = () => {
        activityCentreModal.style.display = 'flex';
        activityCentreModal.setAttribute('aria-hidden', 'false');
        loadActivityLog();
      };
    }
    if (activityCentreModalOverlay && activityCentreModal) {
      activityCentreModalOverlay.onclick = async () => {
        activityCentreModal.style.display = 'none';
        activityCentreModal.setAttribute('aria-hidden', 'true');
        try {
          await fetch('php/setAllActivitySeen.php', { method: 'POST', cache: 'no-store' });
        } catch (e) {}
        updateActivityCentreIndicator();
      };
    }
    if (activityCentreModalClose && activityCentreModal) {
      activityCentreModalClose.onclick = async () => {
        activityCentreModal.style.display = 'none';
        activityCentreModal.setAttribute('aria-hidden', 'true');
        try {
          await fetch('php/setAllActivitySeen.php', { method: 'POST', cache: 'no-store' });
        } catch (e) {}
        updateActivityCentreIndicator();
      };
    }
    </script>
    </div>
  </div>

  <button id="openSessionModal" style="margin-top: 12px; margin-bottom: 20px; background: #2a2a2a; color: white; width: 100%; padding: clamp(10px, 3vw, 14px); border: none; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: clamp(0.9rem, 2.5vw, 1rem);">
    <i class="fas fa-plus"></i> Create Session
  </button>

  <div id="hiddenOldForms" style="display: none;">
  <div id="singleSessionForm" style="display: none; margin-top: 20px; padding: 16px; background: transparent; border-radius: 10px; border: 2px solid #333; color: #333;">
    <label style="color: #333; font-weight: 600;">Select Date</label>
    <input type="date" id="adminDate" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <label style="color: #333; margin-top: 12px; display: block; font-weight: 600;">Slot Title</label>
    <input type="text" id="slotTitle" placeholder="e.g., Basketball Training, Court Rental" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <label style="color: #333; margin-top: 12px; display: block; font-weight: 600;">Number of Spots</label>
    <input type="number" id="numberOfSpots" placeholder="e.g., 10" min="1" value="1" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <label style="color: #333; margin-top: 12px; display: block; font-weight: 600;">Session Type</label>
    <select id="sessionType" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">
      <option value="group">Group</option>
      <option value="solo">Solo</option>
    </select>

    <label style="color: #333; margin-top: 12px; display: block; font-weight: 600;">Session Start Time</label>
    <input type="time" id="sessionStartTime" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <label style="color: #333; margin-top: 12px; display: block; font-weight: 600;">Session Duration (minutes)</label>
    <input type="number" id="sessionDuration" placeholder="e.g., 40" min="15" max="240" value="40" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <label style="color: #333; margin-top: 12px; display: block; font-weight: 600;">Price (Â£)</label>
    <input type="number" id="sessionPrice" placeholder="e.g., 15.00" min="0" step="0.01" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <label style="color: #333; margin-top: 12px; display: block; font-weight: 600;">Location</label>
    <input type="text" id="sessionLocation" placeholder="e.g., Main Studio, Room 101" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <div style="display: flex; gap: 8px; margin-top: 16px;">
      <button id="createSlot" style="flex: 1; background: #FF9800; color: white; padding: clamp(10px, 3vw, 14px); border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: clamp(0.9rem, 2.5vw, 1rem);">Create Slot</button>
      <button id="cancelSingleSession" style="flex: 1; background: transparent; color: #666; padding: clamp(10px, 3vw, 14px); border: 1px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: clamp(0.9rem, 2.5vw, 1rem);">Cancel</button>
    </div>
  </div>

  <div id="blockSessionForm" style="display: none; margin-top: 20px; padding: 16px; background: transparent; border-radius: 10px; border: 2px solid #333; color: #333;">
      <style>
        #blockSessionForm input,
        #blockSessionForm select,
        #blockSessionForm textarea {
          max-width: 400px;
          width: 100%;
          margin-left: auto;
          margin-right: auto;
          box-sizing: border-box;
          min-width: 0;
        }
        @media (max-width: 700px) {
          #blockSessionForm input,
          #blockSessionForm select,
          #blockSessionForm textarea,
          #blockSessionPreviewRows .block-session-row {
            max-width: 100vw !important;
            width: 100vw !important;
            min-width: 0 !important;
            font-size: 15px !important;
            box-sizing: border-box !important;
            margin-left: 0 !important;
            margin-right: 0 !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
          }
        }
      </style>
    <label style="color: #333; font-weight: 600;">Block Title</label>
    <input type="text" id="blockTitle" placeholder="e.g., Basketball Training Series" style="width:80vw;min-width:0;max-width:100%;padding:clamp(10px,3vw,14px);margin-top:8px;border-radius:8px;border:1px solid #ccc;font-size:clamp(0.9rem,2.5vw,1rem);font-family:inherit;background:#fff;color:#333;">

    <label style="margin-top: 12px; color: #333; display: block; font-weight: 600;">First Session Date</label>
    <input type="date" id="blockFirstDate" style="width:80vw;min-width:0;max-width:100%;padding:clamp(10px,3vw,14px);margin-top:8px;border-radius:8px;border:1px solid #ccc;font-size:clamp(0.9rem,2.5vw,1rem);font-family:inherit;background:#fff;color:#333;">

    <label style="margin-top: 12px; color: #333; display: block; font-weight: 600;">Start Time</label>
    <input type="time" id="blockStartTime" style="width:80vw;min-width:0;max-width:100%;padding:clamp(10px,3vw,14px);margin-top:8px;border-radius:8px;border:1px solid #ccc;font-size:clamp(0.9rem,2.5vw,1rem);font-family:inherit;background:#fff;color:#333;">

    <label style="margin-top: 12px; color: #333; display: block; font-weight: 600;">Number of Sessions</label>
    <input type="number" id="blockNumberOfSessions" placeholder="e.g., 4" min="1" max="12" value="4" style="width:80vw;min-width:0;max-width:100%;padding:clamp(10px,3vw,14px);margin-top:8px;border-radius:8px;border:1px solid #ccc;font-size:clamp(0.9rem,2.5vw,1rem);font-family:inherit;background:#fff;color:#333;">

    <label style="margin-top: 12px; color: #333; display: block; font-weight: 600;">Duration (minutes)</label>
    <input type="number" id="blockDuration" placeholder="e.g., 40" min="15" max="240" value="40" style="width:80vw;min-width:0;max-width:100%;padding:clamp(10px,3vw,14px);margin-top:8px;border-radius:8px;border:1px solid #ccc;font-size:clamp(0.9rem,2.5vw,1rem);font-family:inherit;background:#fff;color:#333;">

    <label style="margin-top: 12px; color: #333; display: block; font-weight: 600;">Number of Spots</label>
    <input type="number" id="blockNumberOfSpots" placeholder="e.g., 10" min="1" value="1" style="width:80vw;min-width:0;max-width:100%;padding:clamp(10px,3vw,14px);margin-top:8px;border-radius:8px;border:1px solid #ccc;font-size:clamp(0.9rem,2.5vw,1rem);font-family:inherit;background:#fff;color:#333;">

    <label style="margin-top: 12px; color: #333; display: block; font-weight: 600;">Session Type</label>
    <select id="blockSessionType" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">
      <option value="group">Group</option>
      <option value="solo">Solo</option>
    </select>

    <label style="margin-top: 12px; color: #333; display: block; font-weight: 600;">Price (Â£)</label>
    <input type="number" id="blockPrice" placeholder="e.g., 60.00" min="0" step="0.01" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <label style="display: block; color: #555; font-weight: 600; margin-bottom: 8px; font-size: clamp(0.9rem, 2vw, 1rem);">Location</label>
    <input type="text" id="blockLocation" placeholder="e.g., Main Studio, Room 101" style="width: 100%; padding: clamp(10px, 3vw, 14px); margin-top: 8px; border-radius: 8px; border: 1px solid #ccc; font-size: clamp(0.9rem, 2.5vw, 1rem); font-family: inherit; background: #fff; color: #333;">

    <div style="display: flex; gap: 8px; margin-top: 16px;">
      <button id="createBlockSession" style="flex: 1; background: #FF9800; color: white; padding: clamp(10px, 3vw, 14px); border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: clamp(0.9rem, 2.5vw, 1rem);">Create Block Session</button>
      <button id="cancelBlockSession" style="flex: 1; background: transparent; color: #666; padding: clamp(10px, 3vw, 14px); border: 1px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: clamp(0.9rem, 2.5vw, 1rem);">Cancel</button>
    </div>
    <div id="blockSessionPreviewText" style="margin-top:18px; text-align:center; color:#6366f1; font-weight:600; font-size:1.05rem; display:block;">preview</div>
  </div>
  </div>

  <div id="createdSlotsList" style="margin-top: 12px; margin-bottom: 20px; padding: 12px; background: #f5f5f5; border-radius: 8px; display: none;">
    <label style="font-weight: 600; margin-top: 0; display:block; max-width:90vw; width:90vw; margin-left:auto; margin-right:auto;">Created Slots for This Date:</label>
    <div id="createdSlotsContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; max-width:90vw; width:90vw; margin-left:auto; margin-right:auto;"></div>
  </div>

  <div id="allAvailableSlotsSection">
    <h2><i class="fas fa-list-check"></i> ALL SESSIONS</h2>
    <div class="available-slots-container" id="allAvailableSlots"></div>
  </div>

  <div id="allBookingsSection" style="margin-top: clamp(20px, 5vh, 30px); padding: clamp(16px, 4vw, 24px); background: linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%); border-radius: 12px; box-shadow: 0 8px 20px rgba(15,23,42,0.05);">
    <h2 style="margin: 0 0 15px 0; font-size: clamp(1.1rem, 4vw, 1.3rem); color: #333; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;"><i class="fas fa-calendar-check"></i> ALL BOOKINGS</h2>
    <div class="all-bookings-container" id="allBookings"></div>
  </div>

  <div id="waitlistSection" style="margin-top: clamp(20px, 5vh, 30px); padding: clamp(16px, 4vw, 24px); background: linear-gradient(135deg,#f7fafc 0%,#eef2f7 100%); border-radius: 12px; box-shadow: 0 8px 20px rgba(15,23,42,0.05);">
    <h2 style="margin: 0 0 15px 0; font-size: clamp(1.1rem, 4vw, 1.3rem); color: #334155; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
      <i class="fas fa-hourglass-end"></i> WAITLIST MANAGEMENT
    </h2>
    <div id="waitlistContainer" style="display: grid; gap: 12px; overflow-y: auto; padding-right: 8px; min-height: auto; height: auto; width: 100%; max-height: calc(100vh - 340px);"></div>
    <div id="emptyWaitlist" style="text-align: center; padding: clamp(20px, 8vw, 40px); color: #999; font-style: italic; font-size: clamp(0.9rem, 2vw, 1rem);">
      <i class="fas fa-inbox" style="font-size: clamp(1.5rem, 8vw, 2.5rem); margin-bottom: 10px; display: block; opacity: 0.5;"></i>
      No sessions with waitlists
    </div>
  </div>

  <div id="customEmailSection" style="margin-top: clamp(20px, 5vh, 30px); padding: clamp(16px, 4vw, 24px); background: linear-gradient(135deg,#fff8db 0%,#fffdf6 100%); border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.06);">
    <h2 style="margin: 0 0 15px 0; font-size: clamp(1.1rem, 4vw, 1.3rem); color: #333; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
      <i class="fas fa-envelope"></i> CUSTOM EMAIL
    </h2>
    
    <form id="customEmailForm" style="display: flex; flex-direction: column; gap: 12px;">
      <div>
        <label style="display: block; color: #555; font-weight: 600; margin-bottom: 8px; font-size: clamp(0.9rem, 2vw, 1rem);">Message</label>
        <textarea id="customEmailMessage" placeholder="Write your message here..." style="width: 100%; padding: clamp(10px, 3vw, 14px); border-radius: 8px; border: 1px solid #d1d5db; font-size: clamp(0.9rem, 2vw, 1rem); font-family: inherit; background: #fff; color: #333; min-height: 100px; resize: vertical;"></textarea>
      </div>

      <div>
        <label style="display: block; color: #555; font-weight: 600; margin-bottom: 8px; font-size: clamp(0.9rem, 2vw, 1rem);">Send To</label>
        <select id="customEmailRecipient" style="width: 100%; padding: clamp(10px, 3vw, 14px); border-radius: 8px; border: 1px solid #d1d5db; font-size: clamp(0.9rem, 2vw, 1rem); font-family: inherit; background: #fff; color: #333;">
          <option value="">-- Select a recipient --</option>
          <option value="all">All Users</option>
          <option value="saved">Players (from Player Profiles)</option>
          <option value="new">New Email Address</option>
        </select>
      </div>

      <div id="savedEmailsContainer" style="display: none;">
        <label style="display: block; color: #555; font-weight: 600; margin-bottom: 8px; font-size: clamp(0.9rem, 2vw, 1rem);">Select players (multiple allowed)</label>
        <select id="customEmailSavedList" multiple size="6" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #d1d5db; font-size: 13px; font-family: inherit; background: #fff; color: #333;">
          <option value="">-- Select players --</option>
        </select>
        <div class="small muted" style="margin-top:8px">Tip: hold Ctrl/Cmd to select multiple players, or use Shift for range selection.</div>
      </div>

      <div id="newEmailContainer" style="display: none;">
        <label style="display: block; color: #555; font-weight: 600; margin-bottom: 8px; font-size: clamp(0.9rem, 2vw, 1rem);">Email Address</label>
        <input type="email" id="customEmailNewAddress" placeholder="user@example.com" style="width: 100%; padding: clamp(10px, 3vw, 14px); border-radius: 8px; border: 1px solid #d1d5db; font-size: clamp(0.9rem, 2vw, 1rem); font-family: inherit; background: #fff; color: #333;">
      </div>

      <div style="display: flex; gap: 8px; margin-top: 16px;">
        <button type="submit" id="customEmailSendBtn" style="flex: 1; background: #ca8a04; color: white; padding: clamp(10px, 3vw, 14px); border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: clamp(0.9rem, 2vw, 1rem); transition: background 0.3s;">Send Email</button>
        <button type="reset" id="customEmailResetBtn" style="flex: 1; background: transparent; color: #ca8a04; padding: clamp(10px, 3vw, 14px); border: 2px solid #ca8a04; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: clamp(0.9rem, 2vw, 1rem); transition: all 0.3s;">Clear</button>
      </div>
    </form>
  </div>
</div>

<script>

// ========== ADMIN AUTHENTICATION SYSTEM ==========
(async function initAdminAuth() {
  const loginModal = document.getElementById('adminLoginModal');
  const loginForm = document.getElementById('adminLoginForm');
  const usernameInput = document.getElementById('adminUsername');
  const passwordInput = document.getElementById('adminPassword');
  const rememberMeCheckbox = document.getElementById('adminRememberMe');
  const loginError = document.getElementById('adminLoginError');
  const logoutContainer = document.getElementById('adminLogoutContainer');
  const logoutBtn = document.getElementById('adminLogoutBtn');
  const adminContainer = document.querySelector('.admin-container');
  
  let adminCredentials = null;
  
  // Fetch admin credentials from PHP (which reads from environment variables)
  async function fetchAdminCredentials() {
    try {
      const response = await fetch('php/getAdminConfig.php?t=' + Date.now());
      if (!response.ok) throw new Error('Failed to fetch credentials');
      adminCredentials = await response.json();
      console.log('Admin credentials loaded successfully');
    } catch (error) {
      console.error('Error fetching admin credentials:', error);
      // Fallback to default credentials if fetch fails
      adminCredentials = {
        username: 'bao@hooptheory.co.uk',
        password: 'Dangbongro.72'
      };
    }
  }
  
  // Check if user is authenticated
  function isAuthenticated() {
    return localStorage.getItem('adminAuthed') === 'true';
  }
  
  // Show login modal
  function showLoginModal() {
    loginModal.style.display = 'flex';
    adminContainer.style.display = 'none';
    logoutContainer.style.display = 'none';
    usernameInput.focus();
  }
  
  // Hide login modal and show admin interface
  function hideLoginModal() {
    loginModal.style.display = 'none';
    adminContainer.style.display = 'block';
    logoutContainer.style.display = 'block';
  }
  
  // Handle login
  async function handleLogin(event) {
    event.preventDefault();
    
    const username = usernameInput.value.trim();
    const password = passwordInput.value.trim();
    const rememberMe = rememberMeCheckbox.checked;
    
    // Validate credentials
    if (username === adminCredentials.username && password === adminCredentials.password) {
      // Successful login
      if (rememberMe) {
        localStorage.setItem('adminAuthed', 'true');
      }
      
      hideLoginModal();
      loginError.style.display = 'none';
      
      // Clear form
      loginForm.reset();
      
      console.log('Admin login successful');
    } else {
      // Failed login
      loginError.textContent = 'Incorrect username or password';
      loginError.style.display = 'block';
      passwordInput.value = '';
      passwordInput.focus();
    }
  }
  
  // Handle logout
  function handleLogout() {
    localStorage.removeItem('adminAuthed');
    location.reload();
  }
  
  // Initialize authentication
  await fetchAdminCredentials();
  
  if (isAuthenticated()) {
    hideLoginModal();
  } else {
    showLoginModal();
  }
  
  // Event listeners
  loginForm.addEventListener('submit', handleLogin);
  logoutBtn.addEventListener('click', handleLogout);
  
  // Prevent modal dismissal
  loginModal.addEventListener('click', (e) => {
    if (e.target === loginModal) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  
  // Expose logout function globally
  window.logoutAdmin = handleLogout;
})();
// ========== END ADMIN AUTHENTICATION SYSTEM ==========

// --- Summary Bar Update Function ---
async function updateSummaryBar() {
  try {
    await refreshBookingMappings();
    // Get current week boundaries (Monday to Sunday)
    const now = new Date();
    const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
    const monday = new Date(now);
    monday.setDate(now.getDate() + mondayOffset);
    monday.setHours(0, 0, 0, 0);
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);
    
    // Fetch data
    const [slotsData, bookingsData, waitlistData] = await Promise.all([
      getAvailableSlots(),
      getBookings(),
      getWaitlist()
    ]);
    
    // 1. Count sessions this week
    let weeklySessions = 0;
    Object.entries(slotsData).forEach(([dateStr, slots]) => {
      const sessionDate = new Date(dateStr + 'T00:00:00');
      if (sessionDate >= monday && sessionDate <= sunday) {
        weeklySessions += slots.length;
      }
    });
    
    // 2. Count total bookings and payment statuses
    // For block bookings, count as 1 even though they appear on multiple dates
    let totalBookings = 0;
    let pendingPayments = 0;
    let confirmedPayments = 0;
    const seenBlockBookings = new Set(); // Track block bookings (name+email+title) to avoid counting multiple times
    
    Object.entries(bookingsData).forEach(([date, dateBookings]) => {
      if (Array.isArray(dateBookings)) {
        dateBookings.forEach(booking => {
          // Extract booking details: "time - title (name) (email)"
          const parts = booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
          if (parts) {
            const time = parts[1];
            const title = parts[2];
            const name = parts[3];
            const email = parts[4];
            
            // Check if this is a block session
            let isBlockSession = false;
            let blockId = null;
            if (slotsData[date]) {
              const slot = slotsData[date].find(s => s.time === time && s.title === title);
              isBlockSession = slot && slot.blockId !== null && slot.blockId !== undefined;
              blockId = slot ? slot.blockId : null;
            }
            
            // For block bookings, create a unique key and only count once
            if (isBlockSession && blockId) {
              const blockKey = `${name}|${email}|${title}|${blockId}`;
              if (seenBlockBookings.has(blockKey)) {
                return; // Skip this - already counted
              }
              seenBlockBookings.add(blockKey);
            }
            
            totalBookings++;
            
            // Use the same getBookingStatus function that the rest of the app uses
            const status = getBookingStatus(email, date, time, title);
            if (status === 'Confirmed') confirmedPayments++;
            else if (status === 'Pending') pendingPayments++;
          }
        });
      }
    });
    
    // 3. Count total waitlist entries
    let waitlistTotal = 0;
    Object.values(waitlistData).forEach(sessionWaitlist => {
      if (Array.isArray(sessionWaitlist)) {
        waitlistTotal += sessionWaitlist.length;
      }
    });
    
    console.log('Summary bar update:', {totalBookings, pendingPayments, confirmedPayments, weeklySessions, waitlistTotal});
    
    // Update DOM
    document.getElementById('summaryWeeklySessions').textContent = weeklySessions;
    document.getElementById('summaryTotalBookings').textContent = totalBookings;
    document.getElementById('summaryPendingPayments').textContent = pendingPayments;
    document.getElementById('summaryConfirmedPayments').textContent = confirmedPayments;
    document.getElementById('summaryWaitlistTotal').textContent = waitlistTotal;
    
  } catch (error) {
    console.error('Error updating summary bar:', error);
  }
}

// --- View Mode State ---
let adminViewMode = localStorage.getItem('adminViewMode') || 'aesthetic';
const viewModeSwitch = document.getElementById('viewModeSwitch');
if (adminViewMode === 'table') viewModeSwitch.checked = true;
viewModeSwitch.addEventListener('change', () => {
  adminViewMode = viewModeSwitch.checked ? 'table' : 'aesthetic';
  localStorage.setItem('adminViewMode', adminViewMode);
  updateTableModeStyle();
  console.log('viewModeSwitch changed ->', adminViewMode);
  // Immediately render the appropriate views for the selected mode
  if (adminViewMode === 'table') {
    try { if (typeof renderAllBookingsTable === 'function') renderAllBookingsTable(); } catch(e){console.error('renderAllBookingsTable error',e)}
    try { if (typeof renderAllAvailableSlotsTable === 'function') renderAllAvailableSlotsTable(); } catch(e){console.error('renderAllAvailableSlotsTable error',e)}
    try { if (typeof renderAllAvailableSlotsTableUltraSimple === 'function') renderAllAvailableSlotsTableUltraSimple(); } catch(e){}
    try { if (typeof renderWaitlistTableUltraSimple === 'function') renderWaitlistTableUltraSimple(); } catch(e){}
  } else {
    // aesthetic mode
    console.log('switching to aesthetic mode: rendering aesthetic views');
    try { renderAllBookings(); } catch(e){console.error('renderAllBookings error',e)}
    try { renderAllAvailableSlots(); } catch(e){console.error('renderAllAvailableSlots error',e)}
    try { renderWaitlist(); } catch(e){console.error('renderWaitlist error',e)}
  }
});

// --- Table Mode CSS Toggle ---
const tableModeStyle = document.getElementById('tableModeStyle');
function updateTableModeStyle() {
  if (adminViewMode === 'table') tableModeStyle.removeAttribute('disabled');
  else tableModeStyle.setAttribute('disabled', '');
}
updateTableModeStyle();
viewModeSwitch.addEventListener('change', updateTableModeStyle);

console.clear();
console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('CHECKING CUSTOM EMAIL SECTION');
console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

// Check if custom email section exists in DOM
const customEmailSection = document.getElementById('customEmailSection');
console.log('âœ“ customEmailSection element found:', !!customEmailSection);

if (customEmailSection) {
  console.log('âœ“ Display style:', customEmailSection.style.display);
  console.log('âœ“ Visibility:', customEmailSection.style.visibility);
  console.log('âœ“ Is visible:', customEmailSection.offsetParent !== null);
  console.log('âœ“ Computed display:', window.getComputedStyle(customEmailSection).display);
}

// Check form elements
const customEmailForm = document.getElementById('customEmailForm');
console.log('âœ“ customEmailForm found:', !!customEmailForm);

const customEmailMessage = document.getElementById('customEmailMessage');
console.log('âœ“ customEmailMessage found:', !!customEmailMessage);

const customEmailRecipient = document.getElementById('customEmailRecipient');
console.log('âœ“ customEmailRecipient found:', !!customEmailRecipient);

console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

// ========== CUSTOM EMAIL FUNCTIONALITY ==========
async function getEmailsForCustomEmail() {
  try {
    // Source emails from Player Profiles (players.json) as requested
    const players = await getPlayerProfiles();
    // players is an object keyed by email -> profile
    const out = Object.keys(players || {}).map(key => {
      const p = players[key] || {};
      // Use p.email as the true email, fallback to key only if missing
      return {
        email: p.email || key,
        name: p.name || p.displayName || p.email || key,
        bookings: p.bookings || [],
        waitlist: p.waitlist || [],
        offers: p.offers || []
      };
    }).filter(u => u.email && u.email.includes('@'));
    return out;
  } catch (err) {
    console.error('Error fetching player profiles for custom email:', err);
    return [];
  }
}

// ========= Player Profiles (admin) =========
async function getPlayerProfiles() {
  try {
    const res = await fetch(PHP_PATH + 'getPlayers.php?t=' + Date.now());
    if (!res.ok) throw new Error('Failed to fetch player profiles');
    return await res.json();
  } catch (err) {
    console.error('getPlayerProfiles error:', err);
    return {};
  }
}

async function renderPlayerProfiles() {
  const container = document.getElementById('playerProfilesContainer');
  if (!container) return;

  // Show a loading placeholder only on the very first load â€” do NOT clear the DOM on subsequent polls
  const showTransientLoading = !lastPlayersSnapshot;
  if (showTransientLoading) {
    container.innerHTML = `<div class="empty-profiles" style="display:flex;gap:10px;align-items:center;color:#666;"><i class="fas fa-user"></i> Checking saved profiles ...</div>`;
  }

  try {
    const players = await getPlayerProfiles();
    const keys = Object.keys(players || {});

    // Create a stable, deterministic snapshot for change detection
    keys.sort();
    const stableSnapshot = JSON.stringify(keys.map(k => [k, players[k]]));
    lastPlayersFetchedAt = Date.now();

    // If nothing changed since last fetch, do nothing (prevents flicker)
    if (stableSnapshot === lastPlayersSnapshot) return;
    lastPlayersSnapshot = stableSnapshot;

    // Render only when snapshot changed
    if (!keys.length) {
      container.innerHTML = `
        <div class="empty-slots-message">
          <i class="fas fa-inbox"></i>
          <p>No player profiles saved</p>
        </div>`;
      return;
    }

    const frag = document.createDocumentFragment();

    // Sort by display name for UX (stable sort using name or email)
    keys.sort((a,b)=> (players[a].name||a).localeCompare(players[b].name||b));

    for (const email of keys) {
      const playerId = email; // Use the key from playerProfiles.json
      const p = players[playerId] || {};
      const card = document.createElement('div');
      card.className = 'profile-card';
      const displayName = p.name || playerId || '(no name)';

      // Build content without transient 'checking' state to avoid animation/flicker
      card.innerHTML = `
        <div style="display:flex;flex-direction:row;align-items:center;justify-content:space-between;width:100%;">
          <div style="display:flex;flex-direction:column;align-items:flex-start;min-width:0;">
            <div style="font-size:1.05rem;font-weight:600;color:#222;margin-bottom:2px;">${escapeHtml(displayName)}</div>
            <div style="font-size:0.92rem;color:#555;margin-bottom:2px;">${escapeHtml(p.email || email)}</div>
            <a class="profile-json-link" href="${PHP_PATH}getPlayers.php?email=${encodeURIComponent(p.email || email)}" target="_blank" rel="noopener" style="font-size:0.82rem;color:#4b5563;text-decoration:underline;margin-bottom:4px;">View JSON</a>
          </div>
          <div style="display:flex;align-items:center;gap:8px;">
            <button class="edit-profile-btn" style="background:#2563eb;color:#fff;border:none;padding:4px 8px;border-radius:4px;font-weight:600;font-size:0.82rem;min-width:48px;max-width:64px;cursor:pointer;">Edit</button>
            <button class="delete-profile-btn" style="background:#ef4444;color:#fff;border:none;padding:4px 6px;border-radius:4px;font-weight:600;font-size:0.82rem;min-width:48px;max-width:64px;cursor:pointer;">Delete</button>
          </div>
        </div>`;

      // Open modal on card click (keep raw JSON link available)
      card.addEventListener('click', (e) => {
        if (e.target.closest('.profile-json-link')) return;
        e.preventDefault();
        showPlayerModal(p.email || email);
      });

      // Ensure the raw-JSON link does not propagate/cause modal to open
      card.querySelectorAll('.profile-json-link').forEach(a => a.addEventListener('click', ev => ev.stopPropagation()));

      // Wire up Delete button
            // Wire up Edit button
            const editBtn = card.querySelector('.edit-profile-btn');
            editBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              openEditProfileModal(playerId, p);
            });
      const deleteBtn = card.querySelector('.delete-profile-btn');
      deleteBtn.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        deleteBtn.disabled = true;
        deleteBtn.textContent = '...';
        try {
          const res = await fetch('php/deletePlayerProfile.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: 'playerId=' + encodeURIComponent(playerId)
          });
          const data = await res.json();
          if (data.success) {
            card.remove();
            showToast('Profile deleted');
          } else {
            showToast('Delete failed: ' + (data.error || 'Unknown error'), {error:true});
            deleteBtn.disabled = false;
            deleteBtn.textContent = 'Delete';
          }
        } catch (err) {
          showToast('Delete failed: ' + err.message, {error:true});
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }
      });

      frag.appendChild(card);
    }

    // Replace children in one atomic operation to minimize reflow/flicker
    container.replaceChildren(frag);
  } catch (err) {
    console.error('renderPlayerProfiles failed', err);
    if (!lastPlayersSnapshot) {
      container.innerHTML = `<div class="empty-slots-message"><i class="fas fa-exclamation-triangle"></i><p>Error loading player profiles</p></div>`;
    }
  }
}

// small helper to avoid XSS when injecting names
function escapeHtml(s){ return String(s || '').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }

// Ensure the Player Profiles section exists in the DOM (created dynamically for resilience)
// --- Edit Player Profile Modal ---
function openEditProfileModal(playerId, profile) {
  // Remove any existing modal
  let modal = document.getElementById('editProfileModal');
  if (modal) modal.remove();

  // Build modal HTML
  modal = document.createElement('div');
  modal.id = 'editProfileModal';
  modal.className = 'pt-modal';
  modal.style.display = 'block';
  modal.innerHTML = `
    <div class="pt-modal-overlay" id="editProfileModalOverlay"></div>
    <div class="pt-modal-content" role="document" aria-labelledby="editProfileModalTitle" style="max-width: 520px;">
      <button class="pt-modal-close" id="editProfileModalClose" aria-label="Close dialog" style="font-family: 'Inter', Arial, sans-serif;">&#215;</button>
      <h3 id="editProfileModalTitle">Edit Player Profile</h3>
      <form id="editProfileForm" style="display:flex;flex-direction:column;gap:12px;">
        <label>Name<input type="text" name="name" value="${escapeHtml(profile.name || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
        <label>Email<input type="email" name="email" value="${escapeHtml(profile.email || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
        <label>Age<input type="number" name="age" value="${escapeHtml(profile.age || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
        <label>Experience<input type="text" name="experience" value="${escapeHtml(profile.experience || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
        <label>Medical<input type="text" name="medical" value="${escapeHtml(profile.medical || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
        <fieldset class="emergency-contact" style="border:1px solid #eee;padding:8px 8px 4px 8px;border-radius:6px;margin-bottom:8px;">
          <legend style="font-weight:600;color:#888;font-size:0.95rem;margin-bottom:4px;">Emergency contact</legend>
          <label>Name<input type="text" name="emergency_name" value="${escapeHtml(profile.emergency?.name || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
          <label>Phone<input type="text" name="emergency_phone" value="${escapeHtml(profile.emergency?.phone || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
          <label>Relationship<input type="text" name="emergency_relationship" value="${escapeHtml(profile.emergency?.relationship || '')}" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;"></label>
        </fieldset>
        <div style="display:flex;gap:12px;margin-top:8px;">
          <button type="submit" class="btn" style="background:#2563eb;color:#fff;">Save</button>
          <button type="button" class="btn" id="editProfileCancelBtn" style="background:#888;color:#fff;">Cancel</button>
        </div>
      </form>
    </div>
  `;
  document.body.appendChild(modal);

  // Close modal handlers
  modal.querySelector('#editProfileModalClose').onclick = closeEditProfileModal;
  modal.querySelector('#editProfileCancelBtn').onclick = closeEditProfileModal;
  modal.querySelector('#editProfileModalOverlay').onclick = closeEditProfileModal;

  // Submit handler (to be implemented next)
  modal.querySelector('#editProfileForm').onsubmit = async function(e) {
    e.preventDefault();
    const form = modal.querySelector('#editProfileForm');
    const formData = new FormData(form);
    formData.append('playerId', playerId);

    // Combine emergency fields into a single object and stringify
    const emergency = {
      name: form.elements['emergency_name'].value,
      phone: form.elements['emergency_phone'].value,
      relationship: form.elements['emergency_relationship'].value
    };
    formData.delete('emergency_name');
    formData.delete('emergency_phone');
    formData.delete('emergency_relationship');
    formData.append('emergency', JSON.stringify(emergency));

    try {
      const res = await fetch('php/editPlayerProfile.php', {
        method: 'POST',
        body: formData
      });
      const data = await res.json();
      if (data.success) {
        closeEditProfileModal();
        showToast('Profile updated');
        await renderPlayerProfiles();
      } else {
        showToast('Save failed: ' + (data.error || 'Unknown error'), {error:true});
      }
    } catch (err) {
      showToast('Save failed: ' + err.message, {error:true});
    }
  };
}

function closeEditProfileModal() {
  const modal = document.getElementById('editProfileModal');
  if (modal) modal.remove();
}
function ensurePlayerProfilesSection() {
  if (document.getElementById('playerProfilesContainer')) return;
  const container = document.querySelector('.admin-container');
  if (!container) return;
  const section = document.createElement('div');
  section.id = 'playerProfilesSection';
  section.style.marginTop = 'clamp(20px, 5vh, 30px)';
  section.innerHTML = `
    <h2><i class="fas fa-id-card"></i> Player Profiles</h2>
    <div class="player-profiles-container" id="playerProfilesContainer">
      <div class="empty-profiles" style="display:flex;gap:10px;align-items:center;color:#666;">
        <i class="fas fa-user"></i>
        <span>Checking saved profiles ...</span>
      </div>
    </div>

    <!-- Player profile modal (view-only) -->
    <div id="playerModal" class="pt-modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="pt-modal-overlay" id="playerModalOverlay"></div>
      <div class="pt-modal-content" role="document" aria-labelledby="playerModalTitle">
        <button class="pt-modal-close" id="playerModalClose" aria-label="Close dialog" style="font-family: 'Inter', Arial, sans-serif;">&#215;</button>
        <h3 id="playerModalTitle">Player profile</h3>
        <div class="pt-modal-body" id="playerModalBody">
          <!-- populated dynamically -->
        </div>
        <div class="pt-meta" id="playerModalMeta"></div>
        <div class="pt-actions">
          <button class="btn" id="playerModalDone">Close</button>
        </div>
      </div>
    </div>

    <!-- Player Notes modal (admin add/view) -->
    <div id="playerNotesModal" class="pt-modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="pt-modal-overlay" id="playerNotesModalOverlay"></div>
      <div class="pt-modal-content" role="document" aria-labelledby="playerNotesModalTitle" style="z-index:13000;">
        <button class="pt-modal-close" id="playerNotesModalClose" aria-label="Close dialog">Ã—</button>
        <h3 id="playerNotesModalTitle">Player notes</h3>
        <div class="pt-modal-body" id="playerNotesModalBody">
          <div id="notesHeader" style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
            <div style="color:#6b7280;font-size:0.95rem;">Notes for <span id="notesPlayerName" style="font-weight:700;color:#0f172a"></span></div>
            <div style="display:flex;gap:8px;align-items:center;">
              <button id="playerNotesCopyLinkBtn" class="btn" type="button" title="Generate shareable read-only link">Generate link</button>
            </div>
          </div>

          <div id="notesContainer">
            <div class="notes-empty" id="notesEmpty">Loading notesâ€¦</div>
            <div class="notes-list" id="notesList" aria-live="polite"></div>
          </div>

          <div id="notesFormWrap">
            <form id="notesForm" class="notes-form" action="#" onsubmit="return false;">
              <label style="font-weight:700;color:#374151;">New note</label>
              <textarea id="noteContent" placeholder="Write a private note for this player (visible to admins)..."></textarea>
              <div style="display:flex;gap:8px;align-items:center;">
                <input id="noteAuthor" placeholder="Author" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(15,23,42,0.04);" />
                <div class="notes-actions">
                  <button id="notesSubmitBtn" class="btn" type="button">Add note</button>
                </div>
              </div>
            </form>
          </div>
        </div>
        <div class="pt-actions">
          <button class="btn" id="playerNotesCloseBtn">Close</button>
        </div>
      </div>
    </div>`;
  // Insert near the end of the left column â€” place before the script tag if possible
  const ref = container.querySelector('script');
  if (ref && ref.parentNode === container) container.insertBefore(section, ref);
  else container.appendChild(section);
  
  // Add Session Creation Modal
  const sessionModalHTML = `
    <div id="sessionCreationModal" class="pt-modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="pt-modal-overlay" id="sessionModalOverlay"></div>
      <div class="pt-modal-content" role="document" aria-labelledby="sessionModalTitle" style="max-width: 600px;">
        <button class="pt-modal-close" id="sessionModalClose" aria-label="Close dialog">Ã—</button>
        <h3 id="sessionModalTitle">Create Session</h3>
        <div class="pt-modal-body" id="sessionModalBody" style="max-height: 70vh; overflow-y: auto;">
          
          <div style="margin-bottom: 16px;">
            <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Session Type</label>
            <select id="modalSessionType" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
              <option value="single">Single Session</option>
              <option value="block">Block Session (4-Week Series)</option>
              <option value="special">Special</option>
            </select>
          </div>
          <div style="margin-bottom: 16px;">
            <label for="templateDropdown" style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Templates</label>
            <select id="templateDropdown" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
              <option value="">-- Select a template --</option>
            </select>
            <button id="deleteTemplateBtn" style="margin-top: 6px; background: #e74c3c; color: white; border: none; border-radius: 6px; padding: 6px 12px; font-size: 0.95rem; font-weight: 600; display: none;">Delete Template</button>
          </div>

          <!-- Single Session Fields -->
          <div id="modalSingleFields" style="display: block;">
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Select Date</label>
              <input type="date" id="modalAdminDate" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Slot Title</label>
              <input type="text" id="modalSlotTitle" placeholder="e.g., Basketball Training, Court Rental" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Number of Spots</label>
              <input type="number" id="modalNumberOfSpots" placeholder="e.g., 10" min="1" value="1" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Session Type</label>
              <select id="modalSessionTypeDetail" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
                <option value="group">Group</option>
                <option value="solo">Solo</option>
              </select>
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Session Start Time</label>
              <input type="time" id="modalSessionStartTime" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Session Duration (minutes)</label>
              <input type="number" id="modalSessionDuration" placeholder="e.g., 40" min="15" max="240" value="40" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Price (Â£)</label>
              <input type="number" id="modalSessionPrice" placeholder="e.g., 15.00" min="0" step="0.01" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Location</label>
              <input type="text" id="modalSessionLocation" placeholder="e.g., Main Studio, Room 101" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
          </div>

          <!-- Block Session Fields -->
          <div id="modalBlockFields" style="display: none;">
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Block Title</label>
              <input type="text" id="modalBlockTitle" placeholder="e.g., Basketball Training Series" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">First Session Date</label>
              <input type="date" id="modalBlockFirstDate" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Start Time</label>
              <input type="time" id="modalBlockStartTime" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Number of Sessions</label>
              <input type="number" id="modalBlockNumberOfSessions" placeholder="e.g., 4" min="1" max="12" value="4" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Duration (minutes)</label>
              <input type="number" id="modalBlockDuration" placeholder="e.g., 40" min="15" max="240" value="40" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Number of Spots</label>
              <input type="number" id="modalBlockNumberOfSpots" placeholder="e.g., 10" min="1" value="1" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Session Type</label>
              <select id="modalBlockSessionTypeDetail" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
                <option value="group">Group</option>
                <option value="solo">Solo</option>
              </select>
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Price (Â£)</label>
              <input type="number" id="modalBlockPrice" placeholder="e.g., 60.00" min="0" step="0.01" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div style="margin-bottom: 12px;">
              <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px;">Location</label>
              <input type="text" id="modalBlockLocation" placeholder="e.g., Main Studio, Room 101" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem; background: #fff;">
            </div>
            <div id="modalBlockPreviewText" style="margin-top:18px; text-align:center; color:#6366f1; font-weight:600; font-size:1.05rem; display:block;">preview</div>

            <!-- Block Session Preview Section: Always visible, static -->
            <div id="blockSessionPreviewSection" style="margin-top:28px; background:#f8fafc; border-radius:8px; border:1px solid #e5e7eb; padding:18px 14px 14px 14px;">
              <div style="font-weight:700; color:#22223b; font-size:1.08rem; margin-bottom:12px; letter-spacing:0.01em;">Generated Sessions</div>
              <div id="blockSessionPreviewRows" style="display:flex; flex-direction:column; gap:12px; max-width:100vw; width:100%; overflow-x:hidden;">
                <div class="block-session-row" style="display:flex; align-items:center; gap:6px; background:#fff; border-radius:6px; padding:10px 8px; border:1px solid #e0e7ef; width:100%; box-sizing:border-box; min-width:0;">
                  <span style="min-width:40px; font-weight:600; color:#374151; margin-left:8px;">#1</span>
                  <input type="date" style="width:80px; min-width:0; max-width:100px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;">
                  <input type="time" style="width:64px; min-width:0; max-width:80px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;">
                </div>
                <div class="block-session-row" style="display:flex; align-items:center; gap:12px; background:#fff; border-radius:6px; padding:10px 8px; border:1px solid #e0e7ef; width:100%; box-sizing:border-box; min-width:0;">
                  <span style="min-width:32px; font-weight:600; color:#374151; margin-left:8px;">#2</span>
                  <input type="date" style="width:80px; min-width:0; max-width:100px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;">
                  <input type="time" style="width:64px; min-width:0; max-width:80px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;">
                </div>
                <div class="block-session-row" style="display:flex; align-items:center; gap:12px; background:#fff; border-radius:6px; padding:10px 8px; border:1px solid #e0e7ef; width:100%; box-sizing:border-box; min-width:0;">
                                  <style>
                                    @media (max-width: 600px) {
                                      #blockSessionPreviewRows .block-session-row {
                                        max-width: 90vw !important;
                                        width: 90vw !important;
                                        min-width: 0 !important;
                                      }
                                    }
                                  </style>
                  <span style="min-width:32px; font-weight:600; color:#374151; margin-left:8px;">#3</span>
                  <input type="date" style="width:80px; min-width:0; max-width:100px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;">
                  <input type="time" style="width:64px; min-width:0; max-width:80px; padding:2px 2px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; background:#f9fafb; color:#222; text-align:center; margin:0;">
                </div>
              </div>
            </div>
          </div>

        </div>
        <div class="pt-actions" style="display: flex; gap: 12px; margin-top: 16px; flex-wrap: wrap;">
          <button class="btn" id="sessionModalCreate" style="flex: 1; background: #FF9800; color: white; padding: 10px 16px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">Create</button>
          <button class="btn" id="sessionModalCancel" style="flex: 1; background: transparent; color: #666; padding: 10px 16px; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 600;">Cancel</button>
          <button class="btn" id="saveAsTemplateBtn" style="flex: 1; background: #2563eb; color: white; padding: 10px 16px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">Save as Template</button>
        </div>
      </div>
    </div>
    
    <!-- Sync to Calendar Modal -->
    <div id="syncToCalendarModal" class="pt-modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="pt-modal-overlay" id="syncToCalendarModalOverlay"></div>
      <div class="pt-modal-content" role="document" aria-labelledby="syncToCalendarModalTitle">
        <button class="pt-modal-close" id="syncToCalendarModalClose" aria-label="Close dialog" style="font-family: 'Inter', Arial, sans-serif;">&#215;</button>
        <h3 id="syncToCalendarModalTitle">Sync to Calendar</h3>
        <div class="pt-modal-body" style="display: flex; flex-direction: column; gap: 16px;">
          <div>
            <label style="display: block; color: #333; font-weight: 600; margin-bottom: 8px; font-size: clamp(0.9rem, 2vw, 1rem);">Select Time Range</label>
            <select id="calendarSyncRange" style="width: 100%; padding: clamp(10px, 3vw, 14px); border-radius: 8px; border: 1px solid #d1d5db; font-size: clamp(0.9rem, 2vw, 1rem); font-family: inherit; background: #fff; color: #333;">
              <option value="">-- Choose an option --</option>
              <option value="week">This Week</option>
              <option value="month">This Month</option>
              <option value="all">All Sessions</option>
            </select>
          </div>
          
          <div id="calendarLinkPlaceholder" style="display: flex; flex-direction: column; gap: 16px; padding: 0; background: transparent; border: none; min-height: auto; width: 100%; box-sizing: border-box;">
            <div style="min-height: 80px; padding: 16px; background: #f9fafb; border-radius: 8px; border: 1px dashed #d1d5db; display: flex; align-items: center; justify-content: center; color: #9ca3af; font-size: clamp(0.85rem, 2vw, 0.95rem); text-align: center;">
              Generated calendar link or button will appear here
            </div>
          </div>
        </div>
        <div class="pt-actions" style="display: flex; gap: 12px; margin-top: 16px;">
          <button class="btn" id="syncToCalendarModalCloseBtn" style="flex: 1; background: transparent; color: #666; padding: 10px 16px; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 600;">Close</button>
        </div>
      </div>
    </div>`;
  container.insertAdjacentHTML('beforeend', sessionModalHTML);
}

// ========= Player modal (view-only) =========
function _buildRow(label, value, missing) {
  return `
    <div class="pt-row ${missing ? 'missing-field' : ''}">
      <div class="pt-label">${escapeHtml(label)}</div>
      <div class="pt-value">${escapeHtml(value === undefined || value === null || value === '' ? 'â€”' : value)}</div>
    </div>`;
}

async function showPlayerModal(email) {
  const modal = document.getElementById('playerModal');
  const body = document.getElementById('playerModalBody');
  const meta = document.getElementById('playerModalMeta');
  const raw = document.getElementById('playerModalRaw');
  const closeBtn = document.getElementById('playerModalDone');

  if (!modal || !body) return;
  modal.setAttribute('aria-hidden', 'false');
  modal.classList.add('open');
  document.body.style.overflow = 'hidden';
  body.innerHTML = _buildRow('Loading', 'â€¦', false);
  if (raw) raw.href = PHP_PATH + 'getPlayers.php?email=' + encodeURIComponent(email || '');

  try {
    const res = await fetch(PHP_PATH + 'getPlayers.php?email=' + encodeURIComponent(email || ''));
    if (!res.ok) throw new Error('Profile not found');
    const p = await res.json();

    const rows = [];
    rows.push(_buildRow('Name', p.name || p.full_name || '', !p.name));
    rows.push(_buildRow('Email', p.email || '', !p.email));
    rows.push(_buildRow('Age', p.age || '', !p.age && p.age !== 0));
    rows.push(_buildRow('Playing experience', p.experience || p.playing_experience || '', !p.experience));
    rows.push(_buildRow('Medical information', p.medical || p.medical_information || '', !p.medical));

    const emergency = (p.emergency && (p.emergency.name || p.emergency.phone)) ? `${p.emergency.name || ''}${p.emergency.phone ? ' &bull; ' + p.emergency.phone : ''}` : '';
    rows.push(_buildRow('Emergency contact', emergency, !(p.emergency && p.emergency.name && p.emergency.phone)));

    rows.push(_buildRow('Media consent', p.media_consent ? 'Given' : 'Not given', !p.media_consent));
    rows.push(_buildRow('Waiver acknowledged', p.waiver_acknowledged ? 'Yes' : 'No', !p.waiver_acknowledged));

    // Append a short notes summary row (will be populated async)
    rows.push(`
      <div class="pt-row">
        <div class="pt-label">Player notes</div>
        <div class="pt-value" id="playerModalNotesSummary">Checking notes... <button id="playerModalNotesBtnInline" class="btn" style="margin-left:10px;">View / Add Notes</button></div>
      </div>
    `);

    body.innerHTML = rows.join('\n');
    meta.textContent = `Loaded: ${new Date().toLocaleString()}`;
    if (raw) { raw.href = PHP_PATH + 'getPlayers.php?email=' + encodeURIComponent(p.email || email || ''); raw.style.display = ''; }

    // Wire inline notes button only (header-level button removed)
    const inlineBtn = document.getElementById('playerModalNotesBtnInline');
    const playerEmail = p.email || email || '';
    const playerName = p.name || playerEmail || '(no name)';
    inlineBtn?.addEventListener('click', (ev) => { ev.preventDefault(); closePlayerModal(); showPlayerNotesModal(playerEmail, playerName); });

    // Populate summary (note count + latest author/date)
    (async ()=>{
      try {
        const r = await fetch(PHP_PATH + 'getPlayerNotes.php?email=' + encodeURIComponent(playerEmail));
        if (!r.ok) throw new Error('No notes');
        const j = await r.json();
        const notes = j.notes || [];
        const summaryEl = document.getElementById('playerModalNotesSummary');
        if (!summaryEl) return;
        if (!notes.length) {
          summaryEl.innerHTML = 'No notes yet <button id="playerModalNotesBtnInline2" class="btn" style="margin-left:10px;">View / Add Notes</button>';
          const btn2 = document.getElementById('playerModalNotesBtnInline2');
          btn2?.addEventListener('click', (ev) => { ev.preventDefault(); closePlayerModal(); showPlayerNotesModal(playerEmail, playerName); });
          return;
        }
        const latest = notes[0];
        const d = new Date(latest.date || Date.now()).toLocaleString();
        summaryEl.innerHTML = `${notes.length} note${notes.length>1?'s':''} &mdash; <span class="note-author">${escapeHtml(latest.author||'')}</span> &bull; <span class="note-date">${escapeHtml(d)}</span> <button id="playerModalNotesBtnInline3" class="btn" style="margin-left:10px;">View / Add Notes</button>`;
        const btn3 = document.getElementById('playerModalNotesBtnInline3');
        btn3?.addEventListener('click', (ev) => { ev.preventDefault(); closePlayerModal(); showPlayerNotesModal(playerEmail, playerName); });
      } catch (err) {
        const summaryEl = document.getElementById('playerModalNotesSummary');
        if (summaryEl) summaryEl.textContent = 'Unable to load notes';
      }
    })();

    // focus the close button for keyboard users
    closeBtn?.focus();
  } catch (err) {
    body.innerHTML = `<div class="pt-row"><div class="pt-label">Error</div><div class="pt-value">Could not load profile</div></div>`;
    meta.textContent = '';
  }
}

function closePlayerModal() {
  const modal = document.getElementById('playerModal');
  if (!modal) return;
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
  document.body.style.overflow = '';
}

// ===== Player Notes (frontend) =====
function showToast(msg, opts = {}){
  const container = document.createElement('div');
  container.style.cssText = `position:fixed;right:20px;bottom:24px;background:${opts.error? '#ef4444':'#111827'};color:#fff;padding:12px 16px;border-radius:8px;box-shadow:0 8px 32px rgba(2,6,23,0.3);z-index:14000;font-weight:600;`;
  container.textContent = msg;
  document.body.appendChild(container);
  setTimeout(()=>{ container.style.opacity = '0'; setTimeout(()=>container.remove(), 300); }, opts.duration||3200);
}

async function showPlayerNotesModal(email, name){
  const modal = document.getElementById('playerNotesModal');
  if (!modal) return;
  const titleName = document.getElementById('notesPlayerName');
  titleName.textContent = name || email || '';
  modal.setAttribute('aria-hidden', 'false');
  modal.classList.add('open');
  document.body.style.overflow = 'hidden';
  // reset UI
  document.getElementById('notesList').innerHTML = '';
  document.getElementById('notesEmpty').textContent = 'Loading notesâ€¦';
  document.getElementById('noteContent').value = '';
  document.getElementById('noteAuthor').value = localStorage.getItem('adminName') || '';
  document.getElementById('noteContent').focus();
  // attach handlers
  document.getElementById('playerNotesCloseBtn').onclick = closePlayerNotesModal;
  document.getElementById('playerNotesModalClose').onclick = closePlayerNotesModal;
  document.getElementById('playerNotesModalOverlay').onclick = (e) => { if (e.target && e.target.id === 'playerNotesModalOverlay') closePlayerNotesModal(); };
  document.getElementById('notesSubmitBtn').onclick = async () => {
    await submitPlayerNote(email);
  };
  document.getElementById('playerNotesCopyLinkBtn').onclick = async () => {
    await generateShareableNotesLink(email);
  };
  // initial load
  await fetchAndRenderNotes({ email });
}

function closePlayerNotesModal(){
  const modal = document.getElementById('playerNotesModal');
  if (!modal) return;
  modal.classList.remove('open');
  modal.setAttribute('aria-hidden', 'true');
  document.body.style.overflow = '';
}

document.addEventListener('keydown', (e) => { if (e.key === 'Escape') { closePlayerNotesModal(); closePlayerModal(); } });

async function fetchAndRenderNotes({ email = null, token = null } = {}){
  const readOnly = !!token;
  try {
    let url;
    if (token) url = PHP_PATH + 'getPlayerNotes.php?token=' + encodeURIComponent(token);
    else url = PHP_PATH + 'getPlayerNotes.php?email=' + encodeURIComponent(email);
    const res = await fetch(url);
    if (!res.ok) throw new Error('Failed to load notes');
    const j = await res.json();
    const notes = j.notes || [];
    const list = document.getElementById('notesList');
    list.innerHTML = '';

    // Hide/Show form based on readOnly
    const formWrap = document.getElementById('notesFormWrap');
    if (formWrap) formWrap.style.display = readOnly ? 'none' : '';

    if (!notes.length) {
      document.getElementById('notesEmpty').textContent = readOnly ? 'No notes available.' : 'No notes yet.';
      return notes;
    }
    document.getElementById('notesEmpty').textContent = '';

    notes.forEach(n => {
      const item = document.createElement('div');
      item.className = 'note-item';
      const date = n.date ? new Date(n.date).toLocaleString() : '';

      // Build markup; include admin-only delete button when not readOnly
      item.innerHTML = `
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start;">
          <div style="flex:1">
            <div class="note-meta"><div class="note-author">${escapeHtml(n.author||'')}</div><div class="note-date">${escapeHtml(date)}</div></div>
            <div class="note-content">${escapeHtml(n.content||'')}</div>
          </div>
          <div style="margin-left:12px;display:flex;flex-direction:column;align-items:flex-end;gap:8px;">
            ${readOnly ? '' : `<button class="btn note-delete-btn" data-noteid="${escapeHtml(n.noteId||'')}">Delete</button>`}
          </div>
        </div>
      `;

      list.appendChild(item);

      // Attach delete handler for admin view
      if (!readOnly) {
        const del = item.querySelector('.note-delete-btn');
        if (del) {
          del.addEventListener('click', async (ev) => {
            ev.stopPropagation();
            const noteId = del.dataset.noteid;
            if (!noteId) return;
            if (!confirm('Delete this note? This action cannot be undone.')) return;
            // optimistic remove
            const parent = item;
            parent.style.opacity = '0.45';
            const res = await deletePlayerNote(email, noteId);
            if (res && res.success) {
              parent.remove();
              showToast('Note deleted');
              const remaining = document.querySelectorAll('#notesList .note-item').length;
              if (!remaining) document.getElementById('notesEmpty').textContent = 'No notes yet.';
            } else {
              parent.style.opacity = '';
              showToast('Failed to delete note', { error: true });
            }
          });
        }
      }
    });
    return notes;
  } catch (err) {
    console.error('fetchAndRenderNotes failed', err);
    document.getElementById('notesEmpty').textContent = 'Unable to load notes';
    return [];
  }
}

async function submitPlayerNote(email){
  const contentEl = document.getElementById('noteContent');
  const authorEl = document.getElementById('noteAuthor');
  const content = (contentEl.value || '').trim();
  const author = (authorEl.value || '').trim() || 'admin';
  if (!content) { showToast('Please enter a note', { error: true }); contentEl.focus(); return; }

  // Optimistic UI: show a temporary note
  const list = document.getElementById('notesList');
  const tmpId = 'tmp_' + Date.now();
  const tmp = { noteId: tmpId, content, author, date: new Date().toISOString() };
  const item = document.createElement('div');
  item.className = 'note-item';
  item.dataset.tmpId = tmpId;
  item.innerHTML = `
    <div class="note-meta"><div class="note-author">${escapeHtml(author)}</div><div class="note-date">Just now</div></div>
    <div class="note-content">${escapeHtml(content)}</div>
  `;
  // insert at top
  const empty = document.getElementById('notesEmpty');
  empty.textContent = '';
  list.insertAdjacentElement('afterbegin', item);

  // send to server
  try {
    const res = await fetch(PHP_PATH + 'addPlayerNote.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, content, author }) });
    const j = await res.json();
    if (!res.ok || !j.success) throw new Error((j && j.errors && j.errors[0]) || 'Failed to save note');
    // replace temp node with server-provided note (server returns note)
    if (j.note && j.note.noteId) {
      item.remove();
      await fetchAndRenderNotes({ email });
      localStorage.setItem('adminName', author);
      showToast('Note added');
      document.getElementById('noteContent').value = '';
    }
  } catch (err) {
    console.error('submitPlayerNote error', err);
    item.remove();
    showToast('Failed to save note', { error: true });
  }
}

async function deletePlayerNote(email, noteId){
  if (!email || !noteId) return { success: false, errors: ['email and noteId required'] };
  try {
    const res = await fetch(PHP_PATH + 'deletePlayerNote.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, noteId }) });
    const j = await res.json();
    if (!res.ok || !j.success) return { success: false, errors: j.errors || ['delete failed'] };
    return { success: true };
  } catch (err) {
    console.error('deletePlayerNote failed', err);
    return { success: false, errors: ['network error'] };
  }
}

async function generateShareableNotesLink(email){
  try {
    const res = await fetch(PHP_PATH + 'generateNoteLink.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, scope: 'player', expiresInDays: 30 }) });
    const j = await res.json();
    if (!res.ok || !j.success) throw new Error((j && j.errors && j.errors[0]) || 'Failed to create link');
    // Prefer a user-friendly read-only viewer page if available
    const shareUrl = new URL(window.location.href);
    shareUrl.pathname = (shareUrl.pathname.replace(/\/[^\/]*$/, '/') || '/') + 'notes.html';
    shareUrl.search = '?token=' + encodeURIComponent(j.token);
    await navigator.clipboard.writeText(shareUrl.toString());
    showToast('Shareable link copied to clipboard');
    return { token: j.token, url: shareUrl.toString() };
  } catch (err) {
    console.error('generateShareableNotesLink failed', err);
    showToast('Failed to generate link', { error: true });
    return null;
  }
}

// Allow opening notes modal by URL param (admin convenience): ?notes_token=...
(function checkNotesTokenOnLoad(){
  try {
    const params = new URLSearchParams(location.search);
    const t = params.get('notes_token') || params.get('token');
    if (t) {
      // open a read-only notes modal using the token
      showPlayerNotesModal(null, 'Read-only');
      fetchAndRenderNotes({ token: t }).then(() => {
        // hide form in read-only mode
        const f = document.getElementById('notesFormWrap'); if (f) f.style.display = 'none';
      });
    }
  } catch (err) { /* ignore */ }
})();


// modal event bindings
document.addEventListener('click', (e) => {
  // overlay click
  if (e.target && e.target.id === 'playerModalOverlay') closePlayerModal();
});
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePlayerModal(); });
document.addEventListener('click', (e)=>{
  if (e.target && e.target.id === 'playerModalClose') closePlayerModal();
  if (e.target && e.target.id === 'playerModalDone') closePlayerModal();
});


async function sendCustomEmail(recipient, message) {
  try {
    const res = await fetch(PHP_PATH + 'sendCustomEmail.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ recipient, message })
    });
    const json = await res.json();
    if (!res.ok) throw new Error(json.message || 'Failed to send email');
    return json;
  } catch (err) {
    console.error('Error sending email:', err);
    throw err;
  }
}

// Load emails when recipient dropdown changes
document.getElementById('customEmailRecipient').addEventListener('change', async (e) => {
  const value = e.target.value;
  const savedContainer = document.getElementById('savedEmailsContainer');
  const newContainer = document.getElementById('newEmailContainer');
  
  savedContainer.style.display = 'none';
  newContainer.style.display = 'none';
  
  if (value === 'saved') {
    savedContainer.style.display = 'block';
    const users = await getEmailsForCustomEmail();
    const select = document.getElementById('customEmailSavedList');
    select.innerHTML = '<option value="">-- Select a user --</option>';
    users.forEach(user => {
      const bookingCount = user.bookings?.length || 0;
      const waitlistCount = user.waitlist?.length || 0;
      const offerCount = user.offers?.length || 0;
      
      let status = '';
      if (bookingCount > 0) status += `${bookingCount}B `;
      if (waitlistCount > 0) status += `${waitlistCount}W `;
      if (offerCount > 0) status += `${offerCount}O`;
      status = status.trim() ? `[${status}]` : '';
      
      const option = document.createElement('option');
      option.value = user.email;
      option.textContent = `${user.name} (${user.email}) ${status}`;
      option.title = `Bookings: ${bookingCount}, Waitlist: ${waitlistCount}, Offers: ${offerCount}`;
      select.appendChild(option);
    });
  } else if (value === 'new') {
    newContainer.style.display = 'block';
  }
});

// Handle form submission
document.getElementById('customEmailForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const message = document.getElementById('customEmailMessage').value.trim();
  const recipientType = document.getElementById('customEmailRecipient').value;
  
  if (!message) {
    showToast('Please enter a message', {error: true});
    return;
  }
  
  if (!recipientType) {
    showToast('Please select a recipient', {error: true});
    return;
  }
  
  let recipient = '';
  
  if (recipientType === 'all') {
    recipient = 'all';
  } else if (recipientType === 'saved') {
    // Collect multi-selected player emails
    const sel = Array.from(document.getElementById('customEmailSavedList').selectedOptions || [])
      .map(o => o.value)
      .filter(Boolean);
    if (!sel.length) {
      showToast('Please select one or more players', {error: true});
      return;
    }
    recipient = sel.length === 1 ? sel[0] : sel; // send array when multiple
  } else if (recipientType === 'new') {
    recipient = document.getElementById('customEmailNewAddress').value.trim();
    if (!recipient || !recipient.includes('@')) {
      showToast('Please enter a valid email address', {error: true});
      return;
    }
  }
  
  try {
    const btn = document.getElementById('customEmailSendBtn');
    btn.disabled = true;
    btn.textContent = 'Sending...';
    
    const result = await sendCustomEmail(recipient, message);
    
    // Show success notification
    const successMsg = document.createElement('div');
    successMsg.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #10b981;
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-weight: 600;
      z-index: 10000;
      animation: slideIn 0.3s ease-out;
    `;
    successMsg.textContent = `âœ“ ${result.message || 'Email sent successfully!'}`;
    document.body.appendChild(successMsg);
    
    // Add animation
    const style = document.createElement('style');
    style.textContent = `@keyframes slideIn { from { transform: translateX(400px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }`;
    document.head.appendChild(style);
    
    // Auto remove after 4 seconds
    setTimeout(() => {
      successMsg.style.animation = 'slideIn 0.3s ease-out reverse';
      setTimeout(() => successMsg.remove(), 300);
    }, 4000);
    
    // Reset form
    document.getElementById('customEmailForm').reset();
    document.getElementById('customEmailRecipient').value = '';
    document.getElementById('savedEmailsContainer').style.display = 'none';
    document.getElementById('newEmailContainer').style.display = 'none';
    
    btn.disabled = false;
    btn.textContent = 'Send Email';
  } catch (err) {
    const errorMsg = document.createElement('div');
    errorMsg.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #ef4444;
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-weight: 600;
      z-index: 10000;
      animation: slideIn 0.3s ease-out;
    `;
    errorMsg.textContent = `âœ— Error: ${err.message}`;
    document.body.appendChild(errorMsg);
    
    setTimeout(() => {
      errorMsg.style.animation = 'slideIn 0.3s ease-out reverse';
      setTimeout(() => errorMsg.remove(), 300);
    }, 4000);
    
    document.getElementById('customEmailSendBtn').disabled = false;
    document.getElementById('customEmailSendBtn').textContent = 'Send Email';
  }
});

const PHP_PATH='php/';
let selectedDate=null;
let autoRefreshInterval=null;
let isAutoRefreshing=false; // Flag to prevent UI flicker during refresh
const REFRESH_INTERVAL=5000; // 5 seconds
let expandedBooking=null;
let previousBookingIds=new Set();
let expandedWaitlistCards = new Set(); // Track expanded waitlist cards
let expandedSessionCards = new Set(); // Track which session cards are expanded in All Bookings view
let expandedSlotCards = new Set(); // Track which slot cards are expanded in All Available Slots view
let bookingMappingsCache = {}; // Cache bookingMappings for status lookups
let bookingMappingsLastFetchedAt = 0;
let previousWaitlistData = null; // Track previous waitlist data to detect changes
let previousWaitlistViewMode = null; // Track previous view mode to detect changes

// Player profiles: cache last fetched snapshot to avoid visual re-renders when unchanged
let lastPlayersSnapshot = null;
let lastPlayersFetchedAt = 0; // ms since epoch (for debugging)

// Fetch JSON
async function getAvailableSlots() {
  try {
    const res = await fetch(PHP_PATH + 'getSlots.php?t=' + Date.now());
    const data = await res.json();
    if (data && typeof data === 'object' && !Array.isArray(data)) {
      return data;
    } else {
      console.warn('[getAvailableSlots] Invalid data, returning empty object:', data);
      return {};
    }
  } catch (e) {
    console.error('[getAvailableSlots] Fetch or parse error:', e);
    return {};
  }
}
async function getBookings(){ return await (await fetch(PHP_PATH+'getBookings.php?t='+Date.now())).json(); }
async function getWaitlist(){ return await (await fetch(PHP_PATH+'getWaitlist.php?t='+Date.now())).json(); }
async function getBookingMappings(){ 
  const res = await fetch(PHP_PATH + '../data/bookingMappings.json?t=' + Date.now());
  return res.ok ? await res.json() : {};
}

const _norm = (v) => (v || '').toString().trim();
const _normEmail = (v) => _norm(v).toLowerCase();
const _normKey = (email, date, time, title) => ({
  email: _normEmail(email),
  date: _norm(date),
  time: _norm(time),
  title: _norm(title)
});

async function refreshBookingMappings(){
  bookingMappingsCache = await getBookingMappings();
  bookingMappingsLastFetchedAt = Date.now();
  return bookingMappingsCache;
}

function findBookingMapping(email, date, time, title){
  const mappings = bookingMappingsCache || {};
  let best = null;
  let bestTs = -1;
  const key = _normKey(email, date, time, title);

  const toTs = (m) => {
    if (typeof m.timestamp === 'number') return m.timestamp * 1000;
    if (m.createdAt) {
      const t = Date.parse(m.createdAt);
      if (!Number.isNaN(t)) return t;
    }
    return 0;
  };

  for (const [bookingId, mapping] of Object.entries(mappings)) {
    const mappingTime = _norm(mapping.slot || mapping.time);
    const mappingTitle = _norm(mapping.title);
    const mappingEmail = _normEmail(mapping.email);
    const mappingDates = Array.isArray(mapping.blockDates) ? mapping.blockDates : [];
    const mappingDate = _norm(mapping.date);
    const dateMatch = mappingDate === key.date || mappingDates.includes(key.date);
    if (mappingEmail === key.email && mappingTime === key.time && mappingTitle === key.title && dateMatch) {
      const ts = toTs(mapping);
      if (ts >= bestTs) {
        bestTs = ts;
        best = { bookingId, mapping };
      }
    }
  }
  return best;
}

function getBookingStatus(email, date, time, title) {
  const found = findBookingMapping(email, date, time, title);
  if (!found || !found.mapping) {
    console.log('ðŸŸ¡ STATUS: No mapping found -> Pending', { email, date, time, title });
    return 'Pending';
  }
  const status = found.mapping.status || (found.mapping.confirmedAt ? 'Confirmed' : 'Pending');
  console.log('ðŸŸ¢ STATUS: Mapping found', { email, date, time, title, bookingId: found.bookingId, status, mapping: found.mapping });
  return status === 'Confirmed' ? 'Confirmed' : 'Pending';
}

function getStatusBadgeClass(email, date, time, title) {
  return getBookingStatus(email, date, time, title) === 'Confirmed' ? 'confirmed' : 'pending';
}

async function markBookingConfirmed(email, date, time, title, blockDatesArray = []){
  console.log('ðŸ”µ CONFIRM: markBookingConfirmed called', { email, date, time, title, blockDatesArray });
  const mappings = bookingMappingsCache && Object.keys(bookingMappingsCache).length
    ? bookingMappingsCache
    : await getBookingMappings();
  let targetId = null;
  let targetMapping = null;
  const key = _normKey(email, date, time, title);
  const normBlockDates = (blockDatesArray || []).map(_norm);

  for (const [bookingId, mapping] of Object.entries(mappings)) {
    const mappingTime = _norm(mapping.slot || mapping.time);
    const mappingTitle = _norm(mapping.title);
    const mappingEmail = _normEmail(mapping.email);
    const mappingDates = Array.isArray(mapping.blockDates) ? mapping.blockDates : [];
    const mappingDate = _norm(mapping.date);
    const dateMatch = mappingDate === key.date || mappingDates.includes(key.date) || normBlockDates.some(d => mappingDates.includes(d) || mappingDate === d);
    if (mappingEmail === key.email && mappingTime === key.time && mappingTitle === key.title && dateMatch) {
      targetId = bookingId;
      targetMapping = mapping;
      break;
    }
  }

  if (!targetId || !targetMapping) {
    console.log('ðŸŸ¡ CONFIRM: Not found in cache, refreshing mappings');
    const refreshed = await getBookingMappings();
    bookingMappingsCache = refreshed && typeof refreshed === 'object' ? refreshed : {};
    for (const [bookingId, mapping] of Object.entries(bookingMappingsCache)) {
      const mappingTime = _norm(mapping.slot || mapping.time);
      const mappingTitle = _norm(mapping.title);
      const mappingEmail = _normEmail(mapping.email);
      const mappingDates = Array.isArray(mapping.blockDates) ? mapping.blockDates : [];
      const mappingDate = _norm(mapping.date);
      const dateMatch = mappingDate === key.date || mappingDates.includes(key.date) || normBlockDates.some(d => mappingDates.includes(d) || mappingDate === d);
      if (mappingEmail === key.email && mappingTime === key.time && mappingTitle === key.title && dateMatch) {
        targetId = bookingId;
        targetMapping = mapping;
        break;
      }
    }
  }

  if (!targetId || !targetMapping) {
    console.log('âŒ CONFIRM: Mapping not found after refresh', { email, date, time, title, blockDatesArray });
    return false;
  }

  targetMapping.status = 'Confirmed';
  targetMapping.confirmedAt = new Date().toISOString();

  console.log('ðŸŸ¢ CONFIRM: Updating mapping to Confirmed', { bookingId: targetId, targetMapping });
  await fetch(PHP_PATH + 'saveBookingMapping.php', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ bookingId: targetId, data: targetMapping })
  });

  bookingMappingsCache[targetId] = targetMapping;
  console.log('âœ… CONFIRM: Mapping updated in cache', { bookingId: targetId, status: targetMapping.status });
  return true;
}
async function saveAvailableSlots(slots){ 
  const res = await fetch(PHP_PATH+'saveSlots.php',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(slots)});
  if(!res.ok) throw new Error('Failed to save slots: ' + res.status);
  const json = await res.json();
  return json;
}
async function saveBookings(bookings){ 
  const res = await fetch(PHP_PATH+'saveBookings.php',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(bookings)});
  let json = null;
  let text = await res.text();
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    throw new Error('Failed to parse server response: ' + text);
  }
  if(!res.ok) throw new Error((json && json.message) || 'Failed to save bookings: ' + res.status);
  return json;
}
async function saveWaitlist(waitlist){
  const res = await fetch(PHP_PATH+'saveWaitlist.php',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action: 'replace_all', data: waitlist})});
  if(!res.ok) throw new Error('Failed to save waitlist: ' + res.status);
  const json = await res.json();
  return json;
}
async function saveBookingMappings(mappings){
  const res = await fetch(PHP_PATH + '../data/bookingMappings.json', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(mappings)});
  if(!res.ok) throw new Error('Failed to save booking mappings: ' + res.status);
  return res;
}
// Override confirm to pause auto-refresh during dialog
const originalConfirm=window.confirm;
window.confirm=function(message){
  stopAutoRefresh();
  const result=originalConfirm(message);
  // Resume refresh after dialog closes
  setTimeout(()=>startAutoRefresh(), 50);
  return result;
};
function formatTime(hours, minutes) {
  return `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}`;
}

// Modal confirm function (replaces browser confirm for delete operations)
async function modalConfirm(message) {
  return new Promise((resolve) => {
    const modal = document.createElement('div');
    modal.className = 'pt-modal';
    modal.id = 'confirmModal_' + Date.now();
    modal.innerHTML = `
      <div class="pt-modal-overlay"></div>
      <div class="pt-modal-content" style="max-width: 400px;">
        <h3>Confirm Action</h3>
        <div class="pt-modal-body">${escapeHtml(message)}</div>
        <div class="pt-actions" style="display: flex; gap: 12px; margin-top: 16px;">
          <button class="btn" id="modalConfirmOK" style="flex: 1; background: #ef4444; color: white; padding: 10px 16px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">Delete</button>
          <button class="btn" id="modalConfirmCancel" style="flex: 1; background: transparent; color: #666; padding: 10px 16px; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 600;">Cancel</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    modal.classList.add('open');
    document.body.style.overflow = 'hidden';
    
    const okBtn = modal.querySelector('#modalConfirmOK');
    const cancelBtn = modal.querySelector('#modalConfirmCancel');
    
    const cleanup = () => {
      modal.classList.remove('open');
      document.body.style.overflow = '';
      setTimeout(() => modal.remove(), 300);
    };
    
    okBtn.onclick = () => {
      cleanup();
      resolve(true);
    };
    
    cancelBtn.onclick = () => {
      cleanup();
      resolve(false);
    };
    
    modal.querySelector('.pt-modal-overlay').onclick = () => {
      cleanup();
      resolve(false);
    };
  });
}

// --- Helper: Format date as dd/mm/yy ---
function formatDateDDMMYY(dateStr) {
  if (!dateStr) return '';
  // If already comma-separated (block), format each part
  if (dateStr.includes(',')) {
    return dateStr.split(',').map(d => formatDateDDMMYY(d.trim())).join(', ');
  }
  // Accepts YYYY-MM-DD or already formatted
  const parts = dateStr.split('-');
  if (parts.length === 3) {
    const [year, month, day] = parts;
    return `${day}/${month}/${year.slice(2)}`;
  }
  return dateStr;
}

// --- Date formatting for display ---
function formatDateForDisplay(dateStr) {
  // Convert YYYY-MM-DD to "23rd January 2026"
  const [year, month, day] = dateStr.split('-');
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                      'July', 'August', 'September', 'October', 'November', 'December'];
  
  const dayNum = parseInt(day);
  const monthName = monthNames[parseInt(month) - 1];
  
  return `${dayNum} ${monthName} ${year}`;
}

// Helper: Safely format price (handles both string and number)
function formatPrice(price) {
  if (!price) return '';
  // Use HTML entity for pound sign
  return typeof price === 'number' ? `&pound;${price.toFixed(2)}` : `&pound;${price}`;
}

// --- Helper: Send confirmation email and mark booking confirmed (reused by table and card views) ---
async function adminSendConfirmation(email, bookingDate, slotTime, slotTitle, name, blockDatesArray=[]) {
  if(!confirm(`Are you sure? This will send a confirmation email to ${email}`)) return false;
  const additionalMessage = prompt('Add an optional message to include in the email:\n(Leave blank for no additional message)', '');
  
  // Try to find existing bookingId mapping first
  let bookingId = null;
  let mappingData = null;
  let found = findBookingMapping(email, bookingDate, slotTime, slotTitle);
  if (!found) {
    await refreshBookingMappings();
    found = findBookingMapping(email, bookingDate, slotTime, slotTitle);
  }
  if (found) {
    bookingId = found.bookingId;
    mappingData = found.mapping;
  }
  
  // Generate a bookingId if not already mapped
  if (!bookingId) {
    bookingId = `admin-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  console.log('ðŸ”µ ADMIN SENDCONFIRM: Sending confirmation email');
  console.log('ðŸ”µ ADMIN SENDCONFIRM: bookingId=', bookingId);
  console.log('ðŸ”µ ADMIN SENDCONFIRM: isBlock=', blockDatesArray && blockDatesArray.length > 0);
  console.log('ðŸ”µ ADMIN SENDCONFIRM: blockDatesArray=', blockDatesArray);
  
  // Store this mapping so sendEmail.php can find it
  try {
    const mappingsResponse = await fetch(PHP_PATH + '../data/bookingMappings.json');
    let mappings = await mappingsResponse.json();
    if (!mappings || typeof mappings !== 'object') mappings = {};
    
    mappings[bookingId] = {
      email,
      slot: slotTime,
      title: slotTitle,
      date: bookingDate,
      name,
      isBlock: blockDatesArray && blockDatesArray.length > 0,
      blockDates: blockDatesArray || [],
      status: 'Confirmed',
      confirmedAt: new Date().toISOString(),
      createdAt: mappingData?.createdAt || new Date().toISOString()
    };
    
    console.log('ðŸŸ¡ ADMIN SENDCONFIRM: Saving booking mapping:', mappings[bookingId]);
    // Save the mapping
    await fetch(PHP_PATH + 'saveBookingMapping.php', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({bookingId, data: mappings[bookingId]})
    });
    bookingMappingsCache = bookingMappingsCache && typeof bookingMappingsCache === 'object' ? bookingMappingsCache : {};
    bookingMappingsCache[bookingId] = mappings[bookingId];
    bookingMappingsLastFetchedAt = Date.now();
    console.log('âœ… ADMIN SENDCONFIRM: Mapping saved successfully');
  } catch (err) {
    console.error('âŒ Error storing booking mapping:', err);
  }
  
  try {
    const emailBody = { 
      email, 
      slot: slotTime, 
      date: bookingDate, 
      title: slotTitle, 
      name, 
      adminMessage: additionalMessage || '',
      bookingId: bookingId
    };
    if (blockDatesArray && blockDatesArray.length) emailBody.blockDates = blockDatesArray;
    console.log('ðŸŸ¢ ADMIN SENDCONFIRM: Sending email with body:', emailBody);
    const response = await fetch(PHP_PATH + 'sendEmail.php', {
      method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(emailBody)
    });
    if(!response.ok) throw new Error(`HTTP ${response.status}`);
    const text = await response.text();
    if (text.includes('Email sent')) {
      console.log('âœ… ADMIN SENDCONFIRM: Email sent successfully!');
      showToast(`Email sent to ${email}`);
      await markBookingConfirmed(email, bookingDate, slotTime, slotTitle, blockDatesArray || []);
      await refreshBookingMappings();
      console.log('[SESSION EDIT][PAYLOAD]', payload);
      const editRes = await fetch(PHP_PATH + 'saveSlotsEdit.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      const editJson = await editRes.json();
      console.log('[SESSION EDIT][RESPONSE]', editJson);
      await refreshBookingMappings();
      await renderAllBookings();
      // Debug slotsData and capacity after reload
      const slotsDataDebug = await getAvailableSlots();
      console.group('[SESSION CAPACITY DEBUG]');
      Object.keys(slotsDataDebug).forEach(date => {
        slotsDataDebug[date].forEach(slot => {
          console.log(`[${date}][${slot.time}]`, {
            title: slot.title,
            capacity: slot.capacity,
            bookedUsers: slot.bookedUsers ? slot.bookedUsers.length : 0,
            blockId: slot.blockId || null
          });
        });
      });
      console.groupEnd();
      await renderAllAvailableSlots();
      await renderWaitlist();
      await updateSummaryBar();
      return true;
    }
    showToast(`Error: ${text}`, {error: true});
    return false;
  } catch(err) {
    showToast(`Failed to send email: ${err.message}`, {error: true});
    console.error('adminSendConfirmation error', err);
    return false;
  }
}

// --- Helper: Calculate end time from start time + duration ---
function calculateEndTime(startTime, durationMinutes) {
  const [hours, minutes] = startTime.split(':').map(Number);
  const totalMinutes = hours * 60 + minutes + durationMinutes;
  const endHours = Math.floor(totalMinutes / 60);
  const endMinutes = totalMinutes % 60;
  return formatTime(endHours, endMinutes);
}

// --- Create slot with dynamic duration ---
document.getElementById('createSlot').onclick = async () => {
  if (!selectedDate) { showToast('Select date', { error: true }); return; }
  // Try to get the slot title robustly
  let titleInput = document.getElementById('slotTitle');
  let title = '';
  if (titleInput && titleInput.offsetParent !== null && !titleInput.disabled) {
    title = titleInput.value.trim();
  }
  if (!title) {
    // Try fallback: modalSlotTitle (if using modal)
    let modalTitleInput = document.getElementById('modalSlotTitle');
    if (modalTitleInput && modalTitleInput.offsetParent !== null && !modalTitleInput.disabled) {
      title = modalTitleInput.value.trim();
    }
  }
  if (!title) {
    showToast('Enter slot title (the field may be hidden or not filled)', { error: true });
    return;
  }
  const numberOfSpots = parseInt(document.getElementById('numberOfSpots').value) || 1;
  const sessionType = document.getElementById('sessionType').value;
  const startTime = document.getElementById('sessionStartTime').value;
  const duration = parseInt(document.getElementById('sessionDuration').value) || 40;
  const price = parseFloat(document.getElementById('sessionPrice').value) || 0;
  const location = document.getElementById('sessionLocation').value.trim() || '';
  if (!startTime) { showToast('Select start time', { error: true }); return; }
  const endTime = calculateEndTime(startTime, duration);
  const slotsData = await getAvailableSlots();
  slotsData[selectedDate] = slotsData[selectedDate] || [];
  // Check if slot already exists at this time
  if (slotsData[selectedDate].some(s => s.time === startTime)) {
    showToast('A slot already exists at this time', { error: true });
    return;
  }
  // Add new slot
  slotsData[selectedDate].push({
    time: startTime,
    endTime: endTime,
    duration: duration,
    title: title,
    capacity: numberOfSpots,
    sessionType: sessionType,
    price: price,
    location: location,
    bookedUsers: []
  });
  await saveAvailableSlots(slotsData);
  showToast(`Slot created: ${startTime}-${endTime}`);
  // Clear form
  document.getElementById('sessionStartTime').value = '';
  document.getElementById('sessionDuration').value = '40';
  document.getElementById('sessionPrice').value = '';
  document.getElementById('sessionLocation').value = '';
  
  renderAllAvailableSlots();
};

// --- OLD HANDLERS (kept for reference but disabled since we now use modal) ---
/*
// --- Toggle Block Session Form ---
document.getElementById('toggleBlockSession').onclick = () => {
  const form = document.getElementById('blockSessionForm');
  const btn = document.getElementById('toggleBlockSession');
  const isVisible = form.style.display !== 'none';
  
  form.style.display = isVisible ? 'none' : 'block';
  btn.innerHTML = isVisible ? '<i class="fas fa-plus"></i> Create Block Session (4-Week Series)' : '<i class="fas fa-minus"></i> Hide Block Session';
};

// --- Toggle Single Session Form ---
document.getElementById('toggleSingleSession').onclick = () => {
  const form = document.getElementById('singleSessionForm');
  const btn = document.getElementById('toggleSingleSession');
  const isVisible = form.style.display !== 'none';
  
  form.style.display = isVisible ? 'none' : 'block';
  btn.innerHTML = isVisible ? '<i class="fas fa-plus"></i> Create Single Slot' : '<i class="fas fa-minus"></i> Hide Single Slot';
};

// --- Cancel Block Session Form ---
document.getElementById('cancelBlockSession').onclick = () => {
  document.getElementById('blockSessionForm').style.display = 'none';
  document.getElementById('toggleBlockSession').innerHTML = '<i class="fas fa-plus"></i> Create Block Session (4-Week Series)';
  // Clear form
  document.getElementById('blockTitle').value = '';
  document.getElementById('blockFirstDate').value = '';
  document.getElementById('blockNumberOfSessions').value = '4';
  document.getElementById('blockStartTime').value = '';
  document.getElementById('blockDuration').value = '40';
  document.getElementById('blockNumberOfSpots').value = '1';
  document.getElementById('blockSessionType').value = 'group';
  document.getElementById('blockPrice').value = '';
  document.getElementById('blockLocation').value = '';
};

// --- Cancel Single Session Form ---
document.getElementById('cancelSingleSession').onclick = () => {
  document.getElementById('singleSessionForm').style.display = 'none';
  document.getElementById('toggleSingleSession').innerHTML = '<i class="fas fa-plus"></i> Create Single Slot';
  // Clear form
  document.getElementById('slotTitle').value = '';
  document.getElementById('numberOfSpots').value = '1';
  document.getElementById('sessionType').value = 'group';
  document.getElementById('sessionStartTime').value = '';
  document.getElementById('sessionDuration').value = '40';
  document.getElementById('sessionPrice').value = '';
  document.getElementById('sessionLocation').value = '';
};

// --- Create Block Session ---
document.getElementById('createBlockSession').onclick=async ()=>{
  const blockTitle=document.getElementById('blockTitle').value.trim();
  const firstDate=document.getElementById('blockFirstDate').value;
  const numberOfSessions=parseInt(document.getElementById('blockNumberOfSessions').value) || 4;
  const startTime=document.getElementById('blockStartTime').value;
  const duration=parseInt(document.getElementById('blockDuration').value) || 40;
  const numberOfSpots=parseInt(document.getElementById('blockNumberOfSpots').value) || 1;
  const sessionType=document.getElementById('blockSessionType').value;
  const price=parseFloat(document.getElementById('blockPrice').value) || 0;
  const location=document.getElementById('blockLocation').value.trim() || '';
  
  if(!blockTitle){ showToast('Enter block title', {error: true}); return; }
  if(!firstDate){ showToast('Select first session date', {error: true}); return; }
  if(!startTime){ showToast('Select start time', {error: true}); return; }
  if(numberOfSessions < 1 || numberOfSessions > 12){ showToast('Number of sessions must be between 1 and 12', {error: true}); return; }
  
  // Generate weekly dates starting from firstDate
  const blockDates=[];
  let current=new Date(firstDate);
  for(let i = 0; i < numberOfSessions; i++){
    blockDates.push(current.toISOString().split('T')[0]);
    current.setDate(current.getDate() + 7);
  }
  
  // Generate unique block ID
  const blockId='block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  const endTime=calculateEndTime(startTime, duration);
  
  const slotsData=await getAvailableSlots();
  
  // Create slots for each date
  for(const date of blockDates){
    slotsData[date]=slotsData[date] || [];
    
    if(slotsData[date].some(s => s.time === startTime)){
      showToast(`Slot already exists at ${date} ${startTime}`, {error: true});
      return;
    }
    
    slotsData[date].push({
      time: startTime,
      endTime: endTime,
      duration: duration,
      title: blockTitle,
      capacity: numberOfSpots,
      sessionType: sessionType,
      price: price,
      location: location,
      bookedUsers: [],
      blockId: blockId,
      blockDates: blockDates
    });
  }
  
  await saveAvailableSlots(slotsData);
  const lastDate = blockDates[blockDates.length - 1];
  showToast(`Block session created: ${numberOfSessions} sessions from ${blockDates[0]} to ${lastDate}`);
  
  // Clear form
  document.getElementById('blockTitle').value='';
  document.getElementById('blockFirstDate').value='';
  document.getElementById('blockNumberOfSessions').value='4';
  document.getElementById('blockStartTime').value='';
  document.getElementById('blockDuration').value='40';
  document.getElementById('blockNumberOfSpots').value='1';
  document.getElementById('blockSessionType').value='group';
  
  renderAllAvailableSlots();
};
*/
// --- END OLD HANDLERS ---

// --- Session Creation Modal Handlers ---
// Wait for DOM to be ready and modal to exist
setTimeout(() => {
    // --- Session Templates Logic ---
    let sessionTemplates = [];
    let selectedTemplateId = null;

    async function fetchTemplates(type) {
      let url = 'php/getSessionTemplates.php';
      if (type) url += '?type=' + encodeURIComponent(type);
      const res = await fetch(url);
      sessionTemplates = await res.json();
      return sessionTemplates;
    }

    function updateTemplateDropdown(type) {
      const dropdown = document.getElementById('templateDropdown');
      dropdown.innerHTML = '<option value="">-- Select a template --</option>';
      let filtered = sessionTemplates.filter(t => t.type === type);
      filtered.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t.templateId;
        opt.textContent = t.name + (t.attributes && t.attributes.location ? ' (' + t.attributes.location + ')' : '');
        dropdown.appendChild(opt);
      });
    }

    async function refreshTemplatesUI() {
      const type = document.getElementById('modalSessionType').value;
      await fetchTemplates(type);
      updateTemplateDropdown(type);
      document.getElementById('deleteTemplateBtn').style.display = 'none';
      selectedTemplateId = null;
    }

    document.getElementById('modalSessionType').addEventListener('change', refreshTemplatesUI);
    document.getElementById('templateDropdown').addEventListener('change', function() {
      const tid = this.value;
      selectedTemplateId = tid;
      const t = sessionTemplates.find(t => t.templateId === tid);
      if (!t) return;
      // Auto-fill form fields
      const f = t.formFields || {};
      if (t.type === 'single') {
        document.getElementById('modalSingleFields').style.display = 'block';
        document.getElementById('modalBlockFields').style.display = 'none';
        document.getElementById('modalAdminDate').value = f.date || '';
        document.getElementById('modalSlotTitle').value = f.title || '';
        document.getElementById('modalNumberOfSpots').value = f.capacity || 1;
        document.getElementById('modalSessionTypeDetail').value = f.sessionType || 'group';
        document.getElementById('modalSessionStartTime').value = f.time || '';
        document.getElementById('modalSessionDuration').value = f.duration || 40;
        document.getElementById('modalSessionPrice').value = f.price || '';
        document.getElementById('modalSessionLocation').value = f.location || '';
      } else if (t.type === 'block') {
        document.getElementById('modalSingleFields').style.display = 'none';
        document.getElementById('modalBlockFields').style.display = 'block';
        document.getElementById('modalBlockTitle').value = f.title || '';
        document.getElementById('modalBlockFirstDate').value = f.firstDate || '';
        document.getElementById('modalBlockNumberOfSessions').value = f.numberOfSessions || 4;
        document.getElementById('modalBlockStartTime').value = f.time || '';
        document.getElementById('modalBlockDuration').value = f.duration || 40;
        document.getElementById('modalBlockNumberOfSpots').value = f.capacity || 1;
        document.getElementById('modalBlockSessionTypeDetail').value = f.sessionType || 'group';
        document.getElementById('modalBlockPrice').value = f.price || '';
        document.getElementById('modalBlockLocation').value = f.location || '';
      }
      document.getElementById('deleteTemplateBtn').style.display = 'inline-block';
    });

    document.getElementById('deleteTemplateBtn').addEventListener('click', async function() {
      if (!selectedTemplateId) return;
      if (!confirm('Delete this template?')) return;
      await fetch('php/deleteSessionTemplate.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ templateId: selectedTemplateId })
      });
      await refreshTemplatesUI();
      showToast('Template deleted');
    });

    document.getElementById('saveAsTemplateBtn').addEventListener('click', async function() {
      const type = document.getElementById('modalSessionType').value;
      let name = prompt('Template name:');
      if (!name) return;
      let attributes = {};
      let formFields = {};
      if (type === 'single') {
        attributes = {
          sessionType: document.getElementById('modalSessionTypeDetail').value,
          location: document.getElementById('modalSessionLocation').value,
          price: document.getElementById('modalSessionPrice').value,
          capacity: document.getElementById('modalNumberOfSpots').value
        };
        formFields = {
          title: document.getElementById('modalSlotTitle').value,
          time: document.getElementById('modalSessionStartTime').value,
          duration: document.getElementById('modalSessionDuration').value,
          price: document.getElementById('modalSessionPrice').value,
          location: document.getElementById('modalSessionLocation').value,
          capacity: document.getElementById('modalNumberOfSpots').value,
          sessionType: document.getElementById('modalSessionTypeDetail').value
        };
      } else if (type === 'block') {
        attributes = {
          sessionType: document.getElementById('modalBlockSessionTypeDetail').value,
          location: document.getElementById('modalBlockLocation').value,
          price: document.getElementById('modalBlockPrice').value,
          capacity: document.getElementById('modalBlockNumberOfSpots').value
        };
        formFields = {
          title: document.getElementById('modalBlockTitle').value,
          firstDate: document.getElementById('modalBlockFirstDate').value,
          numberOfSessions: document.getElementById('modalBlockNumberOfSessions').value,
          time: document.getElementById('modalBlockStartTime').value,
          duration: document.getElementById('modalBlockDuration').value,
          price: document.getElementById('modalBlockPrice').value,
          location: document.getElementById('modalBlockLocation').value,
          capacity: document.getElementById('modalBlockNumberOfSpots').value,
          sessionType: document.getElementById('modalBlockSessionTypeDetail').value
        };
      } else if (type === 'special') {
        // For special, use single fields as base
        attributes = {
          sessionType: document.getElementById('modalSessionTypeDetail').value,
          location: document.getElementById('modalSessionLocation').value,
          price: document.getElementById('modalSessionPrice').value,
          capacity: document.getElementById('modalNumberOfSpots').value
        };
        formFields = {
          title: document.getElementById('modalSlotTitle').value,
          time: document.getElementById('modalSessionStartTime').value,
          duration: document.getElementById('modalSessionDuration').value,
          price: document.getElementById('modalSessionPrice').value,
          location: document.getElementById('modalSessionLocation').value,
          capacity: document.getElementById('modalNumberOfSpots').value,
          sessionType: document.getElementById('modalSessionTypeDetail').value
        };
      }
      await fetch('php/saveSessionTemplate.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, type, attributes, formFields })
      });
      await refreshTemplatesUI();
      showToast('Template saved');
    });

    // Initial load
    refreshTemplatesUI();
  const openBtn = document.getElementById('openSessionModal');
  const modalClose = document.getElementById('sessionModalClose');
  const modalOverlay = document.getElementById('sessionModalOverlay');
  const modalCancel = document.getElementById('sessionModalCancel');
  const modalCreate = document.getElementById('sessionModalCreate');
  const sessionTypeSelect = document.getElementById('modalSessionType');
  
  if (!openBtn || !modalClose || !modalOverlay || !modalCancel || !modalCreate || !sessionTypeSelect) {
    console.warn('Session modal elements not found yet, retrying...');
    return;
  }

  openBtn.onclick = () => {
    document.getElementById('sessionCreationModal').classList.add('open');
    document.body.classList.add('modal-open');
  };

  const closeModal = () => {
    document.getElementById('sessionCreationModal').classList.remove('open');
    document.body.classList.remove('modal-open');
  };

  modalClose.onclick = closeModal;

  modalOverlay.onclick = closeModal;

  modalCancel.onclick = closeModal;

  sessionTypeSelect.onchange = (e) => {
    const isSingle = e.target.value === 'single';
    document.getElementById('modalSingleFields').style.display = isSingle ? 'block' : 'none';
    document.getElementById('modalBlockFields').style.display = isSingle ? 'none' : 'block';
    refreshTemplatesUI();
  };

  modalCreate.onclick = async () => {
    console.log('[DEBUG] modalCreate.onclick triggered');
    const sessionType = document.getElementById('modalSessionType').value;
    // Extra debug: check modalCreate button existence
    const btnCheck = document.getElementById('sessionModalCreate');
    console.log('[DEBUG] sessionModalCreate button exists:', !!btnCheck);
  
    if (sessionType === 'single') {
      // Create single session using existing logic
      const date = document.getElementById('modalAdminDate').value;
      const title = document.getElementById('modalSlotTitle').value.trim();
      const capacity = parseInt(document.getElementById('modalNumberOfSpots').value) || 1;
      const type = document.getElementById('modalSessionTypeDetail').value;
      const startTime = document.getElementById('modalSessionStartTime').value;
      const duration = parseInt(document.getElementById('modalSessionDuration').value) || 40;
      const price = parseFloat(document.getElementById('modalSessionPrice').value) || 0;
      const location = document.getElementById('modalSessionLocation').value.trim() || '';

      if (!date) { showToast('Select date', {error: true}); return; }
      if (!title) { showToast('Enter slot title', {error: true}); return; }
      if (!startTime) { showToast('Select start time', {error: true}); return; }

      const endTime = calculateEndTime(startTime, duration);
      let slotsData = await getAvailableSlots();
      slotsData[date] = slotsData[date] || [];

      if (slotsData[date].some(s => s.time === startTime)) {
        showToast(`Slot already exists at ${startTime}`, {error: true});
        return;
      }

      slotsData[date].push({
        time: startTime,
        endTime: endTime,
        duration: duration,
        title: title,
        capacity: capacity,
        sessionType: type,
        price: price,
        location: location,
        bookedUsers: [],
        blockId: null,
        blockDates: []
      });
      
      // Debug: Log the slotsData payload before saving
      console.log('[DEBUG] Payload to saveAvailableSlots:', JSON.stringify(slotsData, null, 2));

      // Validate slotsData before saving
      const validDates = Object.keys(slotsData).filter(date => Array.isArray(slotsData[date]) && slotsData[date].length > 0);
      if (validDates.length === 0) {
        showToast('No valid sessions to save. Please check your input.', {error:true});
        console.error('[BLOCK SESSION] No valid slots to save:', slotsData);
        return;
      }

      // Persist the new slot to backend
      await saveAvailableSlots(slotsData);

      // Clear form
      document.getElementById('modalSlotTitle').value = '';
      document.getElementById('modalNumberOfSpots').value = '1';
      document.getElementById('modalSessionTypeDetail').value = 'group';
      document.getElementById('modalSessionStartTime').value = '';
      document.getElementById('modalSessionDuration').value = '40';
      document.getElementById('modalSessionPrice').value = '';
      document.getElementById('modalSessionLocation').value = '';

      document.getElementById('sessionCreationModal').classList.remove('open');
      document.body.classList.remove('modal-open');
      renderAllAvailableSlots();

    } else {
      // Create block session using existing logic
      const blockTitle = document.getElementById('modalBlockTitle').value.trim();
      const firstDate = document.getElementById('modalBlockFirstDate').value;
      const numberOfSessions = parseInt(document.getElementById('modalBlockNumberOfSessions').value) || 4;
      const startTime = document.getElementById('modalBlockStartTime').value;
      const duration = parseInt(document.getElementById('modalBlockDuration').value) || 40;
      const capacity = parseInt(document.getElementById('modalBlockNumberOfSpots').value) || 1;
      const sessionType = document.getElementById('modalBlockSessionTypeDetail').value;
      const price = parseFloat(document.getElementById('modalBlockPrice').value) || 0;
      const location = document.getElementById('modalBlockLocation').value.trim() || '';

      if (!blockTitle) { showToast('Enter block title', {error: true}); return; }
      if (!firstDate) { showToast('Select first session date', {error: true}); return; }
      if (!startTime) { showToast('Select start time', {error: true}); return; }
      if (numberOfSessions < 1 || numberOfSessions > 12) { showToast('Number of sessions must be between 1 and 12', {error: true}); return; }


      // Use preview row values if present, else fallback to generated
      const blockDates = [];
      const previewRows = document.querySelectorAll('#blockSessionPreviewRows .block-session-row');
      for (let i = 0; i < numberOfSessions; i++) {
        const row = previewRows[i];
        if (row) {
          const dateInput = row.querySelector('input[type="date"]');
          if (dateInput && dateInput.value) {
            blockDates.push(dateInput.value);
            continue;
          }
        }
        // fallback: generate from firstDate
        let current = new Date(firstDate);
        current.setDate(current.getDate() + i * 7);
        blockDates.push(current.toISOString().split('T')[0]);
      }

      const blockId = 'block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const endTime = calculateEndTime(startTime, duration);
      const slotsData = await getAvailableSlots();

      // Ensure slotsData is an object
      if (!slotsData || typeof slotsData !== 'object' || Array.isArray(slotsData)) {
        console.warn('[DEBUG] slotsData was not an object, resetting to {}');
        slotsData = {};
      }

      for (const date of blockDates) {
        slotsData[date] = slotsData[date] || [];

        if (slotsData[date].some(s => s.time === startTime)) {
          showToast(`Slot already exists at ${date} ${startTime}`, {error: true});
          return;
        }

        slotsData[date].push({
          time: startTime,
          endTime: endTime,
          duration: duration,
          title: blockTitle,
          capacity: capacity,
          sessionType: sessionType,
          price: price,
          location: location,
          bookedUsers: [],
          blockId: blockId,
          blockDates: blockDates
        });
      }

      // Debug: Log the slotsData payload before saving (block session)
      console.log('[DEBUG] Payload to saveAvailableSlots (block):', JSON.stringify(slotsData, null, 2));

      await saveAvailableSlots(slotsData);
      const lastDate = blockDates[blockDates.length - 1];
      showToast(`Block session created: ${numberOfSessions} sessions from ${blockDates[0]} to ${lastDate}`);

      // Clear form
      document.getElementById('modalBlockTitle').value = '';
      document.getElementById('modalBlockFirstDate').value = '';
      document.getElementById('modalBlockNumberOfSessions').value = '4';
      document.getElementById('modalBlockStartTime').value = '';
      document.getElementById('modalBlockDuration').value = '40';
      document.getElementById('modalBlockNumberOfSpots').value = '1';
      document.getElementById('modalBlockSessionTypeDetail').value = 'group';
      document.getElementById('modalBlockPrice').value = '';
      document.getElementById('modalBlockLocation').value = '';

      document.getElementById('sessionCreationModal').classList.remove('open');
      document.body.classList.remove('modal-open');
      renderAllAvailableSlots();
    }
  };
}, 100);

// --- on date change ---
document.getElementById('adminDate').onchange=async ()=>{
  selectedDate=document.getElementById('adminDate').value;
  document.getElementById('slotTitle').value='';
  document.getElementById('numberOfSpots').value=1;
  document.getElementById('sessionType').value='group';
  document.getElementById('sessionStartTime').value='';
  document.getElementById('sessionDuration').value='40';
  
  await renderAllBookings();
  await renderAllAvailableSlots();
  await renderWaitlist();
};

// --- Render All Available Slots (only show non-full slots) ---
async function renderAllAvailableSlots(){
  const container = document.getElementById('allAvailableSlots');
  ensureAdminTableStyles();
  const slotsData = await getAvailableSlots();
  const bookingsData = await getBookings();
  container.innerHTML = '';

  if (adminViewMode === 'table') {
    // --- Table View for All Sessions (With Block Grouping) ---
    // Build a flat list of sessions, grouping block sessions as one row
    const rows = [];
    const processedBlockIds = new Set();
    Object.keys(slotsData).forEach(date => {
      slotsData[date].forEach((slot, idx) => {
        // Block session: only add once
        if (slot.blockId && slot.blockDates) {
          if (processedBlockIds.has(slot.blockId)) return;
          processedBlockIds.add(slot.blockId);
          const blockDates = slot.blockDates;
          // Find all slots for this blockId across all blockDates
          let blockSlots = [];
          blockDates.forEach(bd => {
            if (slotsData[bd]) {
              blockSlots = blockSlots.concat(slotsData[bd].filter(s => s.blockId === slot.blockId));
            }
          });
          // Debug: print all blockSlots and their capacity
          console.log('[BLOCK SLOTS CAPACITY DEBUG]', blockSlots.map(s => ({date: s.blockDates ? s.blockDates[0] : '', capacity: s.capacity})));
          // Use the maximum capacity among all blockSlots
          const blockCapacity = blockSlots.length > 0 ? Math.max(...blockSlots.map(s => s.capacity || 1)) : 1;
          // Calculate booked using bookingMappingsCache
          const emails = new Set();
          if (bookingMappingsCache && typeof bookingMappingsCache === 'object') {
            Object.values(bookingMappingsCache).forEach(mapping => {
              const mappingTime = (mapping.slot || mapping.time || '').toString().trim();
              const mappingTitle = (mapping.title || '').toString().trim();
              const mappingEmail = (mapping.email || '').toString().trim().toLowerCase();
              const mappingDates = Array.isArray(mapping.blockDates) ? mapping.blockDates : [mapping.date];
              if (
                mappingTime === slot.time &&
                mappingTitle === slot.title &&
                mappingDates.some(d => blockDates.includes(d))
              ) {
                emails.add(mappingEmail);
              }
            });
          }
          const booked = emails.size;
          const spots = blockCapacity;
          const status = booked >= spots ? 'Full' : 'Available';
          console.debug('[BLOCK SPOT DEBUG]', {blockId: slot.blockId, blockDates, time: slot.time, title: slot.title, booked, spots, emails: Array.from(emails)});
          rows.push({
            isBlock: true,
            date: blockDates.join(', '),
            time: `${slot.time} - ${slot.endTime || ''}`,
            title: slot.title,
            type: slot.sessionType || '',
            price: formatPrice(slot.price),
            status,
            capacity: `${booked}/${spots}`,
            blockId: slot.blockId,
            blockDates,
            remove: () => removeBlockSession(slot.blockId, slot.time, slot.title, blockDates)
          });
        } else if (!slot.blockId) {
          // Single session: count bookings in bookingMappingsCache
          let booked = 0;
          if (bookingMappingsCache && typeof bookingMappingsCache === 'object') {
            booked = Object.values(bookingMappingsCache).filter(mapping => {
              const mappingTime = (mapping.slot || mapping.time || '').toString().trim();
              const mappingTitle = (mapping.title || '').toString().trim();
              const mappingDate = (mapping.date || '').toString().trim();
              return mappingTime === slot.time && mappingTitle === slot.title && mappingDate === date;
            }).length;
          }
          const spots = slot.capacity || 1;
          const status = booked >= spots ? 'Full' : 'Available';
          console.debug('[SINGLE SPOT DEBUG]', {date, time: slot.time, title: slot.title, booked, spots});
          rows.push({
            isBlock: false,
            date: date,
            time: `${slot.time} - ${slot.endTime || ''}`,
            title: slot.title,
            type: slot.sessionType || '',
            price: formatPrice(slot.price),
            status,
            capacity: `${booked}/${spots}`,
            dateRaw: date,
            idx,
            remove: () => removeSingleSession(date, slot.time, slot.title)
          });
        }
      });
    });
    // Sort by date (earliest first)
    rows.sort((a, b) => {
      // For block, use first date in blockDates
      const aDate = a.isBlock ? new Date(a.blockDates[0]) : new Date(a.dateRaw);
      const bDate = b.isBlock ? new Date(b.blockDates[0]) : new Date(b.dateRaw);
      return aDate - bDate;
    });
    // Build table
    const table = document.createElement('table');
    table.className = 'admin-table';
    table.style.width = '100%';
    table.style.tableLayout = 'fixed';
    const thead = document.createElement('thead');
    thead.innerHTML = `<tr><th style="width:13%">Date</th><th style="width:11%">Time</th><th style="width:9%">Capacity</th><th style="width:12%">Title</th><th style="width:10%">Type</th><th style="width:10%">Price</th><th style="width:10%">Status</th><th class='actions' style="width:8%">Actions</th></tr>`;
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    rows.forEach(row => {
      const tr = document.createElement('tr');
      // For block sessions, show each date on its own line; for single sessions, show single formatted date
      const dateHtml = row.isBlock && row.blockDates ? row.blockDates.map(d => formatDateDDMMYY(d)).join('<br>') : formatDateDDMMYY(row.date);
      tr.innerHTML = `<td class="wrap-words" style="max-width:140px;">${dateHtml}</td><td style="white-space:nowrap;word-break:normal;">${row.time}</td><td style="white-space:nowrap;word-break:normal;">${escapeHtml(row.capacity||'')}</td><td class="wrap-words" style="max-width:220px;">${escapeHtml(row.title)}</td><td style="white-space:nowrap;word-break:normal;">${escapeHtml(row.type)}</td><td style="font-size:0.92em;white-space:nowrap;">${row.price}</td><td style="white-space:nowrap;word-break:normal;">${row.status}</td><td class='actions'><a href='#' class='delete-link' style='color:#0074d9;text-decoration:underline;border:none;background:none;padding:0;'>Delete</a></td>`;
      // Attach delete handler
      tr.querySelector('.delete-link').onclick = function(e) { e.preventDefault(); row.remove(); };
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    // Wrap table in a horizontal-scroll container so columns keep natural width
    const wrapper = document.createElement('div');
    wrapper.className = 'admin-table-wrapper';
    wrapper.appendChild(table);
    container.appendChild(wrapper);
    // Responsive: shrink font size for small screens
    table.style.fontSize = '0.95rem';
    return;
  }
  // ...existing code for Aesthetic mode...
  // (the original card-based rendering remains unchanged below)
  const slotArray=[];
  const processedBlockIds = new Set();
  Object.keys(slotsData).forEach(date=>{
    if(slotsData[date] && slotsData[date].length>0){
      slotsData[date].forEach(slot => {
        let booked = 0;
        if (slot.blockId && slot.blockDates) {
          // Block session: count unique emails in bookingMappingsCache
          const emails = new Set();
          if (bookingMappingsCache && typeof bookingMappingsCache === 'object') {
            Object.values(bookingMappingsCache).forEach(mapping => {
              const mappingTime = (mapping.slot || mapping.time || '').toString().trim();
              const mappingTitle = (mapping.title || '').toString().trim();
              const mappingEmail = (mapping.email || '').toString().trim().toLowerCase();
              const mappingDates = Array.isArray(mapping.blockDates) ? mapping.blockDates : [mapping.date];
              if (
                mappingTime === slot.time &&
                mappingTitle === slot.title &&
                mappingDates.some(d => slot.blockDates.includes(d))
              ) {
                emails.add(mappingEmail);
              }
            });
          }
          booked = emails.size;
          // Find all slots for this blockId across all blockDates to get max capacity
          let blockSlots = [];
          slot.blockDates.forEach(bd => {
            if (slotsData[bd]) {
              blockSlots = blockSlots.concat(slotsData[bd].filter(s => s.blockId === slot.blockId));
            }
          });
          const blockCapacity = blockSlots.length > 0 ? Math.max(...blockSlots.map(s => s.capacity || 1)) : (slot.capacity || 1);
          console.log('[BLOCK SPOT DEBUG - CARD]', {blockId: slot.blockId, blockDates: slot.blockDates, time: slot.time, title: slot.title, booked, spots: blockCapacity, emails: Array.from(emails)});
          if(!processedBlockIds.has(slot.blockId)) {
            processedBlockIds.add(slot.blockId);
            // Attach blockCapacity to slot for rendering
            slot.__blockCapacity = blockCapacity;
            slotArray.push({date: slot.blockDates[0], slot, isBlock: true});
          }
        } else {
          // Single session: count bookings in bookingMappingsCache
          if (bookingMappingsCache && typeof bookingMappingsCache === 'object') {
            booked = Object.values(bookingMappingsCache).filter(mapping => {
              const mappingTime = (mapping.slot || mapping.time || '').toString().trim();
              const mappingTitle = (mapping.title || '').toString().trim();
              const mappingDate = (mapping.date || '').toString().trim();
              return mappingTime === slot.time && mappingTitle === slot.title && mappingDate === date;
            }).length;
          }
          console.log('[SINGLE SPOT DEBUG - CARD]', {date, time: slot.time, title: slot.title, booked, spots: slot.numberOfSpots || 1});
          slotArray.push({date, slot, isBlock: false});
        }
      });
    }
  });
  if(slotArray.length===0){
    container.innerHTML=`
      <div class="empty-slots-message">
        <i class="fas fa-inbox"></i>
        <p>No available slots (all are full or no slots created)</p>
      </div>
    `;
    return;
  }
  slotArray.sort((a,b)=>{
    const dateCompare = new Date(a.date) - new Date(b.date);
    if(dateCompare !== 0) return dateCompare;
    return a.slot.time.localeCompare(b.slot.time);
  });

  // Remove duplicate slot cards by slotKey (prevents duplicate event handlers and emails)
  const seenSlotKeys = new Set();
  const uniqueSlotArray = [];
  slotArray.forEach(({date, slot, isBlock}) => {
    const slotKey = isBlock
      ? `BLOCK|${slot.blockId}|${slot.time}|${slot.title}`
      : `${date}|${slot.time}|${slot.title}`;
    if (!seenSlotKeys.has(slotKey)) {
      seenSlotKeys.add(slotKey);
      uniqueSlotArray.push({date, slot, isBlock});
    }
  });


  uniqueSlotArray.forEach(({date, slot, isBlock})=>{
    // ...existing card rendering code...
    const card=document.createElement('div');
    card.className='available-slot-card';

    // Create unique slot key for tracking expanded state
    const slotKey = isBlock 
      ? `BLOCK|${slot.blockId}|${slot.time}|${slot.title}`
      : `${date}|${slot.time}|${slot.title}`;

    // DEBUG: Track slotKey counts
    window.__slotKeyCounts = window.__slotKeyCounts || {};
    window.__slotKeyCounts[slotKey] = (window.__slotKeyCounts[slotKey] || 0) + 1;
    console.log(`[SLOT RENDER] Creating slot: ${slotKey}, count: ${window.__slotKeyCounts[slotKey]}, expandedSlotCards.has(${slotKey}) = ${expandedSlotCards.has(slotKey)}`);

    // Add data attributes for state tracking
    if (isBlock) {
      card.setAttribute('data-block-id', slot.blockId);
    }
    card.setAttribute('data-slot-key', slotKey);

    // Restore expanded state if this card was previously expanded
    const shouldBeExpanded = expandedSlotCards.has(slotKey);
    if (shouldBeExpanded) {
      card.classList.add('expanded');
      console.log(`[SLOT RENDER]   -> Added 'expanded' class to ${slotKey}`);
    }
    // ...existing code...
    // (no changes to card rendering logic)
    let booked = 0;
    let spots = isBlock ? (slot.__blockCapacity || slot.capacity || 1) : (slot.capacity || 1);
    let remaining = 0;
    if (isBlock) {
      // For block sessions, always use the booked value from bookingMappingsCache/emails.size
      // Find the correct booked value from the slotArray (already calculated)
      // Recalculate here for clarity
      const emails = new Set();
      if (bookingMappingsCache && typeof bookingMappingsCache === 'object') {
        Object.values(bookingMappingsCache).forEach(mapping => {
          const mappingTime = (mapping.slot || mapping.time || '').toString().trim();
          const mappingTitle = (mapping.title || '').toString().trim();
          const mappingEmail = (mapping.email || '').toString().trim().toLowerCase();
          const mappingDates = Array.isArray(mapping.blockDates) ? mapping.blockDates : [mapping.date];
          if (
            mappingTime === slot.time &&
            mappingTitle === slot.title &&
            mappingDates.some(d => (slot.blockDates || []).includes(d))
          ) {
            emails.add(mappingEmail);
          }
        });
      }
      booked = emails.size;
      spots = slot.__blockCapacity || slot.capacity || 1;
      remaining = spots - booked;
    } else {
      if (bookingsData && bookingsData[date]) {
        booked = bookingsData[date].filter(b => {
          const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
          const bTime = parts ? parts[1] : null;
          const titleMatch = b.match(/-\s*(.+?)\s*\(/);
          const bTitle = titleMatch ? titleMatch[1].trim() : null;
          return bTime === slot.time && bTitle === slot.title;
        }).length;
      } else {
        booked = (slot.bookedUsers || []).length;
      }
      remaining = spots - booked;
    }
    const endTime = slot.endTime || '??:??';
    const duration = slot.duration || '40';
    if(isBlock) {
      const blockDates = slot.blockDates || [];
      const priceDisplay = formatPrice(slot.price);
      const locationDisplay = slot.location ? slot.location : '';
      const priceLocationInfo = priceDisplay || locationDisplay ? `<div style="font-size: 0.8rem; color: #666; margin-top: 6px;">${priceDisplay}${priceDisplay && locationDisplay ? ' &bull; ' : ''}${locationDisplay}</div>` : '';
      spots = slot.__blockCapacity || slot.capacity || 1;
      remaining = spots - booked;
      card.innerHTML=`
        <div class="available-slot-info">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <div class="available-slot-date">
              <i class="fas fa-cube" style="color: #4CAF50; flex-shrink: 0;"></i>
              4-Week Block
            </div>
            <span class="block-session-badge">Block Session</span>
          </div>
          <div class="available-slot-times compact">
            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;"><strong style="font-size: 0.9rem; font-weight: 550; color: #000;">${slot.title}</strong> &bull; ${slot.time} &bull; <span style="color: #666;">(${booked}/${spots})</span></div>
          </div>
          <div class="available-slot-times" style="display: none;">
            <div style="font-weight: 600; margin-bottom: 4px;"><strong style="font-size: 0.95rem; color: #000;">${slot.title}</strong></div>
            <div style="font-size: 0.85rem; color: #666;">
              ${slot.time} - ${endTime} (${duration} min) - ${slot.sessionType}
            </div>
            ${priceLocationInfo}
            <div style="font-size: 0.8rem; color: #888; margin-top: 4px;">
              ${booked}/${spots} booked, ${remaining} spot${remaining!==1?'s':''} available
            </div>
            <div style="font-size: 0.8rem; color: #FF9800; font-weight: 600; margin-top: 8px;">
              <i class="fas fa-calendar-alt"></i> Dates: ${blockDates.map(d => formatDateForDisplay(d)).join(', ')}
            </div>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
          <button class="available-slot-edit-btn" style="background: #2196F3; color: #fff; border: none; border-radius: 6px; width: 32px; height: 32px; min-width: 32px; min-height: 32px; max-width: 32px; max-height: 32px; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; cursor: pointer; margin: 0; padding: 0; display: none;">
            <i class="fas fa-edit"></i>
          </button>
          <button class="available-slot-remove-btn" data-block-id="${slot.blockId}" style="background: #FF9800; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      const editBtn = card.querySelector('.available-slot-edit-btn');
      // Add event handler for edit button (session edit)
      if (editBtn) {
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          openEditSessionModal(slot, date);
        });
      }
      // Helper: create and show an empty modal for editing session (works for both block and single sessions)
      function openEditSessionModal(slot, date) {
        let modal = document.getElementById('editSessionModal');
        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'editSessionModal';
          modal.style.position = 'fixed';
          modal.style.inset = '0';
          modal.style.width = '100vw';
          modal.style.minHeight = '100dvh';
          modal.style.background = 'rgba(0,0,0,0.45)';
          modal.style.display = 'flex';
          modal.style.alignItems = 'center';
          modal.style.justifyContent = 'center';
          modal.style.zIndex = '10000';
          modal.style.padding = 'env(safe-area-inset-top, 0) env(safe-area-inset-right, 0) env(safe-area-inset-bottom, 0) env(safe-area-inset-left, 0)';
          document.body.appendChild(modal);
        } else {
          modal.style.display = 'flex';
        }
        // Build the modal content with editable fields
        // Use slot and date to prefill values
        const isBlock = !!slot.blockId;
        const blockDates = slot.blockDates || [];
        modal.innerHTML = `
          <div id="editSessionModalContent" style="background:#fff;padding:32px 16px 24px 16px;border-radius:10px;width:calc(100vw - 32px);max-width:400px;min-width:0;box-shadow:0 2px 16px rgba(0,0,0,0.18);position:relative;overflow-y:auto;max-height:80dvh;margin:0 auto;display:block;box-sizing:border-box;">
            <h2 style="margin-top:0;font-size:1.25rem;margin-bottom:18px;text-align:center;">Edit Session</h2>
            <form id="editSessionForm" autocomplete="off">
              <div style="margin-bottom:12px;">
                <label>Date${isBlock ? ' (first date)' : ''}<br><input type="date" id="editSessionDate" name="date" value="${isBlock ? (blockDates[0] || '') : (date || '')}" style="width:100%;padding:6px 8px;"></label>
              </div>
              <div style="margin-bottom:12px;">
                <label>Title<br><input type="text" id="editSessionTitle" name="title" value="${slot.title || ''}" style="width:100%;padding:6px 8px;"></label>
              </div>
              <div style="margin-bottom:12px;">
                <label>Capacity<br><input type="number" id="editSessionSpots" name="capacity" min="1" value="${slot.capacity || slot.numberOfSpots || 1}" style="width:100%;padding:6px 8px;"></label>
              </div>
              <div style="margin-bottom:12px;">
                <label>Session Type<br>
                  <select id="editSessionType" name="sessionType" style="width:100%;padding:6px 8px;">
                    <option value="group"${slot.sessionType === 'group' ? ' selected' : ''}>Group</option>
                    <option value="solo"${slot.sessionType === 'solo' ? ' selected' : ''}>Solo</option>
                  </select>
                </label>
              </div>
              <div style="margin-bottom:12px;">
                <label>Start Time<br><input type="time" id="editSessionStartTime" name="time" value="${slot.time || ''}" style="width:100%;padding:6px 8px;"></label>
              </div>
              <div style="margin-bottom:12px;">
                <label>Duration (minutes)<br><input type="number" id="editSessionDuration" name="duration" min="15" max="240" value="${slot.duration || 40}" style="width:100%;padding:6px 8px;"></label>
              </div>
              <div style="margin-bottom:12px;">
                <label>Price (Â£)<br><input type="number" id="editSessionPrice" name="price" min="0" step="0.01" value="${slot.price || ''}" style="width:100%;padding:6px 8px;"></label>
              </div>
              <div style="margin-bottom:12px;">
                <label>Location<br><input type="text" id="editSessionLocation" name="location" value="${slot.location || ''}" style="width:100%;padding:6px 8px;"></label>
              </div>
              ${isBlock ? `
                <div style="margin-bottom:12px;">
                  <label>Block Dates<br>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                      <input type="date" id="editSessionBlockDate1" name="blockDate1" value="${blockDates[0] || ''}" style="flex:1 1 120px;padding:6px 8px;">
                      <input type="date" id="editSessionBlockDate2" name="blockDate2" value="${blockDates[1] || ''}" style="flex:1 1 120px;padding:6px 8px;">
                      <input type="date" id="editSessionBlockDate3" name="blockDate3" value="${blockDates[2] || ''}" style="flex:1 1 120px;padding:6px 8px;">
                      <input type="date" id="editSessionBlockDate4" name="blockDate4" value="${blockDates[3] || ''}" style="flex:1 1 120px;padding:6px 8px;">
                    </div>
                  </label>
                </div>
              ` : ''}
              <div style="margin-top:18px;text-align:center;">
                <button type="submit" style="background:#2196F3;color:#fff;padding:8px 24px;border:none;border-radius:6px;font-size:1rem;font-weight:600;cursor:pointer;">Save Changes</button>
              </div>
            </form>
          </div>
        `;
        // Close modal if click outside modal content
        modal.onclick = function(ev) {
          if (ev.target === modal) {
            modal.style.display = 'none';
          }
        };
        // Add submit handler for editSessionForm
        setTimeout(() => {
          const form = document.getElementById('editSessionForm');
          if (form) {
            form.onsubmit = async function(e) {
              e.preventDefault();
              // Gather form values
              const isBlock = !!slot.blockId;
              const payload = {
                originalDate: date,
                originalTime: slot.time,
                originalTitle: slot.title,
                date: document.getElementById('editSessionDate').value,
                title: document.getElementById('editSessionTitle').value,
                capacity: parseInt(document.getElementById('editSessionSpots').value, 10),
                sessionType: document.getElementById('editSessionType').value,
                time: document.getElementById('editSessionStartTime').value,
                duration: parseInt(document.getElementById('editSessionDuration').value, 10),
                price: parseFloat(document.getElementById('editSessionPrice').value),
                location: document.getElementById('editSessionLocation').value,
                blockId: slot.blockId || null,
                isBlock: isBlock,
                blockDates: isBlock ? [
                  document.getElementById('editSessionBlockDate1').value,
                  document.getElementById('editSessionBlockDate2').value,
                  document.getElementById('editSessionBlockDate3').value,
                  document.getElementById('editSessionBlockDate4').value
                ].filter(Boolean) : undefined
              };
              try {
                const resp = await fetch('php/saveSlotsEdit.php', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
                });
                const result = await resp.json();
                if (result.status === 'ok') {
                  // Log emails of all users signed up to this session (debug)
                  let emails = [];
                  if (slot && Array.isArray(slot.bookedUsers)) {
                    emails = slot.bookedUsers.map(u => u.email).filter(Boolean);
                    if (emails.length > 0) {
                      console.log('%c[EDIT SESSION] USERS TO NOTIFY (bookedUsers):', 'color:#b91c1c;font-weight:bold;', emails);
                    } else {
                      console.log('%c[EDIT SESSION] No users signed up to this session (bookedUsers is empty)', 'color:#b91c1c;font-weight:bold;');
                    }
                  } else {
                    console.log('%c[EDIT SESSION] No bookedUsers array found on slot', 'color:#b91c1c;font-weight:bold;');
                  }

                  // PATCH: Update bookingMappings.json for all booked users in block
                  if (slot && slot.blockId && Array.isArray(slot.bookedUsers) && Array.isArray(payload.blockDates)) {
                    console.log('[BLOCK EDIT][MAPPING PATCH] Editing block bookingMappings for blockId:', slot.blockId, 'blockDates:', payload.blockDates, 'bookedUsers:', slot.bookedUsers);
                    for (const user of slot.bookedUsers) {
                      const editPayload = {
                        action: 'update',
                        name: user.name,
                        email: user.email,
                        status: slot.status || 'Pending',
                        date: null, // block bookings have date: null
                        time: payload.time,
                        title: payload.title,
                        blockId: slot.blockId,
                        blockDates: payload.blockDates
                      };
                      console.log('[BLOCK EDIT][MAPPING PATCH] Sending editBooking.php for user:', user.email, 'payload:', editPayload);
                      const editResp = await fetch('php/editBooking.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(editPayload)
                      });
                      let editResult = null;
                      try {
                        editResult = await editResp.json();
                      } catch (e) {
                        console.warn('[BLOCK EDIT][MAPPING PATCH] Could not parse editBooking.php response for', user.email, e);
                      }
                      console.log('[BLOCK EDIT][MAPPING PATCH] editBooking.php result for', user.email, editResult);
                    }
                  }

                  // Detect changed fields for email
                  const changedFields = {};
                  const fieldList = ['date','title','capacity','sessionType','time','duration','price','location'];
                  fieldList.forEach(field => {
                    let oldVal = slot[field];
                    let newVal = payload[field];
                    // For blockDates, compare arrays as strings
                    if (field === 'date' && slot.blockId && Array.isArray(slot.blockDates) && Array.isArray(payload.blockDates)) {
                      oldVal = slot.blockDates.join(',');
                      newVal = payload.blockDates.join(',');
                    }
                    if (typeof oldVal === 'number' && typeof newVal === 'string') newVal = parseFloat(newVal);
                    if (typeof oldVal === 'string' && typeof newVal === 'number') oldVal = parseFloat(oldVal);
                    if (oldVal !== undefined && newVal !== undefined && oldVal !== newVal) {
                      changedFields[field] = { old: oldVal, new: newVal };
                    }
                  });
                  // Send booking_edited email to each user
                  if (emails.length > 0 && Object.keys(changedFields).length > 0) {
                    emails.forEach(email => {
                      fetch('php/sendEmail.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                          email,
                          type: 'booking_edited',
                          title: payload.title,
                          slot: payload.time,
                          location: payload.location,
                          date: payload.date,
                          price: payload.price,
                          changedFields
                        })
                      }).then(r => r.json()).then(res => {
                        console.log('[EDIT SESSION] Sent booking_edited email to', email, res);
                      }).catch(e => {
                        console.warn('[EDIT SESSION] Failed to send booking_edited email to', email, e);
                      });
                    });
                  }

                  modal.style.display = 'none';
                  // Optionally, refresh slots UI
                  if (typeof renderAllAvailableSlots === 'function') renderAllAvailableSlots();
                } else {
                  alert('Failed to save changes: ' + (result.message || 'Unknown error'));
                }
              } catch (err) {
                alert('Error saving changes: ' + err);
              }
            }
          }
        }, 0);
      }
      const removeBtn = card.querySelector('.available-slot-remove-btn');
      // Show/hide edit button based on expanded state, just like delete
      if (editBtn) {
        if (card.classList.contains('expanded')) {
          editBtn.style.display = 'inline-flex';
        } else {
          editBtn.style.display = 'none';
        }
      }
      console.log('[DELETE BTN] Block session button found:', !!removeBtn);
      if (!removeBtn) return;
      // DEBUG: Track handler attachment
      window.__removeBtnCounts = window.__removeBtnCounts || {};
      window.__removeBtnCounts[slotKey] = (window.__removeBtnCounts[slotKey] || 0) + 1;
      console.log(`[REMOVE BTN] Attaching handler for slotKey: ${slotKey}, count: ${window.__removeBtnCounts[slotKey]}`);
      removeBtn.addEventListener('click', async (e)=>{
        console.log('[DELETE BTN] Block session delete clicked!');
        e.stopPropagation();
        // Fetch emails from bookings.json for this slot
        let emailsToNotify = [];
        const bookingsData = await getBookings();
        let sessionBookings = [];
        if (Array.isArray(bookingsData[date])) {
          sessionBookings = bookingsData[date].filter(b => {
            const match = b.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
            if (!match) return false;
            const bookingTime = match[1].trim();
            const bookingTitle = match[2].trim();
            return bookingTime === slot.time && bookingTitle === slot.title;
          });
        }
        // Extract emails from sessionBookings
        emailsToNotify = sessionBookings.map(b => {
          const match = b.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
          return match ? match[4].trim() : null;
        }).filter(e => !!e);
        // Deduplicate emails
        emailsToNotify = Array.from(new Set(emailsToNotify));
        if (emailsToNotify.length > 0) {
          console.log('[DELETE BTN] Emails of booked users (from bookings.json):', emailsToNotify);
        } else {
          console.log('[DELETE BTN] No booked users for this session (from bookings.json).');
        }
        // Send email to each booked user
        for (const email of emailsToNotify) {
          try {
            // Always use slot.time for slot, and robustly determine date
            let slotTime = slot.time || '';
            let dateToSend = '';
            if (slot.blockId && Array.isArray(slot.blockDates) && slot.blockDates.length > 0) {
              dateToSend = slot.blockDates[0];
            } else if (slot.date) {
              dateToSend = slot.date;
            } else if (typeof date !== 'undefined' && date) {
              dateToSend = date;
            }
            const payload = {
              email,
              type: 'session_deleted',
              title: slot.title,
              slot: slotTime,
              location: slot.location || '',
              date: dateToSend
            };
            if (slot.blockId && Array.isArray(slot.blockDates) && slot.blockDates.length > 0) {
              payload.blockDates = slot.blockDates;
            }
            if (!payload.slot || !payload.date) {
              console.warn(`[DELETE BTN] Skipping email to ${email}: missing slot or date`, payload);
              continue;
            }
            console.log('[DELETE BTN][DEBUG] Payload for', email, payload);
            const resp = await fetch('php/sendEmail.php', {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(payload)
            });
            let result = null;
            try {
              result = await resp.json();
            } catch (parseErr) {
              console.warn(`[DELETE BTN] Could not parse response for ${email}:`, parseErr);
            }
            if (result && result.success) {
              console.log(`[DELETE BTN] Email sent to ${email}`);
            } else {
              console.warn(`[DELETE BTN] Email FAILED for ${email}:`, result && result.error ? result.error : 'Unknown error');
            }
          } catch (err) {
            console.warn(`[DELETE BTN] Failed to send email to ${email}:`, err);
          }
        }
        // Cascade delete directly, no modal or cancelSession.php
        if (!await modalConfirm('Remove entire block session? This will delete all bookings and waitlist entries for this block.')) return;
        await deleteSessionBookingsAndWaitlist(slot.blockDates, slot.time, slot.title, slot.blockId);
        showToast('Block session deleted (cascade)');
        await renderAllAvailableSlots();
      }, { once: true });
    } else {
      const priceDisplay = slot.price ? `&pound;${typeof slot.price === 'number' ? slot.price.toFixed(2) : slot.price}` : '';
      const locationDisplay = slot.location ? slot.location : '';
      const priceLocationInfo = priceDisplay || locationDisplay ? `<div style="font-size: 0.8rem; color: #666;">${priceDisplay}${priceDisplay && locationDisplay ? ' &bull; ' : ''}${locationDisplay}</div>` : '';
      card.innerHTML=`
        <div class="available-slot-info">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <div class="available-slot-date">
              ${slot.sessionType === 'group' ?
                '<i class="fas fa-users" style="color: #4CAF50; flex-shrink: 0;"></i>' :
                '<i class="fas fa-user" style="color: #4CAF50; flex-shrink: 0;"></i>'}
              ${formatDateForDisplay(date)}
            </div>
            <span style="display: inline-block; padding: 2px 6px; border-radius: 10px; font-size: 0.6rem; font-weight: 600; text-transform: uppercase; background: #E3F2FD; color: #1565C0; white-space: nowrap;">Single</span>
          </div>
          <div class="available-slot-times compact">
            <strong style="font-size: 0.9rem; font-weight: 550; color: #000;">${slot.title}</strong> &bull; ${slot.time} &bull; <span style="color: #666;">(${booked}/${spots})</span>
          </div>
          <div class="available-slot-times" style="display: none;">
            <div style="font-weight: 600; margin-bottom: 4px;"><strong style="font-size: 0.95rem; color: #000;">${slot.title}</strong></div>
            <div style="font-size: 0.85rem; color: #666;">
              ${slot.time} - ${endTime} (${duration} min) - ${slot.sessionType}
            </div>
            ${priceLocationInfo}
            <div style="font-size: 0.8rem; color: #888; margin-top: 4px;">
              ${booked}/${spots} booked, ${remaining} spot${remaining!==1?'s':''} available
            </div>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 4px;">
          <button class="available-slot-edit-btn" style="background: #2196F3; color: #fff; border: none; border-radius: 6px; width: 32px; height: 32px; min-width: 32px; min-height: 32px; max-width: 32px; max-height: 32px; display: ${shouldBeExpanded ? 'inline-flex' : 'none'}; align-items: center; justify-content: center; font-size: 1.1rem; cursor: pointer; margin: 0; padding: 0;">
            <i class="fas fa-edit"></i>
          </button>
          <button class="available-slot-remove-btn" data-date="${date}" data-time="${slot.time}" style="width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `;
      const editBtn = card.querySelector('.available-slot-edit-btn');
      if (editBtn) {
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          openEditSessionModal(slot, date);
        });
      }
      const removeBtn=card.querySelector('.available-slot-remove-btn');
      if (!removeBtn) return;
      // Replace removeBtn with a clone to remove any existing event listeners
      const newRemoveBtn = removeBtn.cloneNode(true);
      removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);
      newRemoveBtn.addEventListener('click', async (e)=>{
        e.stopPropagation();
        // Fetch emails from bookings.json for this slot
        let emailsToNotify = [];
        const bookingsData = await getBookings();
        let sessionBookings = [];
        if (Array.isArray(bookingsData[date])) {
          sessionBookings = bookingsData[date].filter(b => {
            const match = b.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
            if (!match) return false;
            const bookingTime = match[1].trim();
            const bookingTitle = match[2].trim();
            return bookingTime === slot.time && bookingTitle === slot.title;
          });
        }
        // Extract emails from sessionBookings
        emailsToNotify = sessionBookings.map(b => {
          const match = b.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
          return match ? match[4].trim() : null;
        }).filter(e => !!e);
        // Deduplicate emails
        emailsToNotify = Array.from(new Set(emailsToNotify));
        if (emailsToNotify.length > 0) {
          console.log('[DELETE BTN] Emails of booked users (from bookings.json):', emailsToNotify);
        } else {
          console.log('[DELETE BTN] No booked users for this session (from bookings.json).');
        }
        // Send email to each booked user
        for (const email of emailsToNotify) {
          try {
            // Build payload matching backend expectations
            let slotTime = slot.time || '';
            let dateToSend = '';
            if (slot.blockId && Array.isArray(slot.blockDates) && slot.blockDates.length > 0) {
              dateToSend = slot.blockDates[0];
            } else if (slot.date) {
              dateToSend = slot.date;
            } else if (typeof date !== 'undefined' && date) {
              dateToSend = date;
            }
            const payload = {
              email,
              type: 'session_deleted',
              title: slot.title,
              slot: slotTime,
              location: slot.location || '',
              date: dateToSend
            };
            if (slot.blockId && Array.isArray(slot.blockDates) && slot.blockDates.length > 0) {
              payload.blockDates = slot.blockDates;
            }
            if (!payload.slot || !payload.date) {
              console.warn(`[DELETE BTN] Skipping email to ${email}: missing slot or date`, payload);
              continue;
            }
            console.log('[DELETE BTN][DEBUG] Payload for', email, payload);
            const resp = await fetch('php/sendEmail.php', {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(payload)
            });
            let result = null;
            try {
              result = await resp.json();
            } catch (parseErr) {
              console.warn(`[DELETE BTN] Could not parse response for ${email}:`, parseErr);
            }
            if (result && result.success) {
              console.log(`[DELETE BTN] Email sent to ${email}`);
            } else {
              console.warn(`[DELETE BTN] Email FAILED for ${email}:`, result && result.error ? result.error : 'Unknown error');
            }
          } catch (err) {
            console.warn(`[DELETE BTN] Failed to send email to ${email}:`, err);
          }
        }
        // Cascade delete directly, no modal or cancelSession.php
        if (slot.blockId) {
          if (!await modalConfirm('Remove entire block session? This will delete all bookings and waitlist entries for this block.')) return;
          await deleteSessionBookingsAndWaitlist(slot.blockDates, slot.time, slot.title, slot.blockId);
          showToast('Block session deleted (cascade)');
        } else {
          if (!await modalConfirm('Remove this session? This will delete all bookings and waitlist entries for this session.')) return;
          await deleteSessionBookingsAndWaitlist([date], slot.time, slot.title, null);
          showToast('Session deleted (cascade)');
        }
        await renderAllAvailableSlots();
      }, { once: true });
    }
    
    // Apply display styles for compact/expanded and edit button immediately
    const compactDiv = card.querySelector('.available-slot-times.compact');
    const expandedDiv = Array.from(card.querySelectorAll('.available-slot-times')).find(d => !d.classList.contains('compact'));
    const isExpanded = card.classList.contains('expanded');
    const editBtn = card.querySelector('.available-slot-edit-btn');
    if (compactDiv && expandedDiv) {
      if (isExpanded) {
        compactDiv.style.display = 'none';
        expandedDiv.style.display = '';
        if (editBtn) editBtn.style.display = 'inline-flex';
      } else {
        compactDiv.style.display = '';
        expandedDiv.style.display = 'none';
        if (editBtn) editBtn.style.display = 'none';
      }
    }
    
    // Add toggle functionality on card click
    card.addEventListener('click', (e) => {
      // Don't toggle if clicking the delete or edit button
      if (e.target.closest('.available-slot-remove-btn') || e.target.closest('.available-slot-edit-btn')) return;
      card.classList.toggle('expanded');
      const compactDiv = card.querySelector('.available-slot-times.compact');
      const expandedDiv = Array.from(card.querySelectorAll('.available-slot-times')).find(d => !d.classList.contains('compact'));
      const editBtn = card.querySelector('.available-slot-edit-btn');
      if (compactDiv) compactDiv.style.display = card.classList.contains('expanded') ? 'none' : '';
      if (expandedDiv) expandedDiv.style.display = card.classList.contains('expanded') ? '' : 'none';
      if (editBtn) editBtn.style.display = card.classList.contains('expanded') ? 'inline-flex' : 'none';
      // Update tracked state
      if (card.classList.contains('expanded')) {
        expandedSlotCards.add(slotKey);
      } else {
        expandedSlotCards.delete(slotKey);
      }
    });
    
    container.appendChild(card);
  });
}

// Helper function to delete all bookings and waitlist entries for a session
async function deleteSessionBookingsAndWaitlist(dates, time, title, blockId) {
  const logStyle = 'background: #9C27B0; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold;';
  const log = (msg, ...args) => console.log(`%c[CASCADE DELETE]`, logStyle, msg, ...args);
  
  log('=== STARTING CASCADE DELETE ===');
  log('Input params:', {dates, time, title, blockId});
  
  try {
    // Delete bookings (stored as strings in format "time - title (name) (email)")
    let bookingsData = await getBookings();
    log('Current bookings data:', bookingsData);
    const deletedBookings = [];
    const bookingEmails = [];

    for(const date of dates) {
      if(bookingsData[date]) {
        log(`Processing date ${date}, bookings:`, bookingsData[date]);
        const originalLength = bookingsData[date].length;
        bookingsData[date] = bookingsData[date].filter(b => {
          // Match booking string: "time - title (name) (email)" or block session variant
          const match = b.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
          if(!match) {
            log('Could not parse booking:', b);
            return true;
          }
          const bookingTime = match[1].trim();
          const bookingTitle = match[2].trim();
          const bookingEmail = match[4].trim();
          const timeMatch = bookingTime === time;
          const titleMatch = bookingTitle === title;
          // For block sessions, also check blockId if present in booking string (future-proof)
          let blockMatch = true;
          if (blockId) {
            // If blockId is encoded in booking string, check for it (optional, for future-proofing)
            blockMatch = b.includes(blockId);
            // If not present, still allow match (legacy)
            if (!b.includes('block_')) blockMatch = true;
          }
          log(`Checking booking "${b}"`, {bookingTime, bookingTitle, bookingEmail, timeMatch, titleMatch, blockMatch});
          if(timeMatch && titleMatch && blockMatch) {
            log('ðŸ”´ DELETING booking:', b);
            deletedBookings.push(b);
            bookingEmails.push(bookingEmail);
            return false;
          }
          return true;
        });
        const removed = originalLength - bookingsData[date].length;
        log(`Date ${date}: removed ${removed} bookings`);
        if(bookingsData[date].length === 0) {
          delete bookingsData[date];
        }
      }
    }

    log('ðŸ’¾ Saving updated bookings (and mappings via saveBookings.php)...');
    await saveBookings(bookingsData); // This will update both bookings.json and bookingMappings.json
    log('âœ… Bookings and mappings saved. Deleted bookings:', deletedBookings.length);

    // Delete session from availableSlots.json
    let slotsData = await getAvailableSlots();
    log('Current slots data (before filtering):', JSON.parse(JSON.stringify(slotsData)));
    let deletedSessions = 0;
    for(const date of dates) {
      if(slotsData[date]) {
        const originalLength = slotsData[date].length;
        slotsData[date] = slotsData[date].filter(slot => {
          // For block sessions, match blockId; for single, match time/title
          if (blockId) {
            const match = slot.blockId === blockId && slot.time === time && slot.title === title;
            if (match) log('ðŸ”´ DELETING session (block):', slot);
            return !match;
          } else {
            const match = slot.time === time && slot.title === title;
            if (match) log('ðŸ”´ DELETING session (single):', slot);
            return !match;
          }
        });
        deletedSessions += originalLength - slotsData[date].length;
        if(slotsData[date].length === 0) delete slotsData[date];
      }
    }
    log('Current slots data (after filtering):', JSON.parse(JSON.stringify(slotsData)));
    log('ðŸ’¾ Saving updated slots...');
    // Debug: Log the slotsData payload before saving (delete)
    console.log('[DEBUG] Payload to saveAvailableSlots (delete):', JSON.stringify(slotsData, null, 2));
    await saveAvailableSlots(slotsData);
    log('âœ… Slots saved. Deleted sessions:', deletedSessions);

    // (REMOVED) No need to delete bookingMappings directly; saveBookings.php handles this.

    // Delete waitlist entries
    let waitlistData = await getWaitlist();
    log('Current waitlist data:', waitlistData);
    const deletedWaitlist = [];
    for(const date of dates) {
      if(waitlistData[date]) {
        log(`Processing waitlist for date ${date}:`, waitlistData[date]);
        const originalLength = waitlistData[date].length;
        waitlistData[date] = waitlistData[date].filter(w => {
          const timeMatch = w.time === time;
          const titleMatch = w.title === title;
          let blockMatch;
          if (blockId) {
            blockMatch = (w.blockId === blockId);
          } else {
            blockMatch = (!w.blockId || w.blockId === null);
          }
          const shouldDelete = timeMatch && titleMatch && blockMatch;
          if(shouldDelete) {
            log('ðŸ”´ DELETING waitlist entry:', w);
            deletedWaitlist.push({email: w.email, date, time, title});
          }
          return !shouldDelete;
        });
        const removed = originalLength - waitlistData[date].length;
        log(`Date ${date}: removed ${removed} waitlist entries`);
        if(waitlistData[date].length === 0) {
          delete waitlistData[date];
        }
      }
    }
    log('ðŸ’¾ Saving updated waitlist...');
    await saveWaitlist(waitlistData);
    log('âœ… Waitlist saved. Deleted waitlist entries:', deletedWaitlist.length);

    log('=== CASCADE DELETE COMPLETE ===');
    log('âœ… Summary:', {
      deletedBookings: deletedBookings.length,
      deletedWaitlist: deletedWaitlist.length,
      deletedSessions,
      dates, time, title, blockId
    });
    return {
      deletedBookings: deletedBookings.length,
      deletedWaitlist: deletedWaitlist.length,
      deletedSessions
    };
  } catch(err) {
    console.log(`%c[CASCADE DELETE ERROR]`, 'background: #f44336; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold;', err);
    throw err;
  }
}

// --- Table Mode: Remove block session ---
async function removeBlockSession(blockId, time, title, blockDates) {
  if(!confirm('Remove entire 4-week block? This will also delete all bookings and waitlist entries for this session.')) return;
  try {
    let slotsDataCopy=await getAvailableSlots();
    let booked = 0;
    if (bookingMappingsCache && typeof bookingMappingsCache === 'object') {
      booked = Object.values(bookingMappingsCache).filter(mapping => {
        const mappingTime = (mapping.slot || mapping.time || '').toString().trim();
        const mappingTitle = (mapping.title || '').toString().trim();
        const mappingDate = (mapping.date || '').toString().trim();
        return mappingTime === slot.time && mappingTitle === slot.title && mappingDate === date;
      }).length;
    }
    const spots = slot.numberOfSpots || 1;
    const remaining = spots - booked;
    const endTime = slot.endTime || '??:??';
    const duration = slot.duration || '40';
    console.log('[SINGLE SPOT DEBUG - CARD]', {date, time: slot.time, title: slot.title, booked, spots});
    // Delete related bookings and waitlist entries
    await deleteSessionBookingsAndWaitlist(blockDates, time, title, blockId);
    
    await renderAllAvailableSlots();
    showToast(`Block deleted successfully (${deleted} sessions removed)`);
  } catch(err) {
    showToast('Error deleting block: ' + err.message, {error: true});
  }
}

// --- Table Mode: Remove single session ---
async function removeSingleSession(date, time, title) {
  if(!confirm('Remove this session? This will also delete all bookings and waitlist entries for this session.')) return;
  try {
    let slotsDataCopy=await getAvailableSlots();
    const dateSlots = slotsDataCopy[date];
    if(dateSlots) {
      const idx = dateSlots.findIndex(s => s.time === time && s.title === title && !s.blockId);
      if(idx >= 0) {
        dateSlots.splice(idx, 1);
        if(dateSlots.length === 0) {
          delete slotsDataCopy[date];
        }
        await saveAvailableSlots(slotsDataCopy);
        
        // Delete related bookings and waitlist entries
        await deleteSessionBookingsAndWaitlist([date], time, title, null);
        
        await renderAllAvailableSlots();
        showToast('Session deleted successfully');
      } else {
        showToast('Session not found - unable to delete', {error: true});
      }
    } else {
      showToast('No sessions found for this date', {error: true});
    }
  } catch(err) {
    showToast('Error deleting session: ' + err.message, {error: true});
  }
}

// --- simple hash function for stable booking IDs ---
function hashBooking(date, booking){
  let hash=0;
  const str=`${date}-${booking}`;
  for(let i=0; i<str.length; i++){
    const char=str.charCodeAt(i);
    hash=((hash<<5)-hash)+char;
    hash=hash & hash;
  }
  return 'bk-' + Math.abs(hash).toString(36);
}

// --- Render All Bookings With Modern Styling and Click Expansion ---
// ensure consistent admin table styles
function ensureAdminTableStyles() {
  if (document.getElementById('admin-table-styles')) return;
  const style = document.createElement('style');
  style.id = 'admin-table-styles';
  style.innerHTML = `
    .admin-table-wrapper { width: 100%; overflow-x: auto; }
    .admin-table { table-layout: fixed; width: 100%; border-collapse: collapse; min-width: 600px; }
    .admin-table th, .admin-table td { padding: 8px; word-break: break-word; white-space: normal; vertical-align: top; overflow-wrap: break-word; }
    .admin-table th { text-align: left; font-weight: 600; }
    .admin-table td { min-width: 60px; }
    .admin-table .actions div, .admin-table .col-actions div { display:flex; flex-direction:column !important; gap:6px; align-items:flex-start; }
    .admin-table th.col-date, .admin-table td.col-date { min-width: 90px; width: 12%; }
    .admin-table th.col-time, .admin-table td.col-time { min-width: 70px; width: 10%; }
    .admin-table th.col-title, .admin-table td.col-title { min-width: 120px; width: 20%; }
    .admin-table th.col-email, .admin-table td.col-email { min-width: 140px; width: 15%; }
    .admin-table th.col-actions, .admin-table td.col-actions { min-width: 100px; width: 12%; }
    .admin-table th.col-status, .admin-table td.col-status { min-width: 80px; width: 10%; }
    .admin-table th.col-price, .admin-table td.col-price { min-width: 70px; width: 8%; }
    .admin-table th.col-capacity, .admin-table td.col-capacity { min-width: 80px; width: 8%; }
    .admin-table th.col-name, .admin-table td.col-name { min-width: 100px; width: 13%; }
    .admin-table th.col-position, .admin-table td.col-position { min-width: 70px; width: 10%; }
    .admin-table th.col-capacity, .admin-table td.col-capacity { min-width: 80px; width: 8%; }
    .admin-table th.col-block, .admin-table td.col-block { min-width: 100px; width: 12%; }
    .block-session-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; background: #FFE0B2; color: #E65100; white-space: nowrap; }
  `;
  document.head.appendChild(style);
}

async function renderAllBookings(){
  await refreshBookingMappings();
  if (false && adminViewMode === 'table') {
        // --- Table View for All Bookings (Block Bookings as One Row) ---
        const allBookingsDiv = document.getElementById('allBookings');
        const bookings = await getBookings();
        const slotsData = await getAvailableSlots();
        allBookingsDiv.innerHTML = '';
        // Flatten bookings into array for grouping
        const bookingArray = [];
        Object.keys(bookings).forEach(date => {
          bookings[date].forEach((booking, idx) => {
            bookingArray.push({date, booking, idx});
          });
        });
        // Group block bookings
        const grouped = [];
        const processedBlockKeys = new Set();
        bookingArray.forEach(({date, booking, idx}) => {
          const parts = booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
          const time = parts ? parts[1] : '';
          const title = parts ? parts[2] : '';
          const name = parts ? parts[3] : '';
          const email = parts ? parts[4] : '';
          const slot = (slotsData[date]||[]).find(s => s.time === time && s.title === title) || {};
          const blockId = slot.blockId;
          if (blockId) {
            const blockKey = `${blockId}|${name}|${email}`;
            if (processedBlockKeys.has(blockKey)) return;
            processedBlockKeys.add(blockKey);
            // Find all dates for this block booking
            const blockDates = slot.blockDates || [];
            grouped.push({
              isBlock: true,
              name,
              email,
              title,
              time: time,
              dates: blockDates.join(', '),
              blockDates: blockDates,
              price: formatPrice(slot.price),
              status: getBookingStatus(email, blockDates[0] || date, time, title),
              blockId,
              remove: async () => {
                // Remove all bookings for this user/block
                console.log('ðŸ—‘ï¸ Deleting block booking:', { time, title, name, email, blockDates });
                const bookingsData = await getBookings();
                blockDates.forEach(d => {
                  if (bookingsData[d]) {
                    console.log('Before filter on date', d, ':', bookingsData[d]);
                    bookingsData[d] = bookingsData[d].filter(b => {
                      const shouldKeep = !(b.includes(time) && b.includes(title) && b.includes(`(${name})`) && b.includes(`(${email})`));
                      console.log('  Booking:', b, '-> Keep?', shouldKeep);
                      return shouldKeep;
                    });
                    console.log('After filter on date', d, ':', bookingsData[d]);
                    if (bookingsData[d].length === 0) delete bookingsData[d];
                  }
                });
                await saveBookings(bookingsData);
                await renderAllBookings();
              }
            });
          } else {
            grouped.push({
              isBlock: false,
              name,
              email,
              title,
              time: time,
              dates: date,
              dateRaw: date,
              price: formatPrice(slot.price),
              status: getBookingStatus(email, date, time, title),
              idx,
              remove: async () => {
                console.log('ðŸ—‘ï¸ Deleting non-block booking:', { date, time, title, name, email, idx });
                const bookingsData = await getBookings();
                if (!bookingsData[date]) return;
                console.log('Before filter:', bookingsData[date]);
                bookingsData[date] = bookingsData[date].filter((b, i) => {
                  const shouldKeep = i !== idx;
                  console.log(`  Index ${i} (${b}) -> Keep?`, shouldKeep);
                  return shouldKeep;
                });
                console.log('After filter:', bookingsData[date]);
                if (bookingsData[date].length === 0) delete bookingsData[date];
                await saveBookings(bookingsData);
                await renderAllBookings();
              }
            });
          }
        });
        // Build table
        const table = document.createElement('table');
        table.className = 'admin-table';
        table.style.tableLayout = 'auto';
        const thead = document.createElement('thead');
        thead.innerHTML = `<tr>
          <th>Name</th>
          <th>Email</th>
          <th>Session Title</th>
          <th>Session Date(s)</th>
          <th>Â£ Due</th>
          <th>Status</th>
          <th class='actions'>Actions</th>
        </tr>`;
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        grouped.forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(row.name)}</td><td style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(row.email)}</td><td style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(row.title)}</td><td style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(row.dates)}</td><td style="white-space:nowrap;">${row.price}</td><td style="white-space:nowrap;">${row.status}</td><td class='actions'><a href="#" class="delete-link" style="color:#0074d9;text-decoration:underline;border:none;background:none;padding:0;">Delete</a></td>`;
          tr.querySelector('.delete-link').onclick = function(e) { e.preventDefault(); row.remove(); };
          // make first (name), third (title) and fourth (dates) columns wrap words
          try {
            const tds = tr.querySelectorAll('td');
            if (tds[0]) {
              tds[0].classList.add('wrap-words');
            }
            // Email column: ensure it stays single-line and truncates with ellipsis
            if (tds[1]) {
              tds[1].style.overflow = 'hidden';
              tds[1].style.textOverflow = 'ellipsis';
              tds[1].style.whiteSpace = 'nowrap';
            }
            if (tds[2]) {
              tds[2].classList.add('wrap-words');
            }
            if (tds[3]) {
              tds[3].classList.add('wrap-words');
            }
          } catch (e) { /* ignore */ }
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        const wrapper = document.createElement('div');
        wrapper.className = 'admin-table-wrapper';
        wrapper.appendChild(table);
        allBookingsDiv.appendChild(wrapper);
        return;
      }
      if (false && adminViewMode === 'table') {
        await renderAllAvailableSlotsTableUltraSimple();
        return;
      }
    // --- Ultra-Simple Table View Renderer for Sessions ---
    async function renderAllAvailableSlotsTableUltraSimple() {
      const container = document.getElementById('allAvailableSlots');
      const slotsData = await getAvailableSlots();
      const bookingsData = await getBookings();
      container.innerHTML = '';
      const table = document.createElement('table');
      table.className = 'admin-table';
      const thead = document.createElement('thead');
      thead.innerHTML = `<tr><th style="width:14%">Date</th><th style="width:11%">Time</th><th style="width:9%">Capacity</th><th style="width:20%">Title</th><th style="width:12%">Type</th><th style="width:10%">Price</th><th style="width:10%">Status</th><th class='actions' style="width:8%">Actions</th></tr>`;
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      Object.keys(slotsData).forEach(date => {
        slotsData[date].forEach((slot, idx) => {
          const booked = (bookingsData[date]||[]).filter(b => b.includes(slot.time) && b.includes(slot.title)).length;
          const status = booked >= (slot.numberOfSpots||1) ? 'Full' : 'Available';
          const price = formatPrice(slot.price);
          const tr = document.createElement('tr');
          const capacity = `${booked}/${slot.numberOfSpots || 1}`;
          tr.innerHTML = `<td>${escapeHtml(date)}</td><td>${escapeHtml(slot.time)}</td><td>${escapeHtml(capacity)}</td><td style="max-width:120px">${escapeHtml(slot.title)}</td><td>${escapeHtml(slot.sessionType||'')}</td><td>${price}</td><td>${status}</td><td class='actions'><button class='delete' data-date='${escapeHtml(date)}' data-idx='${idx}'>Delete</button></td>`;
          tbody.appendChild(tr);
        });
      });
      table.appendChild(tbody);
      const wrapper = document.createElement('div');
      wrapper.className = 'admin-table-wrapper';
      wrapper.appendChild(table);
      container.appendChild(wrapper);
      container.querySelectorAll('button.delete').forEach(btn => {
        btn.onclick = async (e) => {
          const date = btn.getAttribute('data-date');
          const idx = parseInt(btn.getAttribute('data-idx'));
          const slotsData = await getAvailableSlots();
          if (!slotsData[date]) return;
          slotsData[date].splice(idx, 1);
          if (slotsData[date].length === 0) delete slotsData[date];
          await saveAvailableSlots(slotsData);
          await renderAllAvailableSlotsTableUltraSimple();
        };
      });
    }
    if (adminViewMode === 'table') {
      await renderAllBookingsTable();
      return;
    }
  // --- Table View Renderer for Bookings ---
  async function renderAllBookingsTable() {
    console.log('renderAllBookingsTable: start');
    await refreshBookingMappings();
    ensureAdminTableStyles();
    const allBookingsDiv = document.getElementById('allBookings');
    const bookings = await getBookings();
    const slotsData = await getAvailableSlots();
    allBookingsDiv.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'admin-table';
    table.style.width = '100%';
    table.style.tableLayout = 'fixed';
    const thead = document.createElement('thead');
    thead.innerHTML = `<tr><th>Date</th><th>Booking</th><th>Actions</th></tr>`;
    thead.innerHTML = `<tr>
      <th class="col-date">Date</th>
      <th class="col-time">Time</th>
      <th class="col-title">Title</th>
      <th class="col-title">Type</th>
      <th class="col-price">Price</th>
      <th class="col-status">Status</th>
      <th class="col-block">Block/Single Session</th>
      <th class="col-actions actions">Actions</th>
    </tr>`;
    table.appendChild(thead);
    const tbody = document.createElement('tbody');

    // Flatten bookings into array for grouping block sessions
    const bookingArray = [];
    Object.keys(bookings).forEach(date => {
      (bookings[date] || []).forEach((bk, idx) => bookingArray.push({ date, booking: bk, idx }));
    });

    // Group block bookings: key by blockId + user to ensure single row per block booking
    const grouped = [];
    const processedBlockKeys = new Set();
    bookingArray.forEach(({ date, booking, idx }) => {
      const parts = booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
      const time = parts ? parts[1] : '';
      const title = parts ? parts[2] : '';
      const name = parts ? parts[3] : '';
      const email = parts ? parts[4] : '';
      const slot = (slotsData[date] || []).find(s => s.time === time && s.title === title) || {};
      const blockId = slot.blockId;

      if (blockId) {
        const blockKey = `${blockId}|${name}|${email}|${title}|${time}`;
        if (processedBlockKeys.has(blockKey)) return;
        // collect all dates for this block booking for this user/slot
        const blockDates = [];
        bookingArray.forEach(item => {
          const p = item.booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
          const itime = p ? p[1] : '';
          const ititle = p ? p[2] : '';
          const iname = p ? p[3] : '';
          const iemail = p ? p[4] : '';
          if (iname === name && iemail === email && itime === time && ititle === title) {
            blockDates.push(item.date);
          }
        });
        processedBlockKeys.add(blockKey);
        grouped.push({
          isBlock: true,
          dates: Array.from(new Set(blockDates)).sort(),
          time,
          title,
          name,
          email,
          slotInfo: slot
        });
      } else {
        // single booking
        grouped.push({ isBlock: false, date, time, title, name, email, idx, slotInfo: slot });
      }
    });

    // Render grouped rows
    grouped.forEach((g, rowIdx) => {
      const tr = document.createElement('tr');
      if (g.isBlock) {
        const dateHtml = g.dates.map(d => formatDateDDMMYY(d)).join('<br>');
        const price = formatPrice(g.slotInfo?.price);
        const type = g.slotInfo?.sessionType || '';
        const status = getBookingStatus(g.email, g.dates[0], g.time, g.title);
        const showConfirm = status !== 'Confirmed';
        const blockBadge = `<span class="block-session-badge">Block Session</span>`;
        const actionsHtml = `${showConfirm ? `<button class="confirm" data-email="${escapeHtml(g.email)}" data-date="${escapeHtml(g.dates[0])}" data-time="${escapeHtml(g.time)}" data-title="${escapeHtml(g.title)}" data-name="${escapeHtml(g.name)}" data-block-dates="${escapeHtml(g.dates.join(','))}" style="margin-right:8px;">Confirm</button>` : ''}<button class='delete' data-is-block='true' data-block-dates='${escapeHtml(g.dates.join(','))}' data-title='${escapeHtml(g.title)}' data-time='${escapeHtml(g.time)}' data-email='${escapeHtml(g.email)}'>Delete</button>`;
        tr.innerHTML = `<td class="col-date">${dateHtml}</td>` +
                       `<td class=\"col-time\">${escapeHtml(g.time)}</td>` +
                       `<td class=\"col-title\">${escapeHtml(g.title)}</td>` +
                       `<td class=\"col-title\">${escapeHtml(type)}</td>` +
                       `<td class=\"col-price\">${price}</td>` +
                       `<td class=\"col-status\">${escapeHtml(status)}</td>` +
                       `<td class=\"col-block\">${blockBadge}</td>` +
                       `<td class=\"col-actions\"><div class=\"admin-action-stack\" style=\"display:flex;flex-direction:column;gap:6px;align-items:center;\">${actionsHtml}</div></td>`;
      } else {
        const date = g.date;
        const price = formatPrice(g.slotInfo?.price);
        const type = g.slotInfo?.sessionType || '';
        const status = getBookingStatus(g.email, date, g.time, g.title);
        const showConfirm = status !== 'Confirmed';
        const actionsHtml = `${showConfirm ? `<button class="confirm" data-email="${escapeHtml(g.email)}" data-date="${escapeHtml(date)}" data-time="${escapeHtml(g.time)}" data-title="${escapeHtml(g.title)}" data-name="${escapeHtml(g.name)}" style="margin-right:8px;">Confirm</button>` : ''}<button class='delete' data-date='${escapeHtml(date)}' data-index='${g.idx}' data-slot-time='${escapeHtml(g.time)}' data-slot-title='${escapeHtml(g.title)}' data-name='${escapeHtml(g.name)}' data-email='${escapeHtml(g.email)}'>Delete</button>`;
        tr.innerHTML = `<td class="col-date">${escapeHtml(date)}</td>` +
                       `<td class=\"col-time\">${escapeHtml(g.time)}</td>` +
                       `<td class=\"col-title\">${escapeHtml(g.title)}</td>` +
                       `<td class=\"col-title\">${escapeHtml(type)}</td>` +
                       `<td class=\"col-price\">${price}</td>` +
                       `<td class=\"col-status\">${escapeHtml(status)}</td>` +
                       `<td class=\"col-block\"></td>` +
                       `<td class=\"col-actions\"><div class=\"admin-action-stack\" style=\"display:flex;flex-direction:column;gap:6px;align-items:center;\">${actionsHtml}</div></td>`;
      }
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    const wrapper = document.createElement('div');
    wrapper.className = 'admin-table-wrapper';
    wrapper.appendChild(table);
    allBookingsDiv.appendChild(wrapper);
    // Debug: report number of rows and confirm buttons appended
    try {
      const rowCount = wrapper.querySelectorAll('tbody tr').length;
      const confirmCount = wrapper.querySelectorAll('button.confirm').length;
      console.log('renderAllBookingsTable: appended wrapper', { rowCount, confirmCount });
      // Show a short preview of the actions column HTML for the first 5 rows
      try {
        const previews = Array.from(wrapper.querySelectorAll('tbody tr')).slice(0,5).map((r,i)=>({i, actions: (r.querySelector('td:last-child')||{}).innerHTML?.slice(0,200) }));
        console.log('renderAllBookingsTable: actions previews (first 5 rows)', previews);
      } catch(e) { console.log('renderAllBookingsTable: preview error', e); }
    } catch (e) { console.log('renderAllBookingsTable: debug error', e); }
    // Attach delete handlers (handle block and single bookings)
    allBookingsDiv.querySelectorAll('button.delete').forEach(btn => {
      btn.onclick = async (e) => {
        e.preventDefault();
        if (!confirm('Are you sure you want to delete this booking?')) return;
        const isBlock = btn.getAttribute('data-is-block') === 'true';
        let bookingsData = await getBookings();
        let slotsCopy = await getAvailableSlots();

        if (isBlock) {
          const blockDatesStr = btn.getAttribute('data-block-dates') || '';
          const blockDates = blockDatesStr ? blockDatesStr.split(',') : [];
          const email = btn.getAttribute('data-email') || '';
          const title = btn.getAttribute('data-title') || '';
          const time = btn.getAttribute('data-time') || '';

          for (const d of blockDates) {
            if (bookingsData[d]) {
              bookingsData[d] = bookingsData[d].filter(b => {
                const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
                const bt = parts ? parts[1] : '';
                const bt_title = parts ? parts[2] : '';
                const bt_email = parts ? parts[4] : '';
                return !(bt === time && bt_title === title && bt_email === email);
              });
              if (bookingsData[d].length === 0) delete bookingsData[d];
            }

            // Also remove from slots' bookedUsers if present
            if (slotsCopy[d]) {
              slotsCopy[d].forEach(s => {
                if (s.time === time && s.title === title && Array.isArray(s.bookedUsers)) {
                  s.bookedUsers = s.bookedUsers.filter(u => u.email !== email);
                }
              });
            }
          }
        } else {
          const date = btn.getAttribute('data-date');
          const idx = parseInt(btn.getAttribute('data-idx'));
          if (bookingsData[date]) {
            // remove by index if present
            if (!isNaN(idx)) {
              bookingsData[date].splice(idx, 1);
            } else {
              // fallback: attempt to remove by data attributes if index missing
              const email = btn.getAttribute('data-email');
              const name = btn.getAttribute('data-name');
              const time = btn.getAttribute('data-time');
              const title = btn.getAttribute('data-title');
              bookingsData[date] = bookingsData[date].filter(b => {
                // Keep bookings that don't match this specific time+title+name+email combo
                return !(b.includes(time) && b.includes(title) && b.includes(`(${name})`) && b.includes(`(${email})`));
              });
            }
            if (bookingsData[date].length === 0) delete bookingsData[date];
          }

          // Also remove from slots bookedUsers if dataset provided
          const time = btn.getAttribute('data-time');
          const title = btn.getAttribute('data-title');
          const email = btn.getAttribute('data-email');
          if (date && slotsCopy[date]) {
            slotsCopy[date].forEach(s => {
              if (s.time === time && s.title === title && Array.isArray(s.bookedUsers)) {
                s.bookedUsers = s.bookedUsers.filter(u => u.email !== email);
              }
            });
          }
        }

        console.log('[CASCADE DELETE DEBUG] Cascade delete starting:', {bookingsData, slotsCopy, blockDates, date, time, title, email, name});
        await saveBookings(bookingsData);
        try { await saveAvailableSlots(slotsCopy); } catch(e) { console.log('[CASCADE DELETE DEBUG] saveAvailableSlots error:', e); }
        console.log('[CASCADE DELETE DEBUG] Cascade delete finished.');
        showToast('Booking deleted (cascade) even if email failed.', {error: false});
        await renderAllBookingsTable();
      };
    });

    // Attach confirm handlers (handle block sessions by passing blockDates array)
    const confirmButtons = allBookingsDiv.querySelectorAll('button.confirm');
    console.log('renderAllBookingsTable: confirmButtons found count', confirmButtons.length);
    confirmButtons.forEach((btn, idx) => {
      try {
        console.log(`renderAllBookingsTable: confirmButtons[${idx}] dataset`, {
          email: btn.getAttribute('data-email'),
          date: btn.getAttribute('data-date'),
          time: btn.getAttribute('data-time'),
          title: btn.getAttribute('data-title'),
          name: btn.getAttribute('data-name'),
          blockDates: btn.getAttribute('data-block-dates')
        });
      } catch(e) { console.log('renderAllBookingsTable: dataset read error', e); }

      btn.onclick = async (e) => {
        e.preventDefault();
        const email = btn.getAttribute('data-email');
        const date = btn.getAttribute('data-date');
        const time = btn.getAttribute('data-time');
        const title = btn.getAttribute('data-title');
        const name = btn.getAttribute('data-name');
        const blockDatesStr = btn.getAttribute('data-block-dates') || '';
        const blockDates = blockDatesStr ? blockDatesStr.split(',') : [];
        console.log('renderAllBookingsTable: confirm clicked', { email, date, time, title, name, blockDates });
        let emailResult = null;
        try {
          if (blockDates.length) {
            emailResult = await adminSendConfirmation(email, date, time, title, name, blockDates);
          } else {
            emailResult = await adminSendConfirmation(email, date, time, title, name);
          }
        } catch (err) {
          console.warn('Email send failed, proceeding with cascade delete:', err);
        }
        // Always cascade delete booking and slot, even if email send fails
        let bookingsData = await getBookings();
        let slotsCopy = await getAvailableSlots();
        if (blockDates.length) {
          for (const d of blockDates) {
            if (bookingsData[d]) {
              bookingsData[d] = bookingsData[d].filter(b => {
                const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
                const bt = parts ? parts[1] : '';
                const bt_title = parts ? parts[2] : '';
                const bt_email = parts ? parts[4] : '';
                return !(bt === time && bt_title === title && bt_email === email);
              });
              if (bookingsData[d].length === 0) delete bookingsData[d];
            }
            if (slotsCopy[d]) {
              slotsCopy[d].forEach(s => {
                if (s.time === time && s.title === title && Array.isArray(s.bookedUsers)) {
                  s.bookedUsers = s.bookedUsers.filter(u => u.email !== email);
                }
              });
            }
          }
        } else {
          if (bookingsData[date]) {
            bookingsData[date] = bookingsData[date].filter(b => {
              return !(b.includes(time) && b.includes(title) && b.includes(`(${name})`) && b.includes(`(${email})`));
            });
            if (bookingsData[date].length === 0) delete bookingsData[date];
          }
          if (slotsCopy[date]) {
            slotsCopy[date].forEach(s => {
              if (s.time === time && s.title === title && Array.isArray(s.bookedUsers)) {
                s.bookedUsers = s.bookedUsers.filter(u => u.email !== email);
              }
            });
          }
        }
        await saveBookings(bookingsData);
        try { await saveAvailableSlots(slotsCopy); } catch(e) { /* non-fatal */ }
        await renderAllBookingsTable();
      };
    });
  }
    if (adminViewMode === 'table') {
      await renderAllAvailableSlotsTable();
      return;
    }
  // --- Table View Renderer for Slots ---
  async function renderAllAvailableSlotsTable() {
    const container = document.getElementById('allAvailableSlots');
    ensureAdminTableStyles();
    const slotsData = await getAvailableSlots();
    container.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'admin-table';
    table.style.width = '100%';
    table.style.tableLayout = 'fixed';
    const thead = document.createElement('thead');
    thead.innerHTML = `<tr><th class="col-date">Date</th><th class="col-time">Time</th><th class="col-capacity">Capacity</th><th class="col-title">Title</th><th class="col-title">Type</th><th class="col-price">Price</th><th class="col-status">Status</th><th class="col-block">Block/Single Session</th><th class="col-actions actions">Actions</th></tr>`;
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    Object.keys(slotsData).forEach(date => {
      slotsData[date].forEach((slot, idx) => {
        const tr = document.createElement('tr');
        const booked = Array.isArray(slot.bookedUsers) ? slot.bookedUsers.length : 0;
        const spots = slot.numberOfSpots || 1;
        const capacity = `${booked}/${spots}`;
        const price = formatPrice(slot.price);
        const status = booked >= spots ? 'Full' : 'Available';
        const blockBadge = slot.blockId ? `<span class="block-session-badge">Block Session</span>` : '';
        tr.innerHTML = `<td class="col-date">${escapeHtml(date)}</td><td class="col-time">${escapeHtml(slot.time)}</td><td class="col-capacity">${escapeHtml(capacity)}</td><td class="col-title">${escapeHtml(slot.title)}</td><td class="col-title">${escapeHtml(slot.sessionType || '')}</td><td class="col-price">${price}</td><td class="col-status">${status}</td><td class="col-block">${blockBadge}</td><td class="col-actions"><button class='delete' data-date='${escapeHtml(date)}' data-idx='${idx}'>Delete</button></td>`;
        tbody.appendChild(tr);
      });
    });
    table.appendChild(tbody);
    const wrapper = document.createElement('div');
    wrapper.className = 'admin-table-wrapper';
    wrapper.appendChild(table);
    container.appendChild(wrapper);
    // Attach delete handlers
    container.querySelectorAll('button.delete').forEach(btn => {
      btn.onclick = async (e) => {
        const date = btn.getAttribute('data-date');
        const idx = parseInt(btn.getAttribute('data-idx'));
        const slotsData = await getAvailableSlots();
        if (!slotsData[date]) return;
        slotsData[date].splice(idx, 1);
        if (slotsData[date].length === 0) delete slotsData[date];
        await saveAvailableSlots(slotsData);
        await renderAllAvailableSlotsTable();
      };
    });
  }
  // console.log('renderAllBookings called');
  const allBookingsDiv=document.getElementById('allBookings');
  const bookingMappings=await getBookingMappings();
  const slotsData=await getAvailableSlots();

  let totalBookings=0;
  const bookingArray=[];
  const currentBookingIds=new Set();
  const processedBlockBookings = new Set(); // Track block bookings to avoid duplicates

  // Collect all bookings from bookingMappings, including block bookings with date=null and blockDates present
  Object.keys(bookingMappings).forEach(bookingId => {
    const mapping = bookingMappings[bookingId];
    // Single booking (date present)
    if (mapping && mapping.date && mapping.slot && mapping.title && mapping.email) {
      totalBookings++;
      currentBookingIds.add(bookingId);
      bookingArray.push({
        date: mapping.date,
        booking: `${mapping.slot} - ${mapping.title} (${mapping.name || ''}) (${mapping.email})`,
        index: 0, // index not used for mappings
        bookingId
      });
    }
    // Block booking (date null, blockDates present)
    else if (mapping && !mapping.date && Array.isArray(mapping.blockDates) && mapping.blockDates.length > 0 && mapping.slot && mapping.title && mapping.email) {
      mapping.blockDates.forEach(blockDate => {
        totalBookings++;
        currentBookingIds.add(bookingId + '-' + blockDate);
        bookingArray.push({
          date: blockDate,
          booking: `${mapping.slot} - ${mapping.title} (${mapping.name || ''}) (${mapping.email})`,
          index: 0,
          bookingId
        });
      });
    }
  });

  // Build a quick lookup map of booked counts per date/time/title from bookings.json
  const bookedCounts = {}; // key: `${date}|${time}|${title}` => count
  bookingArray.forEach(({date, booking}) => {
    const parts = booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
    const time = parts ? parts[1] : 'Unknown';
    const title = parts ? parts[2] : 'Session';
    const key = `${date}|${time}|${title}`;
    bookedCounts[key] = (bookedCounts[key] || 0) + 1;
  });
  
  if(totalBookings===0){
    allBookingsDiv.innerHTML=`
      <div class="empty-bookings">
        <i class="fas fa-inbox"></i>
        <p>No bookings yet</p>
      </div>
    `;
    return;
  }
  
  // Remove empty state if it exists
  const emptyState=allBookingsDiv.querySelector('.empty-bookings');
  if(emptyState) emptyState.remove();
  
  // Save the ID of the currently expanded booking before clearing
  const expandedBookingId=expandedBooking?.getAttribute('data-booking-id') || null;
  
  // Clear existing cards
  allBookingsDiv.innerHTML='';
  
  // Sort by date (newest first)
  bookingArray.sort((a,b)=>new Date(b.date)-new Date(a.date));
  
  // Group block bookings: find bookings with same user/time across multiple dates
  const groupedBookings = [];
  const seenBookingKeys = new Set();
  
  bookingArray.forEach(({date, booking, index, bookingId}) => {
    const parts = booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
    const time = parts ? parts[1] : 'Unknown';
    const title = parts ? parts[2] : 'Session';
    const name = parts ? parts[3] : 'Unknown';
    const email = parts ? parts[4] : 'N/A';
    const bookingKey = `${time}-${title}-${name}-${email}`;
    
    // Find slot to check if it's a block session
    const slotInfo = slotsData[date]?.find(s => s.time === time && s.title === title);
    const isBlockSession = slotInfo?.blockId && slotInfo?.blockDates;
    
    if (isBlockSession && !processedBlockBookings.has(bookingKey)) {
      // This is a block booking - collect all dates for this user/slot
      const blockDates = [];
      const blockBookingIndices = [];
      
      bookingArray.forEach(item => {
        const itemParts = item.booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
        const itemTime = itemParts ? itemParts[1] : 'Unknown';
        const itemTitle = itemParts ? itemParts[2] : 'Session';
        const itemName = itemParts ? itemParts[3] : 'Unknown';
        const itemEmail = itemParts ? itemParts[4] : 'N/A';
        const itemKey = `${itemTime}-${itemTitle}-${itemName}-${itemEmail}`;
        
        if (itemKey === bookingKey) {
          blockDates.push(item.date);
          blockBookingIndices.push({date: item.date, index: item.index});
        }
      });
      
      processedBlockBookings.add(bookingKey);
      groupedBookings.push({
        type: 'block',
        date: blockDates[0], // Use first date for sorting
        booking,
        bookingKey,
        blockDates: blockDates.sort(),
        blockBookingIndices,
        slotInfo,
        time,
        title,
        name,
        email
      });
    } else if (!isBlockSession && !seenBookingKeys.has(bookingKey + date)) {
      // Regular single session booking
      seenBookingKeys.add(bookingKey + date);
      groupedBookings.push({
        type: 'single',
        date,
        booking,
        index,
        bookingId,
        slotInfo,
        time,
        title,
        name,
        email
      });
    }
  });
  
  // Sort grouped bookings by date (newest first)
  groupedBookings.sort((a,b) => new Date(b.date) - new Date(a.date));
  
  // Group bookings by session (date, time, title)
  const sessionMap = new Map(); // key: ${date}|${time}|${title} => { slotInfo, bookings: [...] }
  
  groupedBookings.forEach(bookingGroup => {
    const {date, time, title, slotInfo} = bookingGroup;
    const isBlockSession = bookingGroup.type === 'block';
    const sessionKey = isBlockSession 
      ? `BLOCK|${bookingGroup.blockDates[0]}|${time}|${title}` 
      : `${date}|${time}|${title}`;
    
    if (!sessionMap.has(sessionKey)) {
      sessionMap.set(sessionKey, {
        isBlockSession,
        date: date,
        time: time,
        title: title,
        blockDates: isBlockSession ? bookingGroup.blockDates : null,
        slotInfo: slotInfo,
        bookings: []
      });
    }
    
    sessionMap.get(sessionKey).bookings.push(bookingGroup);
  });
  
  // Render session cards with expandable bookings inside
  sessionMap.forEach((sessionData) => {
    const {isBlockSession, date, time, title, blockDates, slotInfo, bookings} = sessionData;
    const sessionType = slotInfo?.sessionType || 'group';
    const priceDisplay = formatPrice(slotInfo?.price);
    const locationDisplay = slotInfo?.location ? slotInfo.location : '';
    const priceLocationInfo = priceDisplay || locationDisplay ? `<div style="font-size: 0.85rem; color: #666; margin-top: 6px;">${priceDisplay}${priceDisplay && locationDisplay ? ' &bull; ' : ''}${locationDisplay}</div>` : '';
    const sessionBadge = `<span style="display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; margin-left: 8px; background: ${sessionType==='group'?'#dbeafe':'#fce7f3'}; color: ${sessionType==='group'?'#1e40af':'#be185d'};\">${sessionType}</span>`;
    const blockBadge = slotInfo?.blockId ? '<span style="display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; margin-left: 8px; background: #FFE0B2; color: #E65100;">4-Week Block</span>' : '';
    
    // Create unique session key for tracking expanded state
    const sessionKey = isBlockSession 
      ? `BLOCK|${blockDates[0]}|${time}|${title}` 
      : `${date}|${time}|${title}`;
    const isSessionExpanded = expandedSessionCards.has(sessionKey);
    
    // Create session container card
    const sessionCard = document.createElement('div');
    sessionCard.style.cssText = 'margin-bottom: 12px; border-radius: 10px; overflow: hidden;';
    
    // Create session header
    const headerDiv = document.createElement('div');
    headerDiv.className = 'all-booking-card confirmed';
    headerDiv.style.cssText = 'cursor: pointer; margin-bottom: 0; border-radius: 10px 10px 0 0;';
    headerDiv.setAttribute('data-session-key', sessionKey); // Store session key for state restoration
    
    const headerHTML = `
      <div class="booking-header">
        <div class="booking-header-info">
          <div style="font-weight: 600; color: #333; font-size: clamp(0.85rem, 2vw, 0.95rem); display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
            ${isBlockSession
              ? `<i class=\"fas fa-cube\" style=\"color: #4CAF50; flex-shrink: 0;\"></i>`
              : (sessionType === 'group'
                ? `<i class=\"fas fa-users\" style=\"color: #4CAF50; flex-shrink: 0;\"></i>`
                : `<i class=\"fas fa-user\" style=\"color: #4CAF50; flex-shrink: 0;\"></i>`)}
            <strong>${title}</strong> ${sessionBadge} ${blockBadge}
          </div>
          <div style="font-size: 0.85rem; color: #666; margin-top: 4px;">
            ${isBlockSession ? `<strong>Dates:</strong> ${blockDates.map(d => formatDateForDisplay(d)).join(', ')}` : `${formatDateForDisplay(date)} &bull; ${time}`}
          </div>
          ${priceLocationInfo}
        </div>
        <div style="text-align: right; font-size: 0.9rem; color: #666;">
          <strong>${bookings.length}</strong> booking${bookings.length !== 1 ? 's' : ''}
        </div>
      </div>
    `;
    headerDiv.innerHTML = headerHTML;
    
    // Create bookings container
    const bookingsContainer = document.createElement('div');
    bookingsContainer.style.cssText = `display: ${isSessionExpanded ? 'block' : 'none'}; background: #f9f9f9; border-left: 4px solid #4CAF50;`;
    
    // Add individual booking cards inside
    bookings.forEach(bookingGroup => {
      const {name, email} = bookingGroup;
      const status = getBookingStatus(email, isBlockSession ? blockDates[0] : date, time, title);
      const isConfirmed = status === 'Confirmed';

      // Get expiryTimestamp from booking mapping
      let expiryDisplay = '';
      const mapping = findBookingMapping(email, isBlockSession ? blockDates[0] : date, time, title)?.mapping;
      if (!isConfirmed && mapping && mapping.expiryTimestamp) {
        const expiryDate = new Date(mapping.expiryTimestamp * 1000);
        // Format as YYYY-MM-DD HH:mm
        const pad = n => n.toString().padStart(2, '0');
        const formatted = `${expiryDate.getFullYear()}-${pad(expiryDate.getMonth()+1)}-${pad(expiryDate.getDate())} ${pad(expiryDate.getHours())}:${pad(expiryDate.getMinutes())}`;
        expiryDisplay = `<div style=\"font-size:0.75rem;color:#E65100;white-space:nowrap;display:block;margin-top:2px;\"><i class=\"fas fa-hourglass-end\"></i> Expires: ${formatted}</div>`;
      }

      const bookingCard = document.createElement('div');
      bookingCard.style.cssText = `
        padding: 12px 16px;
        border-bottom: 1px solid #e0e0e0;
        display: flex;
        flex-direction: column;
        gap: 12px;
      `;
      bookingCard.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; flex-wrap: wrap;">
          <div style="flex: 1; min-width: 0;">
            <div class="booking-person" style="margin-bottom: 4px;">
              <i class="fas fa-user"></i>
              ${name}
            </div>
            <div class="booking-person" style="margin-bottom: 8px; font-size: 0.7rem;">
              <i class="fas fa-envelope"></i>
              ${email}
            </div>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 0; flex-wrap:nowrap;">
              <div style="font-size: 0.8rem; font-weight: 600; padding: 4px 10px; border-radius: 12px; white-space: nowrap; display: inline-block; ${isConfirmed ? 'background: #C8E6C9; color: #2E7D32;' : 'background: #FFE0B2; color: #E65100;'}">
                ${status}
              </div>
            </div>
            ${expiryDisplay}
          </div>
          <div style="display: flex; flex-direction: column; gap: 2px; align-items: stretch; flex-shrink: 0;">
            <button class="confirm-booking-btn" data-name="${name}" data-email="${email}" data-date="${isBlockSession ? blockDates[0] : date}" data-time="${time}" data-title="${title}" data-is-block="${isBlockSession}" data-block-dates="${isBlockSession ? blockDates.join(',') : ''}" style="padding: 2px 8px; margin: 0; border: none; border-radius: 4px; background: #4CAF50; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">Confirm</button>
            <button class="edit-booking-btn" data-name="${name}" data-email="${email}" data-date="${isBlockSession ? blockDates[0] : date}" data-time="${time}" data-title="${title}" data-is-block="${isBlockSession}" data-block-dates="${isBlockSession ? blockDates.join(',') : ''}" style="padding: 2px 8px; margin: 0; border: none; border-radius: 4px; background: #2196F3; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">Edit</button>
            <button class="delete-booking-btn" data-email="${email}" data-date="${isBlockSession ? blockDates[0] : date}" data-time="${time}" data-title="${title}" data-is-block="${isBlockSession}" data-block-dates="${isBlockSession ? blockDates.join(',') : ''}" style="padding: 2px 8px; margin: 0; border: none; border-radius: 4px; background: #f44336; color: white; cursor: pointer; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">Delete</button>
          </div>
          </div>
          </div>
        </div>
      `;
// Change wrapper to vertical stack
      const lastBookingCard = bookingsContainer.lastElementChild;
      if (lastBookingCard) {
        const actionWrapper = lastBookingCard.querySelector('div[style*="gap: 8px"][style*="align-items: center"][style*="flex-shrink: 0"]');
        if (actionWrapper) {
          actionWrapper.style.flexDirection = 'column';
          actionWrapper.style.alignItems = 'stretch';
        }
      }

      bookingsContainer.appendChild(bookingCard);
    });
    
    // Toggle expand/collapse and track state
    headerDiv.addEventListener('click', () => {
      const isExpanded = bookingsContainer.style.display !== 'none';
      bookingsContainer.style.display = isExpanded ? 'none' : 'block';
      // Update tracked state
      if (isExpanded) {
        expandedSessionCards.delete(sessionKey);
      } else {
        expandedSessionCards.add(sessionKey);
      }
    });
    
    sessionCard.appendChild(headerDiv);
    sessionCard.appendChild(bookingsContainer);
    allBookingsDiv.appendChild(sessionCard);
  });

  // Add event listeners for confirm and delete buttons
  allBookingsDiv.querySelectorAll('.confirm-booking-btn').forEach(btn => {
      // Add event listeners for edit buttons
      allBookingsDiv.querySelectorAll('.edit-booking-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          // Show the edit modal
          const modal = document.getElementById('editBookingModal');
          modal.style.display = 'flex';
          document.body.classList.add('modal-open');

          // Autofill fields
          document.getElementById('editBookingName').value = btn.getAttribute('data-name') || '';
          document.getElementById('editBookingEmail').value = btn.getAttribute('data-email') || '';
          // Date, Time, and Title fields removed from modal
          // Set status dropdown to 'confirmed' or 'pending' (lowercase)
          const statusText = btn.closest('.all-booking-card')?.querySelector('.booking-status-badge')?.textContent?.trim().toLowerCase() || '';
          if (statusText === 'confirmed' || statusText === 'pending') {
            document.getElementById('editBookingStatus').value = statusText;
          } else {
            document.getElementById('editBookingStatus').value = '';
          }
        });
        // Close modal logic
        document.getElementById('closeEditBookingModal').onclick = function() {
          document.getElementById('editBookingModal').style.display = 'none';
          document.body.classList.remove('modal-open');
        };
      });
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const name = btn.getAttribute('data-name');
      const email = btn.getAttribute('data-email');
      const date = btn.getAttribute('data-date');
      const time = btn.getAttribute('data-time');
      const title = btn.getAttribute('data-title');
      const isBlock = btn.getAttribute('data-is-block') === 'true';
      const blockDatesStr = btn.getAttribute('data-block-dates') || '';
      const blockDates = blockDatesStr ? blockDatesStr.split(',') : [];
      
      await adminSendConfirmation(email, date, time, title, name, blockDates);
    });
  });

  allBookingsDiv.querySelectorAll('.delete-booking-btn').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (!confirm('Are you sure you want to delete this booking?')) return;

      const name = btn.getAttribute('data-name') || '';
      const email = btn.getAttribute('data-email');
      const date = btn.getAttribute('data-date');
      const time = btn.getAttribute('data-time');
      const title = btn.getAttribute('data-title');
      const isBlock = btn.getAttribute('data-is-block') === 'true';
      const blockDatesStr = btn.getAttribute('data-block-dates') || '';
      const blockDates = blockDatesStr ? blockDatesStr.split(',') : [];

      console.log('[CANCEL BOOKING] Attempting to delete booking:', {
        name, email, date, time, title, isBlock, blockDatesStr, blockDates
      });
      try {
        await refreshBookingMappings();
        const mappingFound = findBookingMapping(email, date, time, title);
        const bookingId = mappingFound ? mappingFound.bookingId : '';
        console.log('[CANCEL BOOKING] Booking mapping found:', mappingFound);
        console.log('[CANCEL BOOKING] BookingId:', bookingId);

        // Use the backend API to delete the booking (handles block sessions properly)
        const payload = {
          name,
          email,
          date,
          time,
          title,
          isBlock,
          blockDates,
          bookingId
        };
        console.log('[CANCEL BOOKING] Sending payload to cancelBooking.php:', payload);
        const res = await fetch(PHP_PATH + 'cancelBooking.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          let errData = null;
          try { errData = await res.json(); } catch (err) { errData = {}; }
          console.error('[CANCEL BOOKING] Backend error response:', errData);
          throw new Error(errData.message || 'Failed to delete booking');
        }

        const result = await res.json();
        console.log('[CANCEL BOOKING] Backend success response:', result);
        await refreshBookingMappings();
        await renderAllBookings();
        await updateSummaryBar();
        showToast('Booking deleted successfully');
      } catch (e) {
        console.error('[CANCEL BOOKING] Delete error:', e);
        showToast('Error deleting booking: ' + e.message, {error: true});
      }
    });
  });

  // Update previous booking IDs for next refresh
  previousBookingIds=currentBookingIds;
}

// --- Check if waitlist data has changed since last render ---
function hasWaitlistChanged(newData) {
  // Always re-render if view mode changed
  if (previousWaitlistViewMode !== adminViewMode) return true;
  
  if (!previousWaitlistData) return true; // First render
  
  // Compare JSON stringified versions for deep equality
  const newJson = JSON.stringify(newData);
  const prevJson = JSON.stringify(previousWaitlistData);
  return newJson !== prevJson;
}

// --- render waitlist with proper table/aesthetic mode handling ---
async function renderWaitlist(){
  ensureAdminTableStyles();
  const waitlistContainer = document.getElementById('waitlistContainer');
  
  // Get fresh waitlist data
  const waitlistData = await getWaitlist();
  
  // Check if data has changed; skip render if not
  if (!hasWaitlistChanged(waitlistData)) {
    // Even when skipping render, update the view mode tracker to keep it in sync
    previousWaitlistViewMode = adminViewMode;
    return; // No changes, skip rendering
  }
  
  // Data has changed, update stored snapshot
  previousWaitlistData = JSON.parse(JSON.stringify(waitlistData));
  previousWaitlistViewMode = adminViewMode;
  
  // Clear container to remove any stale content from previous async operations
  waitlistContainer.innerHTML = '';
  
  // TABLE MODE: Render separate tables for each session with full details
  if (adminViewMode === 'table') {
    const emptyWaitlist = document.getElementById('emptyWaitlist');
    const slotsData = await getAvailableSlots();
    const bookingsData = await getBookings();
    
    if (!waitlistData || Object.keys(waitlistData).length === 0) {
      waitlistContainer.innerHTML = '<div style="color:#888;padding:24px;text-align:center;">No sessions with waitlists</div>';
      emptyWaitlist.style.display = 'block';
      return;
    }
    
    // Hide the static empty state since we have data
    emptyWaitlist.style.display = 'none';
    
    // Switch to flex layout for vertical scrolling in table mode
    waitlistContainer.style.display = 'flex';
    waitlistContainer.style.flexDirection = 'column';
    
    // Build session info map from slots and bookings
    const sessionInfoMap = {}; // {sessionKey: {title, capacity, booked, status, date, time}}
    Object.entries(slotsData).forEach(([date, slots]) => {
      slots.forEach(slot => {
        const key = `${date}_${slot.time}_${slot.title}`;
        const booked = (bookingsData && bookingsData[date]) ? 
          bookingsData[date].filter(b => {
            const parts = b.match(/^(.+?)\s*-\s*(.+?)\s*\(/);
            const bTime = parts ? parts[1] : null;
            const titleMatch = b.match(/-\s*(.+?)\s*\(/);
            const bTitle = titleMatch ? titleMatch[1].trim() : null;
            return bTime === slot.time && bTitle === slot.title;
          }).length : 0;
        const capacity = slot.numberOfSpots || 1;
        const status = booked >= capacity ? 'Full' : `${capacity - booked} spots`;
        // DEBUG: Waitlist spot logic
        console.log('%c[WAITLIST SPOT DEBUG]','color:magenta;font-weight:bold',{
          date,
          time: slot.time,
          title: slot.title,
          booked,
          capacity,
          spotsAvailable: capacity - booked,
          status
        });
        sessionInfoMap[key] = {
          title: slot.title,
          capacity: capacity,
          booked: booked,
          status: status,
          date: date,
          time: slot.time
        };
      });
    });
    
    // Build all content in a document fragment to prevent flicker
    const fragment = document.createDocumentFragment();
    const buttonHandlers = []; // Store button/handler pairs for later attachment
    
    // Create separate table for each session
    Object.entries(waitlistData).forEach(([sessionKey, sessionWaitlist]) => {
      if (!sessionWaitlist || !sessionWaitlist.length) return;
      
      // Get session info
      const sessionInfo = sessionInfoMap[sessionKey] || { title: 'Unknown', capacity: 0, booked: 0, status: 'Unknown', date: '', time: '' };
      
      // Create wrapper section for this session's table
      const sessionSection = document.createElement('div');
      sessionSection.style.marginBottom = '20px';
      
      // Add session header
      const header = document.createElement('div');
      header.style.padding = '12px 16px';
      header.style.backgroundColor = '#f0f4f8';
      header.style.borderRadius = '8px 8px 0 0';
      header.style.fontSize = '0.65rem';
      header.style.fontWeight = '600';
      header.style.color = '#2c3e50';
      header.innerHTML = `${sessionInfo.title} - ${sessionInfo.time} (${sessionInfo.date})`;
      sessionSection.appendChild(header);
      
      // Create table
      const table = document.createElement('table');
      table.className = 'admin-table';
      table.style.tableLayout = 'auto';
      table.style.borderCollapse = 'collapse';
      
      const thead = document.createElement('thead');
      thead.innerHTML = `<tr>
        <th class="col-position" style="text-align:center;">Pos</th>
        <th class="col-name">Name</th>
        <th class="col-email">Email</th>
        <th class="col-title">Session Title</th>
        <th class="col-capacity">Capacity</th>
        <th class="col-status">Status</th>
        <th class="col-actions">Actions</th>
      </tr>`;
      table.appendChild(thead);
      
      const tbody = document.createElement('tbody');
      sessionWaitlist.forEach((entry, idx) => {
        const tr = document.createElement('tr');
        const position = idx + 1;
        const capacityText = `${sessionInfo.booked}/${sessionInfo.capacity}`;
        const actionsHtml = `<div style="display:flex;flex-direction:row;gap:4px;align-items:stretch;">
          <button class='reserve' data-session='${escapeHtml(sessionKey)}' data-email='${escapeHtml(entry.email||'')}' data-idx='${idx}' style="margin:0;padding:4px 6px;font-size:0.5rem;white-space:nowrap;flex:1;">Offer Spot</button>
          <button class='decline' data-session='${escapeHtml(sessionKey)}' data-email='${escapeHtml(entry.email||'')}' data-idx='${idx}' style="margin:0;padding:4px 6px;font-size:0.5rem;white-space:nowrap;flex:1;">Delete</button>
        </div>`.replace('flex-direction:row','flex-direction:column');
        
        tr.innerHTML = `
          <td class="col-position" style="text-align:center;white-space:nowrap;">${position}</td>
          <td class="col-name" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(entry.name||'')}</td>
          <td class="col-email" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(entry.email||'')}</td>
          <td class="col-title" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(sessionInfo.title)}</td>
          <td class="col-capacity" style="text-align:center;white-space:nowrap;">${capacityText}</td>
          <td class="col-status" style="text-align:center;white-space:nowrap;">${escapeHtml(sessionInfo.status)}</td>
          <td class="col-actions">${actionsHtml}</td>
        `;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      
      // Wrap table in horizontal scroll container
      const wrapper = document.createElement('div');
      wrapper.className = 'admin-table-wrapper';
      wrapper.appendChild(table);
      sessionSection.appendChild(wrapper);
      
      // Add to fragment
      fragment.appendChild(sessionSection);
      
      // Store button handlers for attachment after DOM update
      buttonHandlers.push({
        table: table,
        sessionInfo: sessionInfo
      });
    });
    
    // Update DOM once with entire fragment to prevent flicker
    waitlistContainer.innerHTML = '';
    waitlistContainer.appendChild(fragment);
    
    // Now attach event handlers after DOM is updated
    buttonHandlers.forEach(({table, sessionInfo}) => {
      table.querySelectorAll('button.reserve').forEach(btn => {
        btn.onclick = async (e) => {
          e.preventDefault();
          const sessionKey = btn.getAttribute('data-session');
          const email = btn.getAttribute('data-email');
          try {
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            const response = await fetch(PHP_PATH + 'sendOfferEmail.php', {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ email: email, date: sessionInfo.date, time: sessionInfo.time, title: sessionInfo.title, sessionKey: sessionKey, blockDates: [] })
            });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || 'Failed to send offer');
            }
            showToast(`Offer sent to ${email}!`);
            await renderWaitlist();
          } catch (error) {
            console.error('Offer error:', error);
            showToast('Error: ' + error.message, {error: true});
            btn.disabled = false;
            btn.innerHTML = 'Offer Spot';
          }
        };
      });
      table.querySelectorAll('button.decline').forEach(btn => {
        btn.onclick = async (e) => {
          e.preventDefault();
          const sessionKey = btn.getAttribute('data-session');
          const email = btn.getAttribute('data-email');
          if (!confirm(`Remove this person from waitlist?`)) return;
          try {
            const response = await fetch(PHP_PATH + 'deleteFromWaitlist.php', { 
              method: 'POST', 
              headers: {'Content-Type': 'application/json'}, 
              body: JSON.stringify({ date: sessionInfo.date, email: email, name: '' }) 
            });
            if (!response.ok) throw new Error('Failed to remove from waitlist');
            showToast(`Removed from waitlist`);
            await renderWaitlist();
          } catch (error) {
            console.error('Remove error:', error);
            showToast('Error: ' + error.message, {error: true});
          }
        };
      });
    });
    return;
  }
  
  // ========== CLEAR ALL DATA BUTTON HANDLER ==========
  const clearDataBtn = document.getElementById('clearDataBtn');
  if (clearDataBtn) {
    clearDataBtn.addEventListener('click', async () => {
      if (!confirm('Are you sure you want to DELETE ALL DATA? This cannot be undone.')) return;
      clearDataBtn.disabled = true;
      clearDataBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Clearing...';
      try {
        const response = await fetch('php/clearAllData.php', { method: 'POST' });
        const result = await response.json();
        if (!response.ok || result.status !== 'ok') {
          throw new Error(result.message || 'Failed to clear data');
        }
        showToast('All data cleared!', {error: false});
        setTimeout(() => { window.location.reload(); }, 1200);
      } catch (err) {
        showToast('Error: ' + err.message, {error: true});
        clearDataBtn.disabled = false;
        clearDataBtn.innerHTML = '<i class="fas fa-trash"></i> Clear ALL Data';
      }
    });
  }
  // AESTHETIC MODE: Render card-based view (existing code below)
  const waitlistSection = document.getElementById('waitlistSection');
  const emptyWaitlist = document.getElementById('emptyWaitlist');
  
  // Reset display to grid for aesthetic mode
  waitlistContainer.style.display = 'grid';
  waitlistContainer.style.flexDirection = '';
  
  // Save current expanded state before clearing
  document.querySelectorAll('.waitlist-card.expanded').forEach(card => {
    const key = `${card.dataset.date}-${card.dataset.session}`;
    expandedWaitlistCards.add(key);
  });

  Promise.all([
    getWaitlist(),
    getAvailableSlots(),
    getBookings(),
    fetch('php/getOffers.php').then(r => r.json())
  ])
    .then(([waitlistData, slotsData, bookingsData, offersData]) => {
      try {
        // Build a map of dates with their sessions
        const sessionMap = {}; // {date: {time-title: {count, people: [], blockDates: [], sessionType, blockId}}}

        Object.entries(waitlistData).forEach(([date, entries]) => {
          if (!sessionMap[date]) sessionMap[date] = {};
          entries.forEach(entry => {
            const key = `${entry.time}-${entry.title}`;
            
            // For block entries, only count them once (they're already stored under first date only)
            if (entry.isBlock && entry.blockId) {
              // Block entry - use blockId as key to ensure uniqueness
              const blockKey = `${entry.time}-${entry.title}-${entry.blockId}`;
              if (!sessionMap[date][blockKey]) {
                sessionMap[date][blockKey] = { 
                  time: entry.time, 
                  title: entry.title, 
                  sessionType: entry.sessionType, 
                  blockDates: entry.blockDates || [], 
                  blockId: entry.blockId,
                  isBlock: true,
                  people: [] 
                };
              }
              sessionMap[date][blockKey].people.push(entry);
            } else {
              // Single session entry
              if (!sessionMap[date][key]) {
                sessionMap[date][key] = { time: entry.time, title: entry.title, sessionType: entry.sessionType, blockDates: [], people: [] };
              }
              sessionMap[date][key].people.push(entry);
            }
          });
        });

        // Extract block dates from slots for display (if not already in waitlist entry)
        Object.entries(slotsData).forEach(([slotDate, slots]) => {
          slots.forEach(slot => {
            if (slot.blockDates && slot.blockDates.length > 0) {
              Object.keys(sessionMap).forEach(mapDate => {
                const key = `${slot.time}-${slot.title}`;
                if (sessionMap[mapDate][key] && !sessionMap[mapDate][key].blockDates.length) {
                  sessionMap[mapDate][key].blockDates = slot.blockDates;
                }
              });
            }
          });
        });

        if (Object.keys(sessionMap).length === 0) {
          waitlistSection.style.display = 'block';
          waitlistContainer.innerHTML = '';
          emptyWaitlist.style.display = 'block';
          expandedWaitlistCards.clear();
          return;
        }

        waitlistSection.style.display = 'block';
        waitlistContainer.innerHTML = '';
        emptyWaitlist.style.display = 'none';

        // Create cards for each session with waitlist
        Object.entries(sessionMap).sort((a, b) => new Date(a[0]) - new Date(b[0])).forEach(([date, sessions]) => {
          Object.entries(sessions).forEach(([sessionKey, sessionData]) => {

            const {time, title, sessionType, blockDates, blockId, isBlock, people} = sessionData;
            const count = people.length;

            // Find matching slot to get booked/total ratio
            let bookedSpots = 0;
            let totalSpots = 0;

            // For block sessions, use first date to get capacity
            const lookupDate = (isBlock && blockDates && blockDates.length > 0) ? blockDates[0] : date;

            if (isBlock && blockId && blockDates && blockDates.length > 0) {
              // Find any slot across all blockDates with matching blockId and use its bookedUsers
              let found = false;
              for (const d of blockDates) {
                if (slotsData[d]) {
                  for (const slot of slotsData[d]) {
                    if (slot.blockId === blockId && Array.isArray(slot.bookedUsers)) {
                      bookedSpots = slot.bookedUsers.length;
                      found = true;
                      break;
                    }
                  }
                }
                if (found) break;
              }
            } else if (slotsData[lookupDate]) {
              // Single session: use bookedUsers from the slot
              const dateSlots = slotsData[lookupDate];
              const matchingSlot = Object.values(dateSlots).find(slot => slot.time === time && slot.title === title);
              if (matchingSlot && Array.isArray(matchingSlot.bookedUsers)) bookedSpots = matchingSlot.bookedUsers.length;
            }

            // For block sessions, get totalSpots from any slot with matching blockId (use capacity field)
            if (isBlock && blockId && blockDates && blockDates.length > 0) {
              // Find any slot across all blockDates with matching blockId and use its capacity
              let found = false;
              for (const d of blockDates) {
                if (slotsData[d]) {
                  for (const slot of slotsData[d]) {
                    if (slot.blockId === blockId && slot.capacity) {
                      totalSpots = slot.capacity;
                      found = true;
                      break;
                    }
                  }
                }
                if (found) break;
              }
            } else if (slotsData[lookupDate]) {
              const dateSlots = slotsData[lookupDate];
              const matchingSlot = Object.values(dateSlots).find(slot => slot.time === time && slot.title === title);
              if (matchingSlot) totalSpots = matchingSlot.capacity || matchingSlot.numberOfSpots || 0;
            }
            // --- MAGENTA DEBUG LOG: Waitlist spot available logic (Aesthetic Mode) ---
            console.log('%c[DEBUG][AESTHETIC] Waitlist Spot Logic:', 'color:magenta;font-weight:bold;', {
              sessionKey,
              isBlock,
              blockDates,
              blockId,
              lookupDate,
              bookedSpots,
              totalSpots,
              peopleCount: count
            });

            // For block sessions, if totalSpots is set and bookedSpots is 0, availableSpots should be totalSpots
            let availableSpots = totalSpots - bookedSpots;
            if (isBlock && totalSpots > 0 && bookedSpots === 0) {
              availableSpots = totalSpots;
            }
            // Clamp to zero to avoid negative spots
            availableSpots = Math.max(0, availableSpots);

            const card = document.createElement('div');
            card.className = 'waitlist-card';
            card.dataset.date = date;
            card.dataset.session = sessionKey;

            // Restore expanded state
            const cardKey = `${date}-${sessionKey}`;
            if (expandedWaitlistCards.has(cardKey)) card.classList.add('expanded');

            // For block sessions, display all 4 dates
            let dateDisplayText = '';
            if (isBlock && blockDates && blockDates.length > 0) {
              dateDisplayText = `Block Session (${blockDates.map(d => formatDateForDisplay(d)).join(', ')})`;
            } else {
              dateDisplayText = formatDateForDisplay(date);
            }

            card.innerHTML = `
              <div class="waitlist-info">
                <div class="waitlist-date-time">
                  ${isBlock ?
                    '<i class="fas fa-cube" style="color: #FF9800; flex-shrink: 0;"></i>' :
                    (sessionType === 'group' ?
                      '<i class="fas fa-users" style="color: #FF9800; flex-shrink: 0;"></i>' :
                      '<i class="fas fa-user" style="color: #FF9800; flex-shrink: 0;"></i>'
                    )
                  }
                  <strong>${title}</strong> - ${time}${isBlock ? ' (4-Week Block)' : ''}
                </div>
                <div style="font-size: 0.75rem; color: #666; margin-top: 4px;">${dateDisplayText}</div>
                <div class="waitlist-count-badge" style="margin-top: 8px;">${availableSpots} spots available - ${count} on list</div>
              </div>
            `;

            // Expand/collapse handler
            card.addEventListener('click', (e) => {
              if (e.target.closest('.waitlist-remove-btn')) return; // Don't toggle if clicking delete button
              // Close other cards
              document.querySelectorAll('.waitlist-card.expanded').forEach(c => {
                if (c !== card) {
                  c.classList.remove('expanded');
                  const otherKey = `${c.dataset.date}-${c.dataset.session}`;
                  expandedWaitlistCards.delete(otherKey);
                }
              });
              // Toggle this card
              card.classList.toggle('expanded');
              const key = `${card.dataset.date}-${card.dataset.session}`;
              if (card.classList.contains('expanded')) expandedWaitlistCards.add(key); else expandedWaitlistCards.delete(key);
            });

            // Create people list
            const peopleListDiv = document.createElement('div');
            peopleListDiv.className = 'waitlist-people-list';

            people.forEach((person, idx) => {
              const personDiv = document.createElement('div');
              personDiv.className = 'waitlist-person';
              const infoDiv = document.createElement('div');
              infoDiv.className = 'waitlist-person-info';
              const position = idx + 1;
              let ordinal = 'th';
              if (position % 10 === 1 && position !== 11) ordinal = 'st';
              else if (position % 10 === 2 && position !== 12) ordinal = 'nd';
              else if (position % 10 === 3 && position !== 13) ordinal = 'rd';
              const positionDisplay = `${position}${ordinal}`;
              let joinedDisplay = 'Unknown time';
              if (person.joinedAt) {
                const joinDate = new Date(person.joinedAt);
                if (!isNaN(joinDate.getTime())) joinedDisplay = formatDateForDisplay(person.joinedAt.split(' ')[0]);
              }

              // Find pending offer for this person/session
              let offerExpiryHtml = '';
              if (offersData && typeof offersData === 'object') {
                const offer = Object.values(offersData).find(o =>
                  o.email === person.email &&
                  o.title === title &&
                  o.time === time &&
                  o.status === 'pending'
                );
                if (offer && offer.expiresAt) {
                  offerExpiryHtml = `<div style="color:#b45309;font-size:0.85em;margin-top:2px;">Offer expires: <b>${escapeHtml(offer.expiresAt)}</b></div>`;
                }
              }

              infoDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 12px;">
                  <div>
                    <div class="waitlist-person-name">${person.name}</div>
                    <div class="waitlist-person-email">${person.email}</div>
                    ${offerExpiryHtml}
                  </div>
                  <div style="text-align: right; font-size: 0.85rem; color: #666;">
                    <div style="font-weight: 600; font-size: 0.9rem; color: #2E7D32;">#${positionDisplay}</div>
                    <div>Joined: ${joinedDisplay}</div>
                  </div>
                </div>
              `;
              const buttonsDiv = document.createElement('div');
              buttonsDiv.className = 'waitlist-person-buttons';
              const offerBtn = document.createElement('button');
              offerBtn.className = 'waitlist-offer-btn';
              offerBtn.innerHTML = '<i class="fas fa-check"></i> Offer Spot';
              offerBtn.disabled = availableSpots === 0;
              offerBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (offerBtn.disabled) return;
                try {
                  offerBtn.disabled = true;
                  offerBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sending...';
                  const response = await fetch(PHP_PATH + 'sendOfferEmail.php', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ email: person.email, name: person.name, date: date, time: time, title: title, sessionKey: sessionKey, blockDates: blockDates })
                  });
                  if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to send offer');
                  }
                  showToast(`Offer sent to ${person.name}! They have 24 hours to confirm or decline.`);
                  offerBtn.innerHTML = '<i class="fas fa-check"></i> Offer Spot';
                  await renderWaitlist();
                } catch (error) {
                  console.error('Offer error:', error);
                  showToast('Error sending offer: ' + error.message, {error: true});
                  offerBtn.disabled = availableSpots === 0;
                  offerBtn.innerHTML = '<i class="fas fa-check"></i> Offer Spot';
                }
              });
              const removeBtn = document.createElement('button');
              removeBtn.className = 'waitlist-remove-btn';
              removeBtn.innerHTML = '<i class="fas fa-trash"></i> Remove';
              removeBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!confirm(`Remove ${person.name} from waitlist?`)) return;
                try {
                  const response = await fetch(PHP_PATH + 'deleteFromWaitlist.php', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ date: date, email: person.email, name: person.name }) });
                  if (!response.ok) throw new Error('Failed to remove from waitlist');
                  showToast(`${person.name} removed from waitlist`);
                  await renderWaitlist();
                } catch (error) {
                  console.error('Remove from waitlist error:', error);
                  showToast('Error removing from waitlist: ' + error.message, {error: true});
                }
              });
              personDiv.appendChild(infoDiv);
              buttonsDiv.appendChild(offerBtn);
              buttonsDiv.appendChild(removeBtn);
              personDiv.appendChild(buttonsDiv);
              peopleListDiv.appendChild(personDiv);
            });
            card.appendChild(peopleListDiv);
            waitlistContainer.appendChild(card);
          });
        });
      } catch (error) {
        console.error('Render waitlist error:', error);
        waitlistSection.style.display = 'none';
      }
    })
    .catch(error => {
      console.error('Render waitlist error:', error);
      waitlistSection.style.display = 'none';
    });
}

// --- render available slots for selected date ---
async function renderBookings(){
  if(!selectedDate) return;
  
  // Render all bookings and available slots
  await renderAllBookings();
  await renderAllAvailableSlots();
}

// --- Start auto-refresh for all bookings and available slots ---
function startAutoRefresh(){
  // Refresh confirmation status from booking mappings
  refreshBookingMappings();
  
  if(autoRefreshInterval) clearInterval(autoRefreshInterval);
  autoRefreshInterval=setInterval(async ()=>{
    if(isAutoRefreshing) return; // Skip if already refreshing
    isAutoRefreshing=true;
    try {
      // Call cleanupExpiredOffers.php before refresh
      try {
        const res = await fetch('php/cleanupExpiredOffers.php', { method: 'GET' });
        const txt = await res.text();
        console.log('CleanupExpiredOffers:', txt);
      } catch (err) {
        console.warn('CleanupExpiredOffers error:', err);
      }
      // Call removeExpiredPendingBookings.php before refresh
      try {
        const res2 = await fetch('php/removeExpiredPendingBookings.php', { method: 'GET' });
        const txt2 = await res2.text();
        console.log('RemoveExpiredPendingBookings:', txt2);
      } catch (err) {
        console.warn('RemoveExpiredPendingBookings error:', err);
      }
      console.log('=== AUTO REFRESH DEBUG ===');
      console.log('1. SCANNING DOM BEFORE REFRESH...');
      
      // Scan DOM to capture current expanded/collapsed state BEFORE refresh
      // This ensures we capture any manual clicks the user made
      const currentExpandedSessions = new Set();
      document.querySelectorAll('[data-session-key]').forEach(headerDiv => {
        const sessionKey = headerDiv.getAttribute('data-session-key');
        const bookingsContainer = headerDiv.nextElementSibling;
        // Check if container exists AND is actually visible
        const isExpanded = bookingsContainer && bookingsContainer.style.display !== 'none' && bookingsContainer.offsetHeight > 0;
        if (isExpanded) {
          currentExpandedSessions.add(sessionKey);
        }
        console.log(`   Session: ${sessionKey} -> ${isExpanded ? 'EXPANDED' : 'COLLAPSED'}`);
      });
      console.log('2. SCANNED SESSIONS:', currentExpandedSessions);
      
      // REPLACE expandedSessionCards with scanned state to ensure accuracy
      expandedSessionCards = currentExpandedSessions;
      console.log('3. expandedSessionCards REPLACED with:', expandedSessionCards);
      
      // Also scan slot cards for expanded state
      const currentExpandedSlots = new Set();
      document.querySelectorAll('[data-slot-key]').forEach(card => {
        const slotKey = card.getAttribute('data-slot-key');
        if (card.classList.contains('expanded') && card.offsetHeight > 0) {
          currentExpandedSlots.add(slotKey);
        }
      });
      // REPLACE expandedSlotCards with scanned state to ensure accuracy
      expandedSlotCards = currentExpandedSlots;
      
      // Store scroll positions for all table wrappers
      const tableScrolls = new Map();
      document.querySelectorAll('.admin-table-wrapper').forEach(wrapper => {
        const key = wrapper.parentElement?.id || Math.random();
        tableScrolls.set(key, wrapper.scrollLeft);
      });
      const bookingsScroll=document.getElementById('allBookings')?.parentElement?.scrollTop || 0;
      const slotsScroll=document.getElementById('allAvailableSlots')?.parentElement?.scrollTop || 0;
      
      // Now render with the accurate state
      console.log('4. CALLING renderAllBookings() with expandedSessionCards:', expandedSessionCards);
      await renderAllBookings();
      
      // Restore bookings scroll immediately after rendering
      requestAnimationFrame(() => {
        if(document.getElementById('allBookings')?.parentElement) {
          document.getElementById('allBookings').parentElement.scrollTop=bookingsScroll;
        }
        document.querySelectorAll('.admin-table-wrapper').forEach(wrapper => {
          const key = wrapper.parentElement?.id || Math.random();
          if(tableScrolls.has(key)) {
            wrapper.scrollLeft = tableScrolls.get(key);
          }
        });
      });
      
      console.log('5. AFTER renderAllBookings(), checking DOM...');
      // Sync bookings DOM with state immediately after rendering
      setTimeout(() => {
        console.log('6. SYNC PHASE - expandedSessionCards is:', expandedSessionCards);
        document.querySelectorAll('[data-session-key]').forEach(headerDiv => {
          const sessionKey = headerDiv.getAttribute('data-session-key');
          const bookingsContainer = headerDiv.nextElementSibling;
          const shouldBeExpanded = expandedSessionCards.has(sessionKey);
          const isCurrentlyExpanded = bookingsContainer && bookingsContainer.style.display !== 'none';
          
          console.log(`   ${sessionKey}: should=${shouldBeExpanded}, is=${isCurrentlyExpanded}, container=${bookingsContainer ? 'exists' : 'MISSING'}`);
          
          // Force correct state if mismatch
          if (shouldBeExpanded && !isCurrentlyExpanded && bookingsContainer) {
            console.log(`     -> FIXING: setting to display:block`);
            bookingsContainer.style.display = 'block';
          } else if (!shouldBeExpanded && isCurrentlyExpanded && bookingsContainer) {
            console.log(`     -> FIXING: setting to display:none`);
            bookingsContainer.style.display = 'none';
          }
        });
        console.log('7. SYNC COMPLETE');
      }, 0);

      await renderAllAvailableSlots();
      
      // Restore slots scroll immediately
      requestAnimationFrame(() => {
        if(document.getElementById('allAvailableSlots')?.parentElement) {
          document.getElementById('allAvailableSlots').parentElement.scrollTop=slotsScroll;
        }
        document.querySelectorAll('.admin-table-wrapper').forEach(wrapper => {
          const key = wrapper.parentElement?.id || Math.random();
          if(tableScrolls.has(key)) {
            wrapper.scrollLeft = tableScrolls.get(key);
          }
        });
      });
      
      await renderPlayerProfiles();
      renderWaitlist();
      updateSummaryBar();
    } finally {
      isAutoRefreshing=false;
    }
  }, REFRESH_INTERVAL);
}

// --- Stop auto-refresh ---
function stopAutoRefresh(){
  if(autoRefreshInterval){
    clearInterval(autoRefreshInterval);
    autoRefreshInterval=null;
  }
}

// --- on date change ---
document.getElementById('adminDate').onchange=async ()=>{
  selectedDate=document.getElementById('adminDate').value;
  createAdminSlots();
  const slotsData=await getAvailableSlots();
  
  // Preserve slot metadata if it exists
  if(slotsData[selectedDate] && slotsData[selectedDate].length>0){
    const firstSlot=slotsData[selectedDate][0];
    document.getElementById('slotTitle').value=firstSlot.title || '';
    document.getElementById('numberOfSpots').value=firstSlot.numberOfSpots || 1;
    document.getElementById('sessionType').value=firstSlot.sessionType || 'group';
  } else {
    document.getElementById('slotTitle').value='';
    document.getElementById('numberOfSpots').value=1;
    document.getElementById('sessionType').value='group';
  }
  
  document.querySelectorAll('.admin-slot').forEach(d=>{
    const time=d.textContent.split('-')[0]; // Get just the start time
    if(slotsData[selectedDate] && slotsData[selectedDate].some(s=>(s.time||s)===time)) {
      d.classList.add('selected');
    }
  });
  renderAllBookings();
  renderAllAvailableSlots();
  renderWaitlist();
};

// Initialize
// Make page sections collapsible (default: expanded)
function initCollapsibleSections(){
  const container = document.querySelector('.admin-container');
  if (!container) return;
  // Find direct child sections that contain an h2 (common pattern in this page)
  const candidates = Array.from(container.querySelectorAll(':scope > div, :scope > section'));
  candidates.forEach(sec => {
    if (sec.dataset.collapsibleInitialized) return;
    const h2 = sec.querySelector('h2');
    if (!h2) return;
    // don't touch script-only containers
    if (sec.querySelector('script') && sec.children.length === 1) return;

    // Build header (keep existing h2 content)
    const header = document.createElement('div');
    header.className = 'section-header';
    header.tabIndex = 0;
    header.setAttribute('role','button');
    header.setAttribute('aria-expanded','true');
    const h2Clone = h2.cloneNode(true);
    header.appendChild(h2Clone);
    const che = document.createElement('span');
    che.className = 'section-chevron';
    che.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="6 9 12 15 18 9"></polyline></svg>';
    header.appendChild(che);

    // Insert header and wrap remaining content into body
    // Collect children except the original h2 and any leading scripts
    const body = document.createElement('div');
    body.className = 'section-body';

    // Wrap original content into an inner container so we can add
    // top padding / subtle separator when expanded without creating
    // external gaps when collapsed.
    const inner = document.createElement('div');
    inner.className = 'section-body-inner';

    Array.from(sec.children).forEach(child => {
      if (child === h2) return; // skip original heading
      if (child.tagName && child.tagName.toLowerCase() === 'script') return; // leave scripts outside
      inner.appendChild(child);
    });

    body.appendChild(inner);

    // Replace original h2 with header and append the body
    sec.insertBefore(header, h2);
    sec.appendChild(body);
    if (h2.parentNode) h2.parentNode.removeChild(h2);

    // Prepare animation helpers
    function collapseInstant() {
      header.setAttribute('aria-expanded','false');
      sec.classList.add('section-collapsed');
      body.style.height = '0px';
      body.style.opacity = '0';
    }
    function expandAnimated(){
      header.setAttribute('aria-expanded','true');
      sec.classList.remove('section-collapsed');
      const full = body.scrollHeight;
      body.style.height = full + 'px';
      body.style.opacity = '1';
      // clear height after transition so content can size naturally
      setTimeout(()=>{ if (header.getAttribute('aria-expanded')==='true') body.style.height = ''; }, 300);
    }
    function toggle(){
      const isOpen = header.getAttribute('aria-expanded') === 'true';
      if (isOpen) {
        // animate close
        const full = body.scrollHeight;
        body.style.height = full + 'px';
        // allow layout
        requestAnimationFrame(()=>{
          body.style.height = '0px';
          body.style.opacity = '0';
          header.setAttribute('aria-expanded','false');
          sec.classList.add('section-collapsed');
        });
      } else {
        expandAnimated();
      }
    }

    // Attach interactions
    header.addEventListener('click', (e)=>{ e.preventDefault(); toggle(); });
    header.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); } });

    // If the section is initially hidden via inline style (display:none), keep it collapsed visually
    if (getComputedStyle(sec).display === 'none') {
      collapseInstant();
    }

    sec.dataset.collapsibleInitialized = '1';
  });
}

ensurePlayerProfilesSection();
initCollapsibleSections();
renderAllBookings();
renderAllAvailableSlots();
renderPlayerProfiles();
renderWaitlist();
updateSummaryBar();
startAutoRefresh();

// Stop auto-refresh when page is hidden, resume when visible
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden) stopAutoRefresh();
  else startAutoRefresh();
});

// --- BOOKING TRACKING AUDIT FUNCTION ---
// Call window.auditBookingTracking() from console to verify consistency
window.auditBookingTracking = async function() {
  // console.log('========== BOOKING TRACKING AUDIT ==========');
  const bookings = await getBookings();
  const slots = await getAvailableSlots();
  
  let totalBookingEntries = 0;
  let totalBookedUsers = 0;
  let mismatches = 0;
  let detailedIssues = [];
  
  // Count booking entries
  Object.entries(bookings).forEach(([date, bookingList]) => {
    if(Array.isArray(bookingList)) {
      totalBookingEntries += bookingList.length;
    }
  });
  
  // Count bookedUsers entries and verify consistency
  Object.entries(slots).forEach(([date, slotList]) => {
    if(Array.isArray(slotList)) {
      slotList.forEach(slot => {
        if(slot.bookedUsers && Array.isArray(slot.bookedUsers)) {
          totalBookedUsers += slot.bookedUsers.length;
          
          // Verify each user is in the bookings list
          slot.bookedUsers.forEach(user => {
            const bookingString = `${slot.time} - ${slot.title} (${user.name}) (${user.email})`;
            if(bookings[date]) {
              if(!bookings[date].some(b => b === bookingString)) {
                const issue = `MISMATCH on ${date}: User "${user.name}" in slot.bookedUsers but NOT in bookings`;
                console.warn(issue);
                detailedIssues.push(issue);
                mismatches++;
              }
            } else {
              const issue = `MISMATCH on ${date}: slot.bookedUsers exists but no bookings entry for date`;
              console.warn(issue);
              detailedIssues.push(issue);
              mismatches++;
            }
          });
        }
      });
    }
  });
  
  // Verify each booking entry has a corresponding bookedUser
  Object.entries(bookings).forEach(([date, bookingList]) => {
    if(Array.isArray(bookingList)) {
      bookingList.forEach(booking => {
        const parts = booking.match(/^(.+?)\s*-\s*(.+?)\s*\(([^)]+)\)\s*\(([^)]+)\)$/);
        if(parts) {
          const time = parts[1];
          const title = parts[2];
          const name = parts[3];
          const email = parts[4];
          
          const slot = slots[date]?.find(s => s.time === time && s.title === title);
          if(slot) {
            if(!slot.bookedUsers || !slot.bookedUsers.some(u => u.name === name && u.email === email)) {
              const issue = `MISMATCH on ${date}: Booking "${booking}" NOT in slot.bookedUsers`;
              console.warn(issue);
              detailedIssues.push(issue);
              mismatches++;
            }
          } else {
            const issue = `MISMATCH on ${date}: Booking references slot ${time}/${title} but slot NOT FOUND`;
            console.warn(issue);
            detailedIssues.push(issue);
            mismatches++;
          }
        }
      });
    }
  });
  
  const result = {
    totalBookingEntries,
    totalBookedUsers,
    mismatches,
    isConsistent: mismatches === 0,
    issues: detailedIssues
  };
  
  console.log(`\nâœ“ Total booking entries in bookings.json: ${totalBookingEntries}`);
  console.log(`âœ“ Total booked users in availableSlots.json: ${totalBookedUsers}`);
  console.log(`${mismatches === 0 ? 'âœ… PASS' : 'âŒ FAIL'}: ${mismatches} data consistency issues found\n`);
  console.log('===========================================\n');
  
  return result;
};

// Custom email form - frontend only, no JavaScript functionality yet

// Analytics modal setup
const analyticsBtn = document.getElementById('analyticsBtn');
const analyticsModal = document.createElement('div');
analyticsModal.id = 'analyticsModal';
analyticsModal.style.cssText = `
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 9999;
  justify-content: center;
  align-items: center;
`;
analyticsModal.innerHTML = `
  <div style="background: white; border-radius: 12px; padding: 40px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
    <div style="font-size: 3rem; margin-bottom: 16px; color: #3498db;">
      <i class="fas fa-chart-line"></i>
    </div>
    <h2 style="margin: 0 0 12px 0; color: #2c3e50; font-size: 1.5rem;">Analytics</h2>
    <p style="color: #7f8c8d; margin: 0 0 24px 0; font-size: 1rem;">
      ðŸ“Š analytics and reporting coming soon...
    </p>

    <button onclick="document.getElementById('analyticsModal').style.display = 'none'" style="padding: 12px 24px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.95rem;">
      Close
    </button>
  </div>
`;
document.body.appendChild(analyticsModal);

analyticsBtn.addEventListener('click', () => {
  analyticsModal.style.display = 'flex';
});

analyticsModal.addEventListener('click', (e) => {
  if (e.target.id === 'analyticsModal') {
    analyticsModal.style.display = 'none';
  }
});

// Sync to Calendar Modal handlers
const syncToCalendarBtn = document.getElementById('syncToCalendarBtn');
const syncToCalendarModal = document.getElementById('syncToCalendarModal');
const syncToCalendarModalOverlay = document.getElementById('syncToCalendarModalOverlay');
const syncToCalendarModalClose = document.getElementById('syncToCalendarModalClose');
const syncToCalendarModalCloseBtn = document.getElementById('syncToCalendarModalCloseBtn');
const calendarSyncRange = document.getElementById('calendarSyncRange');

if (syncToCalendarBtn) {
  syncToCalendarBtn.addEventListener('click', () => {
    syncToCalendarModal.style.display = 'flex';
  });
}

if (syncToCalendarModalClose) {
  syncToCalendarModalClose.addEventListener('click', () => {
    syncToCalendarModal.style.display = 'none';
  });
}

if (syncToCalendarModalCloseBtn) {
  syncToCalendarModalCloseBtn.addEventListener('click', () => {
    syncToCalendarModal.style.display = 'none';
  });
}

if (syncToCalendarModalOverlay) {
  syncToCalendarModalOverlay.addEventListener('click', () => {
    syncToCalendarModal.style.display = 'none';
  });
}

if (calendarSyncRange) {
  calendarSyncRange.addEventListener('change', (e) => {
    const selectedOption = e.target.value;
    if (selectedOption) {
      handleCalendarSyncSelection(selectedOption);
    }
  });
}


// Placeholder function for calendar sync selection
// This will be implemented with actual calendar generation logic later

// Helper: Get date range based on option (week/month/all)
function getDateRangeForOption(option) {
  const today = new Date();
  let startDate, endDate;
  
  if (option === 'week') {
    // Get Monday-Sunday of current week
    const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
    const mondayOffset = currentDay === 0 ? -6 : 1 - currentDay; // If Sunday, go back 6 days
    
    const monday = new Date(today);
    monday.setDate(today.getDate() + mondayOffset);
    monday.setHours(0, 0, 0, 0);
    
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    sunday.setHours(23, 59, 59, 999);
    
    startDate = monday;
    endDate = sunday;
    
  } else if (option === 'month') {
    // Get first to last day of current month
    const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
    firstDay.setHours(0, 0, 0, 0);
    
    const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0);
    lastDay.setHours(23, 59, 59, 999);
    
    startDate = firstDay;
    endDate = lastDay;
    
  } else {
    // All sessions - no filtering
    startDate = new Date('2000-01-01');
    endDate = new Date('2099-12-31');
  }
  
  return { startDate, endDate };
}

// Helper: Filter sessions by date range
function filterSessionsByDateRange(allSlots, startDate, endDate) {
  const sessions = [];
  
  for (const dateKey in allSlots) {
    const slotDate = new Date(dateKey);
    
    if (slotDate >= startDate && slotDate <= endDate) {
      const slotsForDate = allSlots[dateKey];
      
      if (Array.isArray(slotsForDate)) {
        slotsForDate.forEach(slot => {
          sessions.push({
            date: dateKey,
            time: slot.time || '',
            title: slot.title || 'Session',
            sessionType: slot.sessionType || 'single',
            blockDates: slot.blockDates || [],
            location: slot.location || '',
            price: slot.price || ''
          });
        });
      }
    }
  }
  
  // Sort by date and time
  sessions.sort((a, b) => {
    const dateCompare = a.date.localeCompare(b.date);
    if (dateCompare !== 0) return dateCompare;
    return a.time.localeCompare(b.time);
  });
  
  return sessions;
}

// Helper: Generate Google Calendar URL
function generateGoogleCalendarURL(session) {
  const { date, time, title, sessionType, location } = session;
  
  // Parse date and time
  const [year, month, day] = date.split('-');
  const [hours, minutes] = time.split(':');
  
  // Create start datetime
  const startDateTime = new Date(year, month - 1, day, hours, minutes);
  
  // Assume 1 hour duration (you can adjust based on your session data)
  const endDateTime = new Date(startDateTime);
  endDateTime.setHours(endDateTime.getHours() + 1);
  
  // Format for Google Calendar (YYYYMMDDTHHmmss)
  const formatCalendarDate = (dt) => {
    const y = dt.getFullYear();
    const m = String(dt.getMonth() + 1).padStart(2, '0');
    const d = String(dt.getDate()).padStart(2, '0');
    const h = String(dt.getHours()).padStart(2, '0');
    const min = String(dt.getMinutes()).padStart(2, '0');
    const s = String(dt.getSeconds()).padStart(2, '0');
    return `${y}${m}${d}T${h}${min}${s}`;
  };
  
  const startStr = formatCalendarDate(startDateTime);
  const endStr = formatCalendarDate(endDateTime);
  
  // Build event details
  const eventTitle = encodeURIComponent(`${title} (${sessionType})`);
  const eventLocation = location ? encodeURIComponent(location) : '';
  const eventDetails = encodeURIComponent(`Session at ${time} on ${formatDateForDisplay(date)}`);
  
  // Google Calendar URL
  const url = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${eventTitle}&dates=${startStr}/${endStr}&details=${eventDetails}&location=${eventLocation}`;
  
  return url;
}

// Helper: Generate HTML for all calendar links
function generateCalendarLinksHTML(sessions) {
  let html = '<div style="display: flex; flex-direction: column; width: 100%;">';
  
  // Grid section for individual sessions
  html += '<div style="margin-bottom: 16px; width: 100%; box-sizing: border-box;">';
  html += '<div style="font-size: 0.85rem; font-weight: 600; color: #555; margin-bottom: 10px;">Click to add individual sessions:</div>';
  html += '<div style="display: flex; flex-wrap: nowrap; gap: 10px; overflow-x: auto; padding: 4px; align-items: flex-start; width: 100%; box-sizing: border-box;">';
  
  sessions.forEach(session => {
    const url = generateGoogleCalendarURL(session);
    const displayDate = formatDateForDisplay(session.date);
    const sessionType = session.sessionType === 'block' ? 'ðŸ“…' : 'ðŸŽ¯';
    
    html += `
      <a href="${url}" target="_blank" rel="noopener noreferrer" 
         style="display: flex; flex-direction: column; justify-content: space-between; padding: 16px; background: white; border: 2px solid #e5e7eb; border-radius: 8px; text-decoration: none; color: #333; transition: all 0.2s ease; height: 140px; width: calc(25% - 8px); min-width: 160px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: relative; overflow: hidden; flex-shrink: 0;"
         onmouseover="this.style.background='#f8f9fa'; this.style.borderColor='#3498db'; this.style.transform='translateY(-3px)'; this.style.boxShadow='0 4px 12px rgba(52, 152, 219, 0.3)';"
         onmouseout="this.style.background='white'; this.style.borderColor='#e5e7eb'; this.style.transform='translateY(0)'; this.style.boxShadow='0 1px 3px rgba(0,0,0,0.1)';">
        <i class="fas fa-external-link-alt" style="position: absolute; top: 8px; right: 8px; font-size: 0.7rem; color: #cbd5e0; transition: color 0.2s;" onmouseover="this.style.color='#3498db';" onmouseout="this.style.color='#cbd5e0';"></i>
        <div style="font-size: 1.5rem; margin-bottom: 6px;">${sessionType}</div>
        <div style="font-weight: 600; font-size: 0.8rem; color: #2c3e50; margin-bottom: 6px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; line-height: 1.3; flex: 1;">
          ${session.title}
        </div>
        <div style="font-size: 0.7rem; color: #7f8c8d; margin-bottom: 2px;">
          ${displayDate.split(' ').slice(0, 2).join(' ')}
        </div>
        <div style="font-size: 0.75rem; color: #3498db; font-weight: 700;">
          ${session.time}
        </div>
      </a>
    `;
  });
  
  html += '</div>'; // Close grid
  html += '</div>'; // Close grid section
  
  // Download button section - completely separate
  html += '<div style="margin-top: 5px; padding-top: 5px; border-top: 2px solid #e5e7eb; width: 100%;">';
  html += `<button onclick="downloadAllSessionsICS()" style="width: 100%; padding: 14px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 1rem; transition: all 0.2s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.5)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)';">`;
  html += `<i class="fas fa-cloud-download-alt"></i> DOWNLOAD ALL ${sessions.length} SESSIONS <i class="fas fa-arrow-right"></i>`;
  html += '</button>';
  html += '<div style="margin-top: 8px; font-size: 0.78rem; color: #666; text-align: center; line-height: 1.4;">';
  html += '<i class="fas fa-info-circle" style="color: #3498db;"></i> Downloads .ics file compatible with all calendar apps';
  html += '</div>';
  html += '</div>'; // Close download section
  
  html += '</div>'; // Close main wrapper
  
  return html;
}

// Helper: Generate ICS file content for all sessions
function generateICSContent(sessions) {
  let ics = 'BEGIN:VCALENDAR\r\n';
  ics += 'VERSION:2.0\r\n';
  ics += 'PRODID:-//HoopTheory//Booking System//EN\r\n';
  ics += 'CALSCALE:GREGORIAN\r\n';
  ics += 'METHOD:PUBLISH\r\n';
  
  sessions.forEach((session, index) => {
    const { date, time, title, sessionType, location } = session;
    
    // Parse date and time
    const [year, month, day] = date.split('-');
    const [hours, minutes] = time.split(':');
    
    // Create start datetime
    const startDateTime = new Date(year, month - 1, day, hours, minutes);
    const endDateTime = new Date(startDateTime);
    endDateTime.setHours(endDateTime.getHours() + 1);
    
    // Format for ICS (YYYYMMDDTHHmmss)
    const formatICSDate = (dt) => {
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, '0');
      const d = String(dt.getDate()).padStart(2, '0');
      const h = String(dt.getHours()).padStart(2, '0');
      const min = String(dt.getMinutes()).padStart(2, '0');
      const s = String(dt.getSeconds()).padStart(2, '0');
      return `${y}${m}${d}T${h}${min}${s}`;
    };
    
    const startStr = formatICSDate(startDateTime);
    const endStr = formatICSDate(endDateTime);
    const uid = `hooptheory-${date}-${time.replace(':', '')}-${index}@hooptheory.com`;
    
    ics += 'BEGIN:VEVENT\r\n';
    ics += `UID:${uid}\r\n`;
    ics += `DTSTAMP:${formatICSDate(new Date())}\r\n`;
    ics += `DTSTART:${startStr}\r\n`;
    ics += `DTEND:${endStr}\r\n`;
    ics += `SUMMARY:${title} (${sessionType})\r\n`;
    ics += `DESCRIPTION:Session at ${time} on ${formatDateForDisplay(date)}\r\n`;
    if (location) {
      ics += `LOCATION:${location}\r\n`;
    }
    ics += 'STATUS:CONFIRMED\r\n';
    ics += 'END:VEVENT\r\n';
  });
  
  ics += 'END:VCALENDAR\r\n';
  
  return ics;
}

// Store sessions globally for download function
let currentSessions = [];

// Update the main handler to store sessions
async function handleCalendarSyncSelection(option) {
  console.log('Calendar sync selection:', option);
  
  const placeholder = document.getElementById('calendarLinkPlaceholder');
  if (!placeholder) {
    console.error('Calendar placeholder not found');
    return;
  }
  
  // Show loading state
  placeholder.innerHTML = '<div style="color: #666;"><i class="fas fa-spinner fa-spin"></i> Generating calendar links...</div>';
  
  try {
    // Fetch all sessions
    const allSlots = await getAvailableSlots();
    
    // Get date range based on option
    const { startDate, endDate } = getDateRangeForOption(option);
    
    // Filter sessions
    const filteredSessions = filterSessionsByDateRange(allSlots, startDate, endDate);
    
    if (filteredSessions.length === 0) {
      placeholder.innerHTML = '<div style="color: #999; font-style: italic;">No sessions found for the selected time range.</div>';
      return;
    }
    
    // Store sessions globally for download function
    currentSessions = filteredSessions;
    
    // Generate calendar links
    const linksHTML = generateCalendarLinksHTML(filteredSessions);
    
    // Inject into placeholder
    placeholder.innerHTML = linksHTML;
    
  } catch (error) {
    console.error('Error generating calendar links:', error);
    placeholder.innerHTML = '<div style="color: #e74c3c;">Error generating calendar links. Please try again.</div>';
  }
}

// Function to download all sessions as ICS file
function downloadAllSessionsICS() {
  if (!currentSessions || currentSessions.length === 0) {
    alert('No sessions available to download');
    return;
  }
  
  const icsContent = generateICSContent(currentSessions);
  const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
  const url = window.URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `hooptheory-sessions-${new Date().getTime()}.ics`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  window.URL.revokeObjectURL(url);
  
  showToast('Calendar file downloaded! Import it into your calendar app.');
}

</script>
</body>
</html>
